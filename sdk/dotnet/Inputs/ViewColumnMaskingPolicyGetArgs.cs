// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Snowflake.Inputs
{

    public sealed class ViewColumnMaskingPolicyGetArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Specifies the masking policy to set on a column. For more information about this resource, see docs.
        /// </summary>
        [Input("policyName", required: true)]
        public Input<string> PolicyName { get; set; } = null!;

        [Input("usings")]
        private InputList<string>? _usings;

        /// <summary>
        /// Specifies the arguments to pass into the conditional masking policy SQL expression. The first column in the list specifies the column for the policy conditions to mask or tokenize the data and must match the column to which the masking policy is set. The additional columns specify the columns to evaluate to determine whether to mask or tokenize the data in each row of the query result when a query is made on the first column. If the USING clause is omitted, Snowflake treats the conditional masking policy as a normal masking policy.
        /// </summary>
        public InputList<string> Usings
        {
            get => _usings ?? (_usings = new InputList<string>());
            set => _usings = value;
        }

        public ViewColumnMaskingPolicyGetArgs()
        {
        }
        public static new ViewColumnMaskingPolicyGetArgs Empty => new ViewColumnMaskingPolicyGetArgs();
    }
}
