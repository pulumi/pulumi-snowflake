# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['FunctionPythonArgs', 'FunctionPython']

@pulumi.input_type
class FunctionPythonArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 handler: pulumi.Input[str],
                 return_type: pulumi.Input[str],
                 runtime_version: pulumi.Input[str],
                 schema: pulumi.Input[str],
                 arguments: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonArgumentArgs']]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 enable_console_output: Optional[pulumi.Input[bool]] = None,
                 external_access_integrations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 function_definition: Optional[pulumi.Input[str]] = None,
                 imports: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonImportArgs']]]] = None,
                 is_aggregate: Optional[pulumi.Input[str]] = None,
                 is_secure: Optional[pulumi.Input[str]] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 metric_level: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 null_input_behavior: Optional[pulumi.Input[str]] = None,
                 packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 return_results_behavior: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonSecretArgs']]]] = None,
                 trace_level: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a FunctionPython resource.
        :param pulumi.Input[str] database: The database in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[str] handler: The name of the handler function or class. If the handler is for a scalar UDF, returning a non-tabular value, the HANDLER value should be a function name. If the handler code is in-line with the CREATE FUNCTION statement, you can use the function name alone. When the handler code is referenced at a stage, this value should be qualified with the module name, as in the following form: `my_module.my_function`. If the handler is for a tabular UDF, the HANDLER value should be the name of a handler class.
        :param pulumi.Input[str] return_type: Specifies the results returned by the UDF, which determines the UDF type. Use `<result_data_type>` to create a scalar UDF that returns a single value with the specified data type. Use `TABLE (col_name col_data_type, ...)` to creates a table UDF that returns tabular results with the specified table column(s) and column type(s). For the details, consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages).
        :param pulumi.Input[str] runtime_version: Specifies the Python version to use. The supported versions of Python are: 3.9, 3.10, and 3.11.
        :param pulumi.Input[str] schema: The schema in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionPythonArgumentArgs']]] arguments: List of the arguments for the function. Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages) for more details.
        :param pulumi.Input[str] comment: Specifies a comment for the function.
        :param pulumi.Input[bool] enable_console_output: Enable stdout/stderr fast path logging for anonyous stored procs. This is a public parameter (similar to LOG*LEVEL). For more information, check [ENABLE*CONSOLE_OUTPUT docs](https://docs.snowflake.com/en/sql-reference/parameters#enable-console-output).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] external_access_integrations: The names of [external access integrations](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) needed in order for this function’s handler code to access external networks. An external access integration specifies [network rules](https://docs.snowflake.com/en/sql-reference/sql/create-network-rule) and [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) that specify external locations and credentials (if any) allowed for use by handler code when making requests of an external network, such as an external REST API.
        :param pulumi.Input[str] function_definition: Defines the handler code executed when the UDF is called. Wrapping `$$` signs are added by the provider automatically; do not include them. The `function_definition` value must be Python source code. For more information, see [Introduction to Python UDFs](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-introduction). To mitigate permadiff on this field, the provider replaces blank characters with a space. This can lead to false positives in cases where a change in case or run of whitespace is semantically significant.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionPythonImportArgs']]] imports: The location (stage), path, and name of the file(s) to import. A file can be a `.py` file or another type of file. Python UDFs can also read non-Python files, such as text files. For an example, see [Reading a file](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-examples.html#label-udf-python-read-files). Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#python).
        :param pulumi.Input[str] is_aggregate: Specifies that the function is an aggregate function. For more information about user-defined aggregate functions, see [Python user-defined aggregate functions](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-aggregate-functions). Available options are: "true" or "false". When the value is not set in the configuration the provider will put "default" there which means to use the Snowflake default for this value.
        :param pulumi.Input[str] log_level: LOG*LEVEL to use when filtering events For more information, check [LOG*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#log-level).
        :param pulumi.Input[str] metric_level: METRIC*LEVEL value to control whether to emit metrics to Event Table For more information, check [METRIC*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#metric-level).
        :param pulumi.Input[str] name: The name of the function; the identifier does not need to be unique for the schema in which the function is created because UDFs are identified and resolved by the combination of the name and argument types. Check the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages). Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[str] null_input_behavior: Specifies the behavior of the function when called with null inputs. Valid values are (case-insensitive): `CALLED ON NULL INPUT` | `RETURNS NULL ON NULL INPUT`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] packages: The name and version number of packages required as dependencies. The value should be of the form `package_name==version_number`.
        :param pulumi.Input[str] return_results_behavior: Specifies the behavior of the function when returning results. Valid values are (case-insensitive): `VOLATILE` | `IMMUTABLE`.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionPythonSecretArgs']]] secrets: Assigns the names of [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) to variables so that you can use the variables to reference the secrets when retrieving information from secrets in handler code. Secrets you specify here must be allowed by the [external access integration](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) specified as a value of this CREATE FUNCTION command’s EXTERNAL*ACCESS*INTEGRATIONS parameter.
        :param pulumi.Input[str] trace_level: Trace level value to use when generating/filtering trace events For more information, check [TRACE_LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#trace-level).
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "handler", handler)
        pulumi.set(__self__, "return_type", return_type)
        pulumi.set(__self__, "runtime_version", runtime_version)
        pulumi.set(__self__, "schema", schema)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if enable_console_output is not None:
            pulumi.set(__self__, "enable_console_output", enable_console_output)
        if external_access_integrations is not None:
            pulumi.set(__self__, "external_access_integrations", external_access_integrations)
        if function_definition is not None:
            pulumi.set(__self__, "function_definition", function_definition)
        if imports is not None:
            pulumi.set(__self__, "imports", imports)
        if is_aggregate is not None:
            pulumi.set(__self__, "is_aggregate", is_aggregate)
        if is_secure is not None:
            pulumi.set(__self__, "is_secure", is_secure)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if metric_level is not None:
            pulumi.set(__self__, "metric_level", metric_level)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if null_input_behavior is not None:
            pulumi.set(__self__, "null_input_behavior", null_input_behavior)
        if packages is not None:
            pulumi.set(__self__, "packages", packages)
        if return_results_behavior is not None:
            pulumi.set(__self__, "return_results_behavior", return_results_behavior)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if trace_level is not None:
            pulumi.set(__self__, "trace_level", trace_level)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The database in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def handler(self) -> pulumi.Input[str]:
        """
        The name of the handler function or class. If the handler is for a scalar UDF, returning a non-tabular value, the HANDLER value should be a function name. If the handler code is in-line with the CREATE FUNCTION statement, you can use the function name alone. When the handler code is referenced at a stage, this value should be qualified with the module name, as in the following form: `my_module.my_function`. If the handler is for a tabular UDF, the HANDLER value should be the name of a handler class.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: pulumi.Input[str]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter(name="returnType")
    def return_type(self) -> pulumi.Input[str]:
        """
        Specifies the results returned by the UDF, which determines the UDF type. Use `<result_data_type>` to create a scalar UDF that returns a single value with the specified data type. Use `TABLE (col_name col_data_type, ...)` to creates a table UDF that returns tabular results with the specified table column(s) and column type(s). For the details, consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages).
        """
        return pulumi.get(self, "return_type")

    @return_type.setter
    def return_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "return_type", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> pulumi.Input[str]:
        """
        Specifies the Python version to use. The supported versions of Python are: 3.9, 3.10, and 3.11.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        The schema in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonArgumentArgs']]]]:
        """
        List of the arguments for the function. Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages) for more details.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonArgumentArgs']]]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a comment for the function.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="enableConsoleOutput")
    def enable_console_output(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable stdout/stderr fast path logging for anonyous stored procs. This is a public parameter (similar to LOG*LEVEL). For more information, check [ENABLE*CONSOLE_OUTPUT docs](https://docs.snowflake.com/en/sql-reference/parameters#enable-console-output).
        """
        return pulumi.get(self, "enable_console_output")

    @enable_console_output.setter
    def enable_console_output(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_console_output", value)

    @property
    @pulumi.getter(name="externalAccessIntegrations")
    def external_access_integrations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The names of [external access integrations](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) needed in order for this function’s handler code to access external networks. An external access integration specifies [network rules](https://docs.snowflake.com/en/sql-reference/sql/create-network-rule) and [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) that specify external locations and credentials (if any) allowed for use by handler code when making requests of an external network, such as an external REST API.
        """
        return pulumi.get(self, "external_access_integrations")

    @external_access_integrations.setter
    def external_access_integrations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "external_access_integrations", value)

    @property
    @pulumi.getter(name="functionDefinition")
    def function_definition(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the handler code executed when the UDF is called. Wrapping `$$` signs are added by the provider automatically; do not include them. The `function_definition` value must be Python source code. For more information, see [Introduction to Python UDFs](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-introduction). To mitigate permadiff on this field, the provider replaces blank characters with a space. This can lead to false positives in cases where a change in case or run of whitespace is semantically significant.
        """
        return pulumi.get(self, "function_definition")

    @function_definition.setter
    def function_definition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_definition", value)

    @property
    @pulumi.getter
    def imports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonImportArgs']]]]:
        """
        The location (stage), path, and name of the file(s) to import. A file can be a `.py` file or another type of file. Python UDFs can also read non-Python files, such as text files. For an example, see [Reading a file](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-examples.html#label-udf-python-read-files). Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#python).
        """
        return pulumi.get(self, "imports")

    @imports.setter
    def imports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonImportArgs']]]]):
        pulumi.set(self, "imports", value)

    @property
    @pulumi.getter(name="isAggregate")
    def is_aggregate(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies that the function is an aggregate function. For more information about user-defined aggregate functions, see [Python user-defined aggregate functions](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-aggregate-functions). Available options are: "true" or "false". When the value is not set in the configuration the provider will put "default" there which means to use the Snowflake default for this value.
        """
        return pulumi.get(self, "is_aggregate")

    @is_aggregate.setter
    def is_aggregate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_aggregate", value)

    @property
    @pulumi.getter(name="isSecure")
    def is_secure(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "is_secure")

    @is_secure.setter
    def is_secure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_secure", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        LOG*LEVEL to use when filtering events For more information, check [LOG*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#log-level).
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="metricLevel")
    def metric_level(self) -> Optional[pulumi.Input[str]]:
        """
        METRIC*LEVEL value to control whether to emit metrics to Event Table For more information, check [METRIC*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#metric-level).
        """
        return pulumi.get(self, "metric_level")

    @metric_level.setter
    def metric_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_level", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the function; the identifier does not need to be unique for the schema in which the function is created because UDFs are identified and resolved by the combination of the name and argument types. Check the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages). Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nullInputBehavior")
    def null_input_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the behavior of the function when called with null inputs. Valid values are (case-insensitive): `CALLED ON NULL INPUT` | `RETURNS NULL ON NULL INPUT`.
        """
        return pulumi.get(self, "null_input_behavior")

    @null_input_behavior.setter
    def null_input_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "null_input_behavior", value)

    @property
    @pulumi.getter
    def packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name and version number of packages required as dependencies. The value should be of the form `package_name==version_number`.
        """
        return pulumi.get(self, "packages")

    @packages.setter
    def packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "packages", value)

    @property
    @pulumi.getter(name="returnResultsBehavior")
    def return_results_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the behavior of the function when returning results. Valid values are (case-insensitive): `VOLATILE` | `IMMUTABLE`.
        """
        return pulumi.get(self, "return_results_behavior")

    @return_results_behavior.setter
    def return_results_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "return_results_behavior", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonSecretArgs']]]]:
        """
        Assigns the names of [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) to variables so that you can use the variables to reference the secrets when retrieving information from secrets in handler code. Secrets you specify here must be allowed by the [external access integration](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) specified as a value of this CREATE FUNCTION command’s EXTERNAL*ACCESS*INTEGRATIONS parameter.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonSecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="traceLevel")
    def trace_level(self) -> Optional[pulumi.Input[str]]:
        """
        Trace level value to use when generating/filtering trace events For more information, check [TRACE_LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#trace-level).
        """
        return pulumi.get(self, "trace_level")

    @trace_level.setter
    def trace_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trace_level", value)


@pulumi.input_type
class _FunctionPythonState:
    def __init__(__self__, *,
                 arguments: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonArgumentArgs']]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 enable_console_output: Optional[pulumi.Input[bool]] = None,
                 external_access_integrations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fully_qualified_name: Optional[pulumi.Input[str]] = None,
                 function_definition: Optional[pulumi.Input[str]] = None,
                 function_language: Optional[pulumi.Input[str]] = None,
                 handler: Optional[pulumi.Input[str]] = None,
                 imports: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonImportArgs']]]] = None,
                 is_aggregate: Optional[pulumi.Input[str]] = None,
                 is_secure: Optional[pulumi.Input[str]] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 metric_level: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 null_input_behavior: Optional[pulumi.Input[str]] = None,
                 packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonParameterArgs']]]] = None,
                 return_results_behavior: Optional[pulumi.Input[str]] = None,
                 return_type: Optional[pulumi.Input[str]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonSecretArgs']]]] = None,
                 show_outputs: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonShowOutputArgs']]]] = None,
                 trace_level: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering FunctionPython resources.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionPythonArgumentArgs']]] arguments: List of the arguments for the function. Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages) for more details.
        :param pulumi.Input[str] comment: Specifies a comment for the function.
        :param pulumi.Input[str] database: The database in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[bool] enable_console_output: Enable stdout/stderr fast path logging for anonyous stored procs. This is a public parameter (similar to LOG*LEVEL). For more information, check [ENABLE*CONSOLE_OUTPUT docs](https://docs.snowflake.com/en/sql-reference/parameters#enable-console-output).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] external_access_integrations: The names of [external access integrations](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) needed in order for this function’s handler code to access external networks. An external access integration specifies [network rules](https://docs.snowflake.com/en/sql-reference/sql/create-network-rule) and [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) that specify external locations and credentials (if any) allowed for use by handler code when making requests of an external network, such as an external REST API.
        :param pulumi.Input[str] fully_qualified_name: Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
        :param pulumi.Input[str] function_definition: Defines the handler code executed when the UDF is called. Wrapping `$$` signs are added by the provider automatically; do not include them. The `function_definition` value must be Python source code. For more information, see [Introduction to Python UDFs](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-introduction). To mitigate permadiff on this field, the provider replaces blank characters with a space. This can lead to false positives in cases where a change in case or run of whitespace is semantically significant.
        :param pulumi.Input[str] function_language: Specifies language for the user. Used to detect external changes.
        :param pulumi.Input[str] handler: The name of the handler function or class. If the handler is for a scalar UDF, returning a non-tabular value, the HANDLER value should be a function name. If the handler code is in-line with the CREATE FUNCTION statement, you can use the function name alone. When the handler code is referenced at a stage, this value should be qualified with the module name, as in the following form: `my_module.my_function`. If the handler is for a tabular UDF, the HANDLER value should be the name of a handler class.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionPythonImportArgs']]] imports: The location (stage), path, and name of the file(s) to import. A file can be a `.py` file or another type of file. Python UDFs can also read non-Python files, such as text files. For an example, see [Reading a file](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-examples.html#label-udf-python-read-files). Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#python).
        :param pulumi.Input[str] is_aggregate: Specifies that the function is an aggregate function. For more information about user-defined aggregate functions, see [Python user-defined aggregate functions](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-aggregate-functions). Available options are: "true" or "false". When the value is not set in the configuration the provider will put "default" there which means to use the Snowflake default for this value.
        :param pulumi.Input[str] log_level: LOG*LEVEL to use when filtering events For more information, check [LOG*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#log-level).
        :param pulumi.Input[str] metric_level: METRIC*LEVEL value to control whether to emit metrics to Event Table For more information, check [METRIC*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#metric-level).
        :param pulumi.Input[str] name: The name of the function; the identifier does not need to be unique for the schema in which the function is created because UDFs are identified and resolved by the combination of the name and argument types. Check the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages). Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[str] null_input_behavior: Specifies the behavior of the function when called with null inputs. Valid values are (case-insensitive): `CALLED ON NULL INPUT` | `RETURNS NULL ON NULL INPUT`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] packages: The name and version number of packages required as dependencies. The value should be of the form `package_name==version_number`.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionPythonParameterArgs']]] parameters: Outputs the result of `SHOW PARAMETERS IN FUNCTION` for the given function.
        :param pulumi.Input[str] return_results_behavior: Specifies the behavior of the function when returning results. Valid values are (case-insensitive): `VOLATILE` | `IMMUTABLE`.
        :param pulumi.Input[str] return_type: Specifies the results returned by the UDF, which determines the UDF type. Use `<result_data_type>` to create a scalar UDF that returns a single value with the specified data type. Use `TABLE (col_name col_data_type, ...)` to creates a table UDF that returns tabular results with the specified table column(s) and column type(s). For the details, consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages).
        :param pulumi.Input[str] runtime_version: Specifies the Python version to use. The supported versions of Python are: 3.9, 3.10, and 3.11.
        :param pulumi.Input[str] schema: The schema in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionPythonSecretArgs']]] secrets: Assigns the names of [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) to variables so that you can use the variables to reference the secrets when retrieving information from secrets in handler code. Secrets you specify here must be allowed by the [external access integration](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) specified as a value of this CREATE FUNCTION command’s EXTERNAL*ACCESS*INTEGRATIONS parameter.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionPythonShowOutputArgs']]] show_outputs: Outputs the result of `SHOW FUNCTION` for the given function.
        :param pulumi.Input[str] trace_level: Trace level value to use when generating/filtering trace events For more information, check [TRACE_LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#trace-level).
        """
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if enable_console_output is not None:
            pulumi.set(__self__, "enable_console_output", enable_console_output)
        if external_access_integrations is not None:
            pulumi.set(__self__, "external_access_integrations", external_access_integrations)
        if fully_qualified_name is not None:
            pulumi.set(__self__, "fully_qualified_name", fully_qualified_name)
        if function_definition is not None:
            pulumi.set(__self__, "function_definition", function_definition)
        if function_language is not None:
            pulumi.set(__self__, "function_language", function_language)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if imports is not None:
            pulumi.set(__self__, "imports", imports)
        if is_aggregate is not None:
            pulumi.set(__self__, "is_aggregate", is_aggregate)
        if is_secure is not None:
            pulumi.set(__self__, "is_secure", is_secure)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if metric_level is not None:
            pulumi.set(__self__, "metric_level", metric_level)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if null_input_behavior is not None:
            pulumi.set(__self__, "null_input_behavior", null_input_behavior)
        if packages is not None:
            pulumi.set(__self__, "packages", packages)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if return_results_behavior is not None:
            pulumi.set(__self__, "return_results_behavior", return_results_behavior)
        if return_type is not None:
            pulumi.set(__self__, "return_type", return_type)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if show_outputs is not None:
            pulumi.set(__self__, "show_outputs", show_outputs)
        if trace_level is not None:
            pulumi.set(__self__, "trace_level", trace_level)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonArgumentArgs']]]]:
        """
        List of the arguments for the function. Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages) for more details.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonArgumentArgs']]]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a comment for the function.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        The database in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="enableConsoleOutput")
    def enable_console_output(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable stdout/stderr fast path logging for anonyous stored procs. This is a public parameter (similar to LOG*LEVEL). For more information, check [ENABLE*CONSOLE_OUTPUT docs](https://docs.snowflake.com/en/sql-reference/parameters#enable-console-output).
        """
        return pulumi.get(self, "enable_console_output")

    @enable_console_output.setter
    def enable_console_output(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_console_output", value)

    @property
    @pulumi.getter(name="externalAccessIntegrations")
    def external_access_integrations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The names of [external access integrations](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) needed in order for this function’s handler code to access external networks. An external access integration specifies [network rules](https://docs.snowflake.com/en/sql-reference/sql/create-network-rule) and [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) that specify external locations and credentials (if any) allowed for use by handler code when making requests of an external network, such as an external REST API.
        """
        return pulumi.get(self, "external_access_integrations")

    @external_access_integrations.setter
    def external_access_integrations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "external_access_integrations", value)

    @property
    @pulumi.getter(name="fullyQualifiedName")
    def fully_qualified_name(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
        """
        return pulumi.get(self, "fully_qualified_name")

    @fully_qualified_name.setter
    def fully_qualified_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fully_qualified_name", value)

    @property
    @pulumi.getter(name="functionDefinition")
    def function_definition(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the handler code executed when the UDF is called. Wrapping `$$` signs are added by the provider automatically; do not include them. The `function_definition` value must be Python source code. For more information, see [Introduction to Python UDFs](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-introduction). To mitigate permadiff on this field, the provider replaces blank characters with a space. This can lead to false positives in cases where a change in case or run of whitespace is semantically significant.
        """
        return pulumi.get(self, "function_definition")

    @function_definition.setter
    def function_definition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_definition", value)

    @property
    @pulumi.getter(name="functionLanguage")
    def function_language(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies language for the user. Used to detect external changes.
        """
        return pulumi.get(self, "function_language")

    @function_language.setter
    def function_language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_language", value)

    @property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the handler function or class. If the handler is for a scalar UDF, returning a non-tabular value, the HANDLER value should be a function name. If the handler code is in-line with the CREATE FUNCTION statement, you can use the function name alone. When the handler code is referenced at a stage, this value should be qualified with the module name, as in the following form: `my_module.my_function`. If the handler is for a tabular UDF, the HANDLER value should be the name of a handler class.
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "handler", value)

    @property
    @pulumi.getter
    def imports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonImportArgs']]]]:
        """
        The location (stage), path, and name of the file(s) to import. A file can be a `.py` file or another type of file. Python UDFs can also read non-Python files, such as text files. For an example, see [Reading a file](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-examples.html#label-udf-python-read-files). Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#python).
        """
        return pulumi.get(self, "imports")

    @imports.setter
    def imports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonImportArgs']]]]):
        pulumi.set(self, "imports", value)

    @property
    @pulumi.getter(name="isAggregate")
    def is_aggregate(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies that the function is an aggregate function. For more information about user-defined aggregate functions, see [Python user-defined aggregate functions](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-aggregate-functions). Available options are: "true" or "false". When the value is not set in the configuration the provider will put "default" there which means to use the Snowflake default for this value.
        """
        return pulumi.get(self, "is_aggregate")

    @is_aggregate.setter
    def is_aggregate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_aggregate", value)

    @property
    @pulumi.getter(name="isSecure")
    def is_secure(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "is_secure")

    @is_secure.setter
    def is_secure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_secure", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        LOG*LEVEL to use when filtering events For more information, check [LOG*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#log-level).
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="metricLevel")
    def metric_level(self) -> Optional[pulumi.Input[str]]:
        """
        METRIC*LEVEL value to control whether to emit metrics to Event Table For more information, check [METRIC*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#metric-level).
        """
        return pulumi.get(self, "metric_level")

    @metric_level.setter
    def metric_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_level", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the function; the identifier does not need to be unique for the schema in which the function is created because UDFs are identified and resolved by the combination of the name and argument types. Check the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages). Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nullInputBehavior")
    def null_input_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the behavior of the function when called with null inputs. Valid values are (case-insensitive): `CALLED ON NULL INPUT` | `RETURNS NULL ON NULL INPUT`.
        """
        return pulumi.get(self, "null_input_behavior")

    @null_input_behavior.setter
    def null_input_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "null_input_behavior", value)

    @property
    @pulumi.getter
    def packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The name and version number of packages required as dependencies. The value should be of the form `package_name==version_number`.
        """
        return pulumi.get(self, "packages")

    @packages.setter
    def packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "packages", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonParameterArgs']]]]:
        """
        Outputs the result of `SHOW PARAMETERS IN FUNCTION` for the given function.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="returnResultsBehavior")
    def return_results_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the behavior of the function when returning results. Valid values are (case-insensitive): `VOLATILE` | `IMMUTABLE`.
        """
        return pulumi.get(self, "return_results_behavior")

    @return_results_behavior.setter
    def return_results_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "return_results_behavior", value)

    @property
    @pulumi.getter(name="returnType")
    def return_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the results returned by the UDF, which determines the UDF type. Use `<result_data_type>` to create a scalar UDF that returns a single value with the specified data type. Use `TABLE (col_name col_data_type, ...)` to creates a table UDF that returns tabular results with the specified table column(s) and column type(s). For the details, consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages).
        """
        return pulumi.get(self, "return_type")

    @return_type.setter
    def return_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "return_type", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Python version to use. The supported versions of Python are: 3.9, 3.10, and 3.11.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonSecretArgs']]]]:
        """
        Assigns the names of [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) to variables so that you can use the variables to reference the secrets when retrieving information from secrets in handler code. Secrets you specify here must be allowed by the [external access integration](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) specified as a value of this CREATE FUNCTION command’s EXTERNAL*ACCESS*INTEGRATIONS parameter.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonSecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="showOutputs")
    def show_outputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonShowOutputArgs']]]]:
        """
        Outputs the result of `SHOW FUNCTION` for the given function.
        """
        return pulumi.get(self, "show_outputs")

    @show_outputs.setter
    def show_outputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionPythonShowOutputArgs']]]]):
        pulumi.set(self, "show_outputs", value)

    @property
    @pulumi.getter(name="traceLevel")
    def trace_level(self) -> Optional[pulumi.Input[str]]:
        """
        Trace level value to use when generating/filtering trace events For more information, check [TRACE_LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#trace-level).
        """
        return pulumi.get(self, "trace_level")

    @trace_level.setter
    def trace_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trace_level", value)


class FunctionPython(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 arguments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonArgumentArgs', 'FunctionPythonArgumentArgsDict']]]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 enable_console_output: Optional[pulumi.Input[bool]] = None,
                 external_access_integrations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 function_definition: Optional[pulumi.Input[str]] = None,
                 handler: Optional[pulumi.Input[str]] = None,
                 imports: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonImportArgs', 'FunctionPythonImportArgsDict']]]]] = None,
                 is_aggregate: Optional[pulumi.Input[str]] = None,
                 is_secure: Optional[pulumi.Input[str]] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 metric_level: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 null_input_behavior: Optional[pulumi.Input[str]] = None,
                 packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 return_results_behavior: Optional[pulumi.Input[str]] = None,
                 return_type: Optional[pulumi.Input[str]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonSecretArgs', 'FunctionPythonSecretArgsDict']]]]] = None,
                 trace_level: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        ## Import

        ```sh
        $ pulumi import snowflake:index/functionPython:FunctionPython example '"<database_name>"."<schema_name>"."<function_name>"(varchar, varchar, varchar)'
        ```

        Note: Snowflake is not returning all information needed to populate the state correctly after import (e.g. data types with attributes like NUMBER(32, 10) are returned as NUMBER, default values for arguments are not returned at all).

        Also, `ALTER` for functions is very limited so most of the attributes on this resource are marked as force new. Because of that, in multiple situations plan won't be empty after importing and manual state operations may be required.

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonArgumentArgs', 'FunctionPythonArgumentArgsDict']]]] arguments: List of the arguments for the function. Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages) for more details.
        :param pulumi.Input[str] comment: Specifies a comment for the function.
        :param pulumi.Input[str] database: The database in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[bool] enable_console_output: Enable stdout/stderr fast path logging for anonyous stored procs. This is a public parameter (similar to LOG*LEVEL). For more information, check [ENABLE*CONSOLE_OUTPUT docs](https://docs.snowflake.com/en/sql-reference/parameters#enable-console-output).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] external_access_integrations: The names of [external access integrations](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) needed in order for this function’s handler code to access external networks. An external access integration specifies [network rules](https://docs.snowflake.com/en/sql-reference/sql/create-network-rule) and [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) that specify external locations and credentials (if any) allowed for use by handler code when making requests of an external network, such as an external REST API.
        :param pulumi.Input[str] function_definition: Defines the handler code executed when the UDF is called. Wrapping `$$` signs are added by the provider automatically; do not include them. The `function_definition` value must be Python source code. For more information, see [Introduction to Python UDFs](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-introduction). To mitigate permadiff on this field, the provider replaces blank characters with a space. This can lead to false positives in cases where a change in case or run of whitespace is semantically significant.
        :param pulumi.Input[str] handler: The name of the handler function or class. If the handler is for a scalar UDF, returning a non-tabular value, the HANDLER value should be a function name. If the handler code is in-line with the CREATE FUNCTION statement, you can use the function name alone. When the handler code is referenced at a stage, this value should be qualified with the module name, as in the following form: `my_module.my_function`. If the handler is for a tabular UDF, the HANDLER value should be the name of a handler class.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonImportArgs', 'FunctionPythonImportArgsDict']]]] imports: The location (stage), path, and name of the file(s) to import. A file can be a `.py` file or another type of file. Python UDFs can also read non-Python files, such as text files. For an example, see [Reading a file](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-examples.html#label-udf-python-read-files). Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#python).
        :param pulumi.Input[str] is_aggregate: Specifies that the function is an aggregate function. For more information about user-defined aggregate functions, see [Python user-defined aggregate functions](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-aggregate-functions). Available options are: "true" or "false". When the value is not set in the configuration the provider will put "default" there which means to use the Snowflake default for this value.
        :param pulumi.Input[str] log_level: LOG*LEVEL to use when filtering events For more information, check [LOG*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#log-level).
        :param pulumi.Input[str] metric_level: METRIC*LEVEL value to control whether to emit metrics to Event Table For more information, check [METRIC*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#metric-level).
        :param pulumi.Input[str] name: The name of the function; the identifier does not need to be unique for the schema in which the function is created because UDFs are identified and resolved by the combination of the name and argument types. Check the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages). Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[str] null_input_behavior: Specifies the behavior of the function when called with null inputs. Valid values are (case-insensitive): `CALLED ON NULL INPUT` | `RETURNS NULL ON NULL INPUT`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] packages: The name and version number of packages required as dependencies. The value should be of the form `package_name==version_number`.
        :param pulumi.Input[str] return_results_behavior: Specifies the behavior of the function when returning results. Valid values are (case-insensitive): `VOLATILE` | `IMMUTABLE`.
        :param pulumi.Input[str] return_type: Specifies the results returned by the UDF, which determines the UDF type. Use `<result_data_type>` to create a scalar UDF that returns a single value with the specified data type. Use `TABLE (col_name col_data_type, ...)` to creates a table UDF that returns tabular results with the specified table column(s) and column type(s). For the details, consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages).
        :param pulumi.Input[str] runtime_version: Specifies the Python version to use. The supported versions of Python are: 3.9, 3.10, and 3.11.
        :param pulumi.Input[str] schema: The schema in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonSecretArgs', 'FunctionPythonSecretArgsDict']]]] secrets: Assigns the names of [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) to variables so that you can use the variables to reference the secrets when retrieving information from secrets in handler code. Secrets you specify here must be allowed by the [external access integration](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) specified as a value of this CREATE FUNCTION command’s EXTERNAL*ACCESS*INTEGRATIONS parameter.
        :param pulumi.Input[str] trace_level: Trace level value to use when generating/filtering trace events For more information, check [TRACE_LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#trace-level).
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: FunctionPythonArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Import

        ```sh
        $ pulumi import snowflake:index/functionPython:FunctionPython example '"<database_name>"."<schema_name>"."<function_name>"(varchar, varchar, varchar)'
        ```

        Note: Snowflake is not returning all information needed to populate the state correctly after import (e.g. data types with attributes like NUMBER(32, 10) are returned as NUMBER, default values for arguments are not returned at all).

        Also, `ALTER` for functions is very limited so most of the attributes on this resource are marked as force new. Because of that, in multiple situations plan won't be empty after importing and manual state operations may be required.

        :param str resource_name: The name of the resource.
        :param FunctionPythonArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(FunctionPythonArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 arguments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonArgumentArgs', 'FunctionPythonArgumentArgsDict']]]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 enable_console_output: Optional[pulumi.Input[bool]] = None,
                 external_access_integrations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 function_definition: Optional[pulumi.Input[str]] = None,
                 handler: Optional[pulumi.Input[str]] = None,
                 imports: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonImportArgs', 'FunctionPythonImportArgsDict']]]]] = None,
                 is_aggregate: Optional[pulumi.Input[str]] = None,
                 is_secure: Optional[pulumi.Input[str]] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 metric_level: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 null_input_behavior: Optional[pulumi.Input[str]] = None,
                 packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 return_results_behavior: Optional[pulumi.Input[str]] = None,
                 return_type: Optional[pulumi.Input[str]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonSecretArgs', 'FunctionPythonSecretArgsDict']]]]] = None,
                 trace_level: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = FunctionPythonArgs.__new__(FunctionPythonArgs)

            __props__.__dict__["arguments"] = arguments
            __props__.__dict__["comment"] = comment
            if database is None and not opts.urn:
                raise TypeError("Missing required property 'database'")
            __props__.__dict__["database"] = database
            __props__.__dict__["enable_console_output"] = enable_console_output
            __props__.__dict__["external_access_integrations"] = external_access_integrations
            __props__.__dict__["function_definition"] = function_definition
            if handler is None and not opts.urn:
                raise TypeError("Missing required property 'handler'")
            __props__.__dict__["handler"] = handler
            __props__.__dict__["imports"] = imports
            __props__.__dict__["is_aggregate"] = is_aggregate
            __props__.__dict__["is_secure"] = is_secure
            __props__.__dict__["log_level"] = log_level
            __props__.__dict__["metric_level"] = metric_level
            __props__.__dict__["name"] = name
            __props__.__dict__["null_input_behavior"] = null_input_behavior
            __props__.__dict__["packages"] = packages
            __props__.__dict__["return_results_behavior"] = return_results_behavior
            if return_type is None and not opts.urn:
                raise TypeError("Missing required property 'return_type'")
            __props__.__dict__["return_type"] = return_type
            if runtime_version is None and not opts.urn:
                raise TypeError("Missing required property 'runtime_version'")
            __props__.__dict__["runtime_version"] = runtime_version
            if schema is None and not opts.urn:
                raise TypeError("Missing required property 'schema'")
            __props__.__dict__["schema"] = schema
            __props__.__dict__["secrets"] = secrets
            __props__.__dict__["trace_level"] = trace_level
            __props__.__dict__["fully_qualified_name"] = None
            __props__.__dict__["function_language"] = None
            __props__.__dict__["parameters"] = None
            __props__.__dict__["show_outputs"] = None
        super(FunctionPython, __self__).__init__(
            'snowflake:index/functionPython:FunctionPython',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            arguments: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonArgumentArgs', 'FunctionPythonArgumentArgsDict']]]]] = None,
            comment: Optional[pulumi.Input[str]] = None,
            database: Optional[pulumi.Input[str]] = None,
            enable_console_output: Optional[pulumi.Input[bool]] = None,
            external_access_integrations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            fully_qualified_name: Optional[pulumi.Input[str]] = None,
            function_definition: Optional[pulumi.Input[str]] = None,
            function_language: Optional[pulumi.Input[str]] = None,
            handler: Optional[pulumi.Input[str]] = None,
            imports: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonImportArgs', 'FunctionPythonImportArgsDict']]]]] = None,
            is_aggregate: Optional[pulumi.Input[str]] = None,
            is_secure: Optional[pulumi.Input[str]] = None,
            log_level: Optional[pulumi.Input[str]] = None,
            metric_level: Optional[pulumi.Input[str]] = None,
            name: Optional[pulumi.Input[str]] = None,
            null_input_behavior: Optional[pulumi.Input[str]] = None,
            packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            parameters: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonParameterArgs', 'FunctionPythonParameterArgsDict']]]]] = None,
            return_results_behavior: Optional[pulumi.Input[str]] = None,
            return_type: Optional[pulumi.Input[str]] = None,
            runtime_version: Optional[pulumi.Input[str]] = None,
            schema: Optional[pulumi.Input[str]] = None,
            secrets: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonSecretArgs', 'FunctionPythonSecretArgsDict']]]]] = None,
            show_outputs: Optional[pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonShowOutputArgs', 'FunctionPythonShowOutputArgsDict']]]]] = None,
            trace_level: Optional[pulumi.Input[str]] = None) -> 'FunctionPython':
        """
        Get an existing FunctionPython resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonArgumentArgs', 'FunctionPythonArgumentArgsDict']]]] arguments: List of the arguments for the function. Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages) for more details.
        :param pulumi.Input[str] comment: Specifies a comment for the function.
        :param pulumi.Input[str] database: The database in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[bool] enable_console_output: Enable stdout/stderr fast path logging for anonyous stored procs. This is a public parameter (similar to LOG*LEVEL). For more information, check [ENABLE*CONSOLE_OUTPUT docs](https://docs.snowflake.com/en/sql-reference/parameters#enable-console-output).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] external_access_integrations: The names of [external access integrations](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) needed in order for this function’s handler code to access external networks. An external access integration specifies [network rules](https://docs.snowflake.com/en/sql-reference/sql/create-network-rule) and [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) that specify external locations and credentials (if any) allowed for use by handler code when making requests of an external network, such as an external REST API.
        :param pulumi.Input[str] fully_qualified_name: Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
        :param pulumi.Input[str] function_definition: Defines the handler code executed when the UDF is called. Wrapping `$$` signs are added by the provider automatically; do not include them. The `function_definition` value must be Python source code. For more information, see [Introduction to Python UDFs](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-introduction). To mitigate permadiff on this field, the provider replaces blank characters with a space. This can lead to false positives in cases where a change in case or run of whitespace is semantically significant.
        :param pulumi.Input[str] function_language: Specifies language for the user. Used to detect external changes.
        :param pulumi.Input[str] handler: The name of the handler function or class. If the handler is for a scalar UDF, returning a non-tabular value, the HANDLER value should be a function name. If the handler code is in-line with the CREATE FUNCTION statement, you can use the function name alone. When the handler code is referenced at a stage, this value should be qualified with the module name, as in the following form: `my_module.my_function`. If the handler is for a tabular UDF, the HANDLER value should be the name of a handler class.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonImportArgs', 'FunctionPythonImportArgsDict']]]] imports: The location (stage), path, and name of the file(s) to import. A file can be a `.py` file or another type of file. Python UDFs can also read non-Python files, such as text files. For an example, see [Reading a file](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-examples.html#label-udf-python-read-files). Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#python).
        :param pulumi.Input[str] is_aggregate: Specifies that the function is an aggregate function. For more information about user-defined aggregate functions, see [Python user-defined aggregate functions](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-aggregate-functions). Available options are: "true" or "false". When the value is not set in the configuration the provider will put "default" there which means to use the Snowflake default for this value.
        :param pulumi.Input[str] log_level: LOG*LEVEL to use when filtering events For more information, check [LOG*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#log-level).
        :param pulumi.Input[str] metric_level: METRIC*LEVEL value to control whether to emit metrics to Event Table For more information, check [METRIC*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#metric-level).
        :param pulumi.Input[str] name: The name of the function; the identifier does not need to be unique for the schema in which the function is created because UDFs are identified and resolved by the combination of the name and argument types. Check the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages). Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[str] null_input_behavior: Specifies the behavior of the function when called with null inputs. Valid values are (case-insensitive): `CALLED ON NULL INPUT` | `RETURNS NULL ON NULL INPUT`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] packages: The name and version number of packages required as dependencies. The value should be of the form `package_name==version_number`.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonParameterArgs', 'FunctionPythonParameterArgsDict']]]] parameters: Outputs the result of `SHOW PARAMETERS IN FUNCTION` for the given function.
        :param pulumi.Input[str] return_results_behavior: Specifies the behavior of the function when returning results. Valid values are (case-insensitive): `VOLATILE` | `IMMUTABLE`.
        :param pulumi.Input[str] return_type: Specifies the results returned by the UDF, which determines the UDF type. Use `<result_data_type>` to create a scalar UDF that returns a single value with the specified data type. Use `TABLE (col_name col_data_type, ...)` to creates a table UDF that returns tabular results with the specified table column(s) and column type(s). For the details, consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages).
        :param pulumi.Input[str] runtime_version: Specifies the Python version to use. The supported versions of Python are: 3.9, 3.10, and 3.11.
        :param pulumi.Input[str] schema: The schema in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonSecretArgs', 'FunctionPythonSecretArgsDict']]]] secrets: Assigns the names of [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) to variables so that you can use the variables to reference the secrets when retrieving information from secrets in handler code. Secrets you specify here must be allowed by the [external access integration](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) specified as a value of this CREATE FUNCTION command’s EXTERNAL*ACCESS*INTEGRATIONS parameter.
        :param pulumi.Input[Sequence[pulumi.Input[Union['FunctionPythonShowOutputArgs', 'FunctionPythonShowOutputArgsDict']]]] show_outputs: Outputs the result of `SHOW FUNCTION` for the given function.
        :param pulumi.Input[str] trace_level: Trace level value to use when generating/filtering trace events For more information, check [TRACE_LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#trace-level).
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _FunctionPythonState.__new__(_FunctionPythonState)

        __props__.__dict__["arguments"] = arguments
        __props__.__dict__["comment"] = comment
        __props__.__dict__["database"] = database
        __props__.__dict__["enable_console_output"] = enable_console_output
        __props__.__dict__["external_access_integrations"] = external_access_integrations
        __props__.__dict__["fully_qualified_name"] = fully_qualified_name
        __props__.__dict__["function_definition"] = function_definition
        __props__.__dict__["function_language"] = function_language
        __props__.__dict__["handler"] = handler
        __props__.__dict__["imports"] = imports
        __props__.__dict__["is_aggregate"] = is_aggregate
        __props__.__dict__["is_secure"] = is_secure
        __props__.__dict__["log_level"] = log_level
        __props__.__dict__["metric_level"] = metric_level
        __props__.__dict__["name"] = name
        __props__.__dict__["null_input_behavior"] = null_input_behavior
        __props__.__dict__["packages"] = packages
        __props__.__dict__["parameters"] = parameters
        __props__.__dict__["return_results_behavior"] = return_results_behavior
        __props__.__dict__["return_type"] = return_type
        __props__.__dict__["runtime_version"] = runtime_version
        __props__.__dict__["schema"] = schema
        __props__.__dict__["secrets"] = secrets
        __props__.__dict__["show_outputs"] = show_outputs
        __props__.__dict__["trace_level"] = trace_level
        return FunctionPython(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def arguments(self) -> pulumi.Output[Optional[Sequence['outputs.FunctionPythonArgument']]]:
        """
        List of the arguments for the function. Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages) for more details.
        """
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter
    def comment(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies a comment for the function.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def database(self) -> pulumi.Output[str]:
        """
        The database in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="enableConsoleOutput")
    def enable_console_output(self) -> pulumi.Output[bool]:
        """
        Enable stdout/stderr fast path logging for anonyous stored procs. This is a public parameter (similar to LOG*LEVEL). For more information, check [ENABLE*CONSOLE_OUTPUT docs](https://docs.snowflake.com/en/sql-reference/parameters#enable-console-output).
        """
        return pulumi.get(self, "enable_console_output")

    @property
    @pulumi.getter(name="externalAccessIntegrations")
    def external_access_integrations(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        The names of [external access integrations](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) needed in order for this function’s handler code to access external networks. An external access integration specifies [network rules](https://docs.snowflake.com/en/sql-reference/sql/create-network-rule) and [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) that specify external locations and credentials (if any) allowed for use by handler code when making requests of an external network, such as an external REST API.
        """
        return pulumi.get(self, "external_access_integrations")

    @property
    @pulumi.getter(name="fullyQualifiedName")
    def fully_qualified_name(self) -> pulumi.Output[str]:
        """
        Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
        """
        return pulumi.get(self, "fully_qualified_name")

    @property
    @pulumi.getter(name="functionDefinition")
    def function_definition(self) -> pulumi.Output[Optional[str]]:
        """
        Defines the handler code executed when the UDF is called. Wrapping `$$` signs are added by the provider automatically; do not include them. The `function_definition` value must be Python source code. For more information, see [Introduction to Python UDFs](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-introduction). To mitigate permadiff on this field, the provider replaces blank characters with a space. This can lead to false positives in cases where a change in case or run of whitespace is semantically significant.
        """
        return pulumi.get(self, "function_definition")

    @property
    @pulumi.getter(name="functionLanguage")
    def function_language(self) -> pulumi.Output[str]:
        """
        Specifies language for the user. Used to detect external changes.
        """
        return pulumi.get(self, "function_language")

    @property
    @pulumi.getter
    def handler(self) -> pulumi.Output[str]:
        """
        The name of the handler function or class. If the handler is for a scalar UDF, returning a non-tabular value, the HANDLER value should be a function name. If the handler code is in-line with the CREATE FUNCTION statement, you can use the function name alone. When the handler code is referenced at a stage, this value should be qualified with the module name, as in the following form: `my_module.my_function`. If the handler is for a tabular UDF, the HANDLER value should be the name of a handler class.
        """
        return pulumi.get(self, "handler")

    @property
    @pulumi.getter
    def imports(self) -> pulumi.Output[Optional[Sequence['outputs.FunctionPythonImport']]]:
        """
        The location (stage), path, and name of the file(s) to import. A file can be a `.py` file or another type of file. Python UDFs can also read non-Python files, such as text files. For an example, see [Reading a file](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-examples.html#label-udf-python-read-files). Consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#python).
        """
        return pulumi.get(self, "imports")

    @property
    @pulumi.getter(name="isAggregate")
    def is_aggregate(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies that the function is an aggregate function. For more information about user-defined aggregate functions, see [Python user-defined aggregate functions](https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-aggregate-functions). Available options are: "true" or "false". When the value is not set in the configuration the provider will put "default" there which means to use the Snowflake default for this value.
        """
        return pulumi.get(self, "is_aggregate")

    @property
    @pulumi.getter(name="isSecure")
    def is_secure(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "is_secure")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> pulumi.Output[str]:
        """
        LOG*LEVEL to use when filtering events For more information, check [LOG*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#log-level).
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="metricLevel")
    def metric_level(self) -> pulumi.Output[str]:
        """
        METRIC*LEVEL value to control whether to emit metrics to Event Table For more information, check [METRIC*LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#metric-level).
        """
        return pulumi.get(self, "metric_level")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        The name of the function; the identifier does not need to be unique for the schema in which the function is created because UDFs are identified and resolved by the combination of the name and argument types. Check the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages). Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nullInputBehavior")
    def null_input_behavior(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies the behavior of the function when called with null inputs. Valid values are (case-insensitive): `CALLED ON NULL INPUT` | `RETURNS NULL ON NULL INPUT`.
        """
        return pulumi.get(self, "null_input_behavior")

    @property
    @pulumi.getter
    def packages(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        The name and version number of packages required as dependencies. The value should be of the form `package_name==version_number`.
        """
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Output[Sequence['outputs.FunctionPythonParameter']]:
        """
        Outputs the result of `SHOW PARAMETERS IN FUNCTION` for the given function.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="returnResultsBehavior")
    def return_results_behavior(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies the behavior of the function when returning results. Valid values are (case-insensitive): `VOLATILE` | `IMMUTABLE`.
        """
        return pulumi.get(self, "return_results_behavior")

    @property
    @pulumi.getter(name="returnType")
    def return_type(self) -> pulumi.Output[str]:
        """
        Specifies the results returned by the UDF, which determines the UDF type. Use `<result_data_type>` to create a scalar UDF that returns a single value with the specified data type. Use `TABLE (col_name col_data_type, ...)` to creates a table UDF that returns tabular results with the specified table column(s) and column type(s). For the details, consult the [docs](https://docs.snowflake.com/en/sql-reference/sql/create-function#all-languages).
        """
        return pulumi.get(self, "return_type")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> pulumi.Output[str]:
        """
        Specifies the Python version to use. The supported versions of Python are: 3.9, 3.10, and 3.11.
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Output[str]:
        """
        The schema in which to create the function. Due to technical limitations (read more here), avoid using the following characters: `|`, `.`, `"`.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def secrets(self) -> pulumi.Output[Optional[Sequence['outputs.FunctionPythonSecret']]]:
        """
        Assigns the names of [secrets](https://docs.snowflake.com/en/sql-reference/sql/create-secret) to variables so that you can use the variables to reference the secrets when retrieving information from secrets in handler code. Secrets you specify here must be allowed by the [external access integration](https://docs.snowflake.com/en/sql-reference/sql/create-external-access-integration) specified as a value of this CREATE FUNCTION command’s EXTERNAL*ACCESS*INTEGRATIONS parameter.
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="showOutputs")
    def show_outputs(self) -> pulumi.Output[Sequence['outputs.FunctionPythonShowOutput']]:
        """
        Outputs the result of `SHOW FUNCTION` for the given function.
        """
        return pulumi.get(self, "show_outputs")

    @property
    @pulumi.getter(name="traceLevel")
    def trace_level(self) -> pulumi.Output[str]:
        """
        Trace level value to use when generating/filtering trace events For more information, check [TRACE_LEVEL docs](https://docs.snowflake.com/en/sql-reference/parameters#trace-level).
        """
        return pulumi.get(self, "trace_level")

