// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * ## Import
 *
 * format is database name | schema name | file format name
 *
 * ```sh
 * $ pulumi import snowflake:index/fileFormat:FileFormat example 'dbName|schemaName|fileFormatName'
 * ```
 */
export class FileFormat extends pulumi.CustomResource {
    /**
     * Get an existing FileFormat resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: FileFormatState, opts?: pulumi.CustomResourceOptions): FileFormat {
        return new FileFormat(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'snowflake:index/fileFormat:FileFormat';

    /**
     * Returns true if the given object is an instance of FileFormat.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is FileFormat {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === FileFormat.__pulumiType;
    }

    /**
     * Boolean that specifies to allow duplicate object field names (only the last one will be preserved).
     */
    declare public readonly allowDuplicate: pulumi.Output<boolean | undefined>;
    /**
     * Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.
     */
    declare public readonly binaryAsText: pulumi.Output<boolean | undefined>;
    /**
     * Defines the encoding format for binary input or output.
     */
    declare public readonly binaryFormat: pulumi.Output<string>;
    /**
     * Specifies a comment for the file format.
     */
    declare public readonly comment: pulumi.Output<string | undefined>;
    /**
     * Specifies the current compression algorithm for the data file.
     */
    declare public readonly compression: pulumi.Output<string>;
    /**
     * The database in which to create the file format.
     */
    declare public readonly database: pulumi.Output<string>;
    /**
     * Defines the format of date values in the data files (data loading) or table (data unloading).
     */
    declare public readonly dateFormat: pulumi.Output<string>;
    /**
     * Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.
     */
    declare public readonly disableAutoConvert: pulumi.Output<boolean | undefined>;
    /**
     * Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.
     */
    declare public readonly disableSnowflakeData: pulumi.Output<boolean | undefined>;
    /**
     * Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.
     */
    declare public readonly emptyFieldAsNull: pulumi.Output<boolean | undefined>;
    /**
     * Boolean that enables parsing of octal numbers.
     */
    declare public readonly enableOctal: pulumi.Output<boolean | undefined>;
    /**
     * String (constant) that specifies the character set of the source data when loading data into a table.
     */
    declare public readonly encoding: pulumi.Output<string>;
    /**
     * Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.
     */
    declare public readonly errorOnColumnCountMismatch: pulumi.Output<boolean | undefined>;
    /**
     * Single character string used as the escape character for field values.
     */
    declare public readonly escape: pulumi.Output<string>;
    /**
     * Single character string used as the escape character for unenclosed field values only.
     */
    declare public readonly escapeUnenclosedField: pulumi.Output<string>;
    /**
     * Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).
     */
    declare public readonly fieldDelimiter: pulumi.Output<string>;
    /**
     * Character used to enclose strings.
     */
    declare public readonly fieldOptionallyEnclosedBy: pulumi.Output<string>;
    /**
     * Specifies the extension for files unloaded to a stage.
     */
    declare public readonly fileExtension: pulumi.Output<string | undefined>;
    /**
     * Specifies the format of the input files (for data loading) or output files (for data unloading).
     */
    declare public readonly formatType: pulumi.Output<string>;
    /**
     * Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
     */
    declare public /*out*/ readonly fullyQualifiedName: pulumi.Output<string>;
    /**
     * Boolean that specifies whether UTF-8 encoding errors produce error conditions.
     */
    declare public readonly ignoreUtf8Errors: pulumi.Output<boolean | undefined>;
    /**
     * Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * String used to convert to and from SQL NULL.
     */
    declare public readonly nullIfs: pulumi.Output<string[]>;
    /**
     * Boolean that specifies whether to use the first row headers in the data files to determine column names.
     */
    declare public readonly parseHeader: pulumi.Output<boolean | undefined>;
    /**
     * Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.
     */
    declare public readonly preserveSpace: pulumi.Output<boolean | undefined>;
    /**
     * Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).
     */
    declare public readonly recordDelimiter: pulumi.Output<string>;
    /**
     * Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (ï¿½).
     */
    declare public readonly replaceInvalidCharacters: pulumi.Output<boolean | undefined>;
    /**
     * The schema in which to create the file format.
     */
    declare public readonly schema: pulumi.Output<string>;
    /**
     * Boolean that specifies to skip any blank lines encountered in the data files.
     */
    declare public readonly skipBlankLines: pulumi.Output<boolean | undefined>;
    /**
     * Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.
     */
    declare public readonly skipByteOrderMark: pulumi.Output<boolean | undefined>;
    /**
     * Number of lines at the start of the file to skip.
     */
    declare public readonly skipHeader: pulumi.Output<number | undefined>;
    /**
     * Boolean that instructs the JSON parser to remove object fields or array elements containing null values.
     */
    declare public readonly stripNullValues: pulumi.Output<boolean | undefined>;
    /**
     * Boolean that instructs the JSON parser to remove outer brackets.
     */
    declare public readonly stripOuterArray: pulumi.Output<boolean | undefined>;
    /**
     * Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.
     */
    declare public readonly stripOuterElement: pulumi.Output<boolean | undefined>;
    /**
     * Defines the format of time values in the data files (data loading) or table (data unloading).
     */
    declare public readonly timeFormat: pulumi.Output<string>;
    /**
     * Defines the format of timestamp values in the data files (data loading) or table (data unloading).
     */
    declare public readonly timestampFormat: pulumi.Output<string>;
    /**
     * Boolean that specifies whether to remove white space from fields.
     */
    declare public readonly trimSpace: pulumi.Output<boolean | undefined>;

    /**
     * Create a FileFormat resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: FileFormatArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: FileFormatArgs | FileFormatState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as FileFormatState | undefined;
            resourceInputs["allowDuplicate"] = state?.allowDuplicate;
            resourceInputs["binaryAsText"] = state?.binaryAsText;
            resourceInputs["binaryFormat"] = state?.binaryFormat;
            resourceInputs["comment"] = state?.comment;
            resourceInputs["compression"] = state?.compression;
            resourceInputs["database"] = state?.database;
            resourceInputs["dateFormat"] = state?.dateFormat;
            resourceInputs["disableAutoConvert"] = state?.disableAutoConvert;
            resourceInputs["disableSnowflakeData"] = state?.disableSnowflakeData;
            resourceInputs["emptyFieldAsNull"] = state?.emptyFieldAsNull;
            resourceInputs["enableOctal"] = state?.enableOctal;
            resourceInputs["encoding"] = state?.encoding;
            resourceInputs["errorOnColumnCountMismatch"] = state?.errorOnColumnCountMismatch;
            resourceInputs["escape"] = state?.escape;
            resourceInputs["escapeUnenclosedField"] = state?.escapeUnenclosedField;
            resourceInputs["fieldDelimiter"] = state?.fieldDelimiter;
            resourceInputs["fieldOptionallyEnclosedBy"] = state?.fieldOptionallyEnclosedBy;
            resourceInputs["fileExtension"] = state?.fileExtension;
            resourceInputs["formatType"] = state?.formatType;
            resourceInputs["fullyQualifiedName"] = state?.fullyQualifiedName;
            resourceInputs["ignoreUtf8Errors"] = state?.ignoreUtf8Errors;
            resourceInputs["name"] = state?.name;
            resourceInputs["nullIfs"] = state?.nullIfs;
            resourceInputs["parseHeader"] = state?.parseHeader;
            resourceInputs["preserveSpace"] = state?.preserveSpace;
            resourceInputs["recordDelimiter"] = state?.recordDelimiter;
            resourceInputs["replaceInvalidCharacters"] = state?.replaceInvalidCharacters;
            resourceInputs["schema"] = state?.schema;
            resourceInputs["skipBlankLines"] = state?.skipBlankLines;
            resourceInputs["skipByteOrderMark"] = state?.skipByteOrderMark;
            resourceInputs["skipHeader"] = state?.skipHeader;
            resourceInputs["stripNullValues"] = state?.stripNullValues;
            resourceInputs["stripOuterArray"] = state?.stripOuterArray;
            resourceInputs["stripOuterElement"] = state?.stripOuterElement;
            resourceInputs["timeFormat"] = state?.timeFormat;
            resourceInputs["timestampFormat"] = state?.timestampFormat;
            resourceInputs["trimSpace"] = state?.trimSpace;
        } else {
            const args = argsOrState as FileFormatArgs | undefined;
            if (args?.database === undefined && !opts.urn) {
                throw new Error("Missing required property 'database'");
            }
            if (args?.formatType === undefined && !opts.urn) {
                throw new Error("Missing required property 'formatType'");
            }
            if (args?.schema === undefined && !opts.urn) {
                throw new Error("Missing required property 'schema'");
            }
            resourceInputs["allowDuplicate"] = args?.allowDuplicate;
            resourceInputs["binaryAsText"] = args?.binaryAsText;
            resourceInputs["binaryFormat"] = args?.binaryFormat;
            resourceInputs["comment"] = args?.comment;
            resourceInputs["compression"] = args?.compression;
            resourceInputs["database"] = args?.database;
            resourceInputs["dateFormat"] = args?.dateFormat;
            resourceInputs["disableAutoConvert"] = args?.disableAutoConvert;
            resourceInputs["disableSnowflakeData"] = args?.disableSnowflakeData;
            resourceInputs["emptyFieldAsNull"] = args?.emptyFieldAsNull;
            resourceInputs["enableOctal"] = args?.enableOctal;
            resourceInputs["encoding"] = args?.encoding;
            resourceInputs["errorOnColumnCountMismatch"] = args?.errorOnColumnCountMismatch;
            resourceInputs["escape"] = args?.escape;
            resourceInputs["escapeUnenclosedField"] = args?.escapeUnenclosedField;
            resourceInputs["fieldDelimiter"] = args?.fieldDelimiter;
            resourceInputs["fieldOptionallyEnclosedBy"] = args?.fieldOptionallyEnclosedBy;
            resourceInputs["fileExtension"] = args?.fileExtension;
            resourceInputs["formatType"] = args?.formatType;
            resourceInputs["ignoreUtf8Errors"] = args?.ignoreUtf8Errors;
            resourceInputs["name"] = args?.name;
            resourceInputs["nullIfs"] = args?.nullIfs;
            resourceInputs["parseHeader"] = args?.parseHeader;
            resourceInputs["preserveSpace"] = args?.preserveSpace;
            resourceInputs["recordDelimiter"] = args?.recordDelimiter;
            resourceInputs["replaceInvalidCharacters"] = args?.replaceInvalidCharacters;
            resourceInputs["schema"] = args?.schema;
            resourceInputs["skipBlankLines"] = args?.skipBlankLines;
            resourceInputs["skipByteOrderMark"] = args?.skipByteOrderMark;
            resourceInputs["skipHeader"] = args?.skipHeader;
            resourceInputs["stripNullValues"] = args?.stripNullValues;
            resourceInputs["stripOuterArray"] = args?.stripOuterArray;
            resourceInputs["stripOuterElement"] = args?.stripOuterElement;
            resourceInputs["timeFormat"] = args?.timeFormat;
            resourceInputs["timestampFormat"] = args?.timestampFormat;
            resourceInputs["trimSpace"] = args?.trimSpace;
            resourceInputs["fullyQualifiedName"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(FileFormat.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering FileFormat resources.
 */
export interface FileFormatState {
    /**
     * Boolean that specifies to allow duplicate object field names (only the last one will be preserved).
     */
    allowDuplicate?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.
     */
    binaryAsText?: pulumi.Input<boolean>;
    /**
     * Defines the encoding format for binary input or output.
     */
    binaryFormat?: pulumi.Input<string>;
    /**
     * Specifies a comment for the file format.
     */
    comment?: pulumi.Input<string>;
    /**
     * Specifies the current compression algorithm for the data file.
     */
    compression?: pulumi.Input<string>;
    /**
     * The database in which to create the file format.
     */
    database?: pulumi.Input<string>;
    /**
     * Defines the format of date values in the data files (data loading) or table (data unloading).
     */
    dateFormat?: pulumi.Input<string>;
    /**
     * Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.
     */
    disableAutoConvert?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.
     */
    disableSnowflakeData?: pulumi.Input<boolean>;
    /**
     * Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.
     */
    emptyFieldAsNull?: pulumi.Input<boolean>;
    /**
     * Boolean that enables parsing of octal numbers.
     */
    enableOctal?: pulumi.Input<boolean>;
    /**
     * String (constant) that specifies the character set of the source data when loading data into a table.
     */
    encoding?: pulumi.Input<string>;
    /**
     * Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.
     */
    errorOnColumnCountMismatch?: pulumi.Input<boolean>;
    /**
     * Single character string used as the escape character for field values.
     */
    escape?: pulumi.Input<string>;
    /**
     * Single character string used as the escape character for unenclosed field values only.
     */
    escapeUnenclosedField?: pulumi.Input<string>;
    /**
     * Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).
     */
    fieldDelimiter?: pulumi.Input<string>;
    /**
     * Character used to enclose strings.
     */
    fieldOptionallyEnclosedBy?: pulumi.Input<string>;
    /**
     * Specifies the extension for files unloaded to a stage.
     */
    fileExtension?: pulumi.Input<string>;
    /**
     * Specifies the format of the input files (for data loading) or output files (for data unloading).
     */
    formatType?: pulumi.Input<string>;
    /**
     * Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
     */
    fullyQualifiedName?: pulumi.Input<string>;
    /**
     * Boolean that specifies whether UTF-8 encoding errors produce error conditions.
     */
    ignoreUtf8Errors?: pulumi.Input<boolean>;
    /**
     * Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.
     */
    name?: pulumi.Input<string>;
    /**
     * String used to convert to and from SQL NULL.
     */
    nullIfs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Boolean that specifies whether to use the first row headers in the data files to determine column names.
     */
    parseHeader?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.
     */
    preserveSpace?: pulumi.Input<boolean>;
    /**
     * Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).
     */
    recordDelimiter?: pulumi.Input<string>;
    /**
     * Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (ï¿½).
     */
    replaceInvalidCharacters?: pulumi.Input<boolean>;
    /**
     * The schema in which to create the file format.
     */
    schema?: pulumi.Input<string>;
    /**
     * Boolean that specifies to skip any blank lines encountered in the data files.
     */
    skipBlankLines?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.
     */
    skipByteOrderMark?: pulumi.Input<boolean>;
    /**
     * Number of lines at the start of the file to skip.
     */
    skipHeader?: pulumi.Input<number>;
    /**
     * Boolean that instructs the JSON parser to remove object fields or array elements containing null values.
     */
    stripNullValues?: pulumi.Input<boolean>;
    /**
     * Boolean that instructs the JSON parser to remove outer brackets.
     */
    stripOuterArray?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.
     */
    stripOuterElement?: pulumi.Input<boolean>;
    /**
     * Defines the format of time values in the data files (data loading) or table (data unloading).
     */
    timeFormat?: pulumi.Input<string>;
    /**
     * Defines the format of timestamp values in the data files (data loading) or table (data unloading).
     */
    timestampFormat?: pulumi.Input<string>;
    /**
     * Boolean that specifies whether to remove white space from fields.
     */
    trimSpace?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a FileFormat resource.
 */
export interface FileFormatArgs {
    /**
     * Boolean that specifies to allow duplicate object field names (only the last one will be preserved).
     */
    allowDuplicate?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.
     */
    binaryAsText?: pulumi.Input<boolean>;
    /**
     * Defines the encoding format for binary input or output.
     */
    binaryFormat?: pulumi.Input<string>;
    /**
     * Specifies a comment for the file format.
     */
    comment?: pulumi.Input<string>;
    /**
     * Specifies the current compression algorithm for the data file.
     */
    compression?: pulumi.Input<string>;
    /**
     * The database in which to create the file format.
     */
    database: pulumi.Input<string>;
    /**
     * Defines the format of date values in the data files (data loading) or table (data unloading).
     */
    dateFormat?: pulumi.Input<string>;
    /**
     * Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.
     */
    disableAutoConvert?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.
     */
    disableSnowflakeData?: pulumi.Input<boolean>;
    /**
     * Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.
     */
    emptyFieldAsNull?: pulumi.Input<boolean>;
    /**
     * Boolean that enables parsing of octal numbers.
     */
    enableOctal?: pulumi.Input<boolean>;
    /**
     * String (constant) that specifies the character set of the source data when loading data into a table.
     */
    encoding?: pulumi.Input<string>;
    /**
     * Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.
     */
    errorOnColumnCountMismatch?: pulumi.Input<boolean>;
    /**
     * Single character string used as the escape character for field values.
     */
    escape?: pulumi.Input<string>;
    /**
     * Single character string used as the escape character for unenclosed field values only.
     */
    escapeUnenclosedField?: pulumi.Input<string>;
    /**
     * Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).
     */
    fieldDelimiter?: pulumi.Input<string>;
    /**
     * Character used to enclose strings.
     */
    fieldOptionallyEnclosedBy?: pulumi.Input<string>;
    /**
     * Specifies the extension for files unloaded to a stage.
     */
    fileExtension?: pulumi.Input<string>;
    /**
     * Specifies the format of the input files (for data loading) or output files (for data unloading).
     */
    formatType: pulumi.Input<string>;
    /**
     * Boolean that specifies whether UTF-8 encoding errors produce error conditions.
     */
    ignoreUtf8Errors?: pulumi.Input<boolean>;
    /**
     * Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.
     */
    name?: pulumi.Input<string>;
    /**
     * String used to convert to and from SQL NULL.
     */
    nullIfs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Boolean that specifies whether to use the first row headers in the data files to determine column names.
     */
    parseHeader?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.
     */
    preserveSpace?: pulumi.Input<boolean>;
    /**
     * Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).
     */
    recordDelimiter?: pulumi.Input<string>;
    /**
     * Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (ï¿½).
     */
    replaceInvalidCharacters?: pulumi.Input<boolean>;
    /**
     * The schema in which to create the file format.
     */
    schema: pulumi.Input<string>;
    /**
     * Boolean that specifies to skip any blank lines encountered in the data files.
     */
    skipBlankLines?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.
     */
    skipByteOrderMark?: pulumi.Input<boolean>;
    /**
     * Number of lines at the start of the file to skip.
     */
    skipHeader?: pulumi.Input<number>;
    /**
     * Boolean that instructs the JSON parser to remove object fields or array elements containing null values.
     */
    stripNullValues?: pulumi.Input<boolean>;
    /**
     * Boolean that instructs the JSON parser to remove outer brackets.
     */
    stripOuterArray?: pulumi.Input<boolean>;
    /**
     * Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.
     */
    stripOuterElement?: pulumi.Input<boolean>;
    /**
     * Defines the format of time values in the data files (data loading) or table (data unloading).
     */
    timeFormat?: pulumi.Input<string>;
    /**
     * Defines the format of timestamp values in the data files (data loading) or table (data unloading).
     */
    timestampFormat?: pulumi.Input<string>;
    /**
     * Boolean that specifies whether to remove white space from fields.
     */
    trimSpace?: pulumi.Input<boolean>;
}
