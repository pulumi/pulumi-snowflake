// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.snowflake.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class FileFormatState extends com.pulumi.resources.ResourceArgs {

    public static final FileFormatState Empty = new FileFormatState();

    /**
     * Boolean that specifies to allow duplicate object field names (only the last one will be preserved).
     * 
     */
    @Import(name="allowDuplicate")
    private @Nullable Output<Boolean> allowDuplicate;

    /**
     * @return Boolean that specifies to allow duplicate object field names (only the last one will be preserved).
     * 
     */
    public Optional<Output<Boolean>> allowDuplicate() {
        return Optional.ofNullable(this.allowDuplicate);
    }

    /**
     * Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.
     * 
     */
    @Import(name="binaryAsText")
    private @Nullable Output<Boolean> binaryAsText;

    /**
     * @return Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.
     * 
     */
    public Optional<Output<Boolean>> binaryAsText() {
        return Optional.ofNullable(this.binaryAsText);
    }

    /**
     * Defines the encoding format for binary input or output.
     * 
     */
    @Import(name="binaryFormat")
    private @Nullable Output<String> binaryFormat;

    /**
     * @return Defines the encoding format for binary input or output.
     * 
     */
    public Optional<Output<String>> binaryFormat() {
        return Optional.ofNullable(this.binaryFormat);
    }

    /**
     * Specifies a comment for the file format.
     * 
     */
    @Import(name="comment")
    private @Nullable Output<String> comment;

    /**
     * @return Specifies a comment for the file format.
     * 
     */
    public Optional<Output<String>> comment() {
        return Optional.ofNullable(this.comment);
    }

    /**
     * Specifies the current compression algorithm for the data file.
     * 
     */
    @Import(name="compression")
    private @Nullable Output<String> compression;

    /**
     * @return Specifies the current compression algorithm for the data file.
     * 
     */
    public Optional<Output<String>> compression() {
        return Optional.ofNullable(this.compression);
    }

    /**
     * The database in which to create the file format.
     * 
     */
    @Import(name="database")
    private @Nullable Output<String> database;

    /**
     * @return The database in which to create the file format.
     * 
     */
    public Optional<Output<String>> database() {
        return Optional.ofNullable(this.database);
    }

    /**
     * Defines the format of date values in the data files (data loading) or table (data unloading).
     * 
     */
    @Import(name="dateFormat")
    private @Nullable Output<String> dateFormat;

    /**
     * @return Defines the format of date values in the data files (data loading) or table (data unloading).
     * 
     */
    public Optional<Output<String>> dateFormat() {
        return Optional.ofNullable(this.dateFormat);
    }

    /**
     * Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.
     * 
     */
    @Import(name="disableAutoConvert")
    private @Nullable Output<Boolean> disableAutoConvert;

    /**
     * @return Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.
     * 
     */
    public Optional<Output<Boolean>> disableAutoConvert() {
        return Optional.ofNullable(this.disableAutoConvert);
    }

    /**
     * Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.
     * 
     */
    @Import(name="disableSnowflakeData")
    private @Nullable Output<Boolean> disableSnowflakeData;

    /**
     * @return Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.
     * 
     */
    public Optional<Output<Boolean>> disableSnowflakeData() {
        return Optional.ofNullable(this.disableSnowflakeData);
    }

    /**
     * Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.
     * 
     */
    @Import(name="emptyFieldAsNull")
    private @Nullable Output<Boolean> emptyFieldAsNull;

    /**
     * @return Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.
     * 
     */
    public Optional<Output<Boolean>> emptyFieldAsNull() {
        return Optional.ofNullable(this.emptyFieldAsNull);
    }

    /**
     * Boolean that enables parsing of octal numbers.
     * 
     */
    @Import(name="enableOctal")
    private @Nullable Output<Boolean> enableOctal;

    /**
     * @return Boolean that enables parsing of octal numbers.
     * 
     */
    public Optional<Output<Boolean>> enableOctal() {
        return Optional.ofNullable(this.enableOctal);
    }

    /**
     * String (constant) that specifies the character set of the source data when loading data into a table.
     * 
     */
    @Import(name="encoding")
    private @Nullable Output<String> encoding;

    /**
     * @return String (constant) that specifies the character set of the source data when loading data into a table.
     * 
     */
    public Optional<Output<String>> encoding() {
        return Optional.ofNullable(this.encoding);
    }

    /**
     * Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.
     * 
     */
    @Import(name="errorOnColumnCountMismatch")
    private @Nullable Output<Boolean> errorOnColumnCountMismatch;

    /**
     * @return Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.
     * 
     */
    public Optional<Output<Boolean>> errorOnColumnCountMismatch() {
        return Optional.ofNullable(this.errorOnColumnCountMismatch);
    }

    /**
     * Single character string used as the escape character for field values.
     * 
     */
    @Import(name="escape")
    private @Nullable Output<String> escape;

    /**
     * @return Single character string used as the escape character for field values.
     * 
     */
    public Optional<Output<String>> escape() {
        return Optional.ofNullable(this.escape);
    }

    /**
     * Single character string used as the escape character for unenclosed field values only.
     * 
     */
    @Import(name="escapeUnenclosedField")
    private @Nullable Output<String> escapeUnenclosedField;

    /**
     * @return Single character string used as the escape character for unenclosed field values only.
     * 
     */
    public Optional<Output<String>> escapeUnenclosedField() {
        return Optional.ofNullable(this.escapeUnenclosedField);
    }

    /**
     * Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).
     * 
     */
    @Import(name="fieldDelimiter")
    private @Nullable Output<String> fieldDelimiter;

    /**
     * @return Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).
     * 
     */
    public Optional<Output<String>> fieldDelimiter() {
        return Optional.ofNullable(this.fieldDelimiter);
    }

    /**
     * Character used to enclose strings.
     * 
     */
    @Import(name="fieldOptionallyEnclosedBy")
    private @Nullable Output<String> fieldOptionallyEnclosedBy;

    /**
     * @return Character used to enclose strings.
     * 
     */
    public Optional<Output<String>> fieldOptionallyEnclosedBy() {
        return Optional.ofNullable(this.fieldOptionallyEnclosedBy);
    }

    /**
     * Specifies the extension for files unloaded to a stage.
     * 
     */
    @Import(name="fileExtension")
    private @Nullable Output<String> fileExtension;

    /**
     * @return Specifies the extension for files unloaded to a stage.
     * 
     */
    public Optional<Output<String>> fileExtension() {
        return Optional.ofNullable(this.fileExtension);
    }

    /**
     * Specifies the format of the input files (for data loading) or output files (for data unloading).
     * 
     */
    @Import(name="formatType")
    private @Nullable Output<String> formatType;

    /**
     * @return Specifies the format of the input files (for data loading) or output files (for data unloading).
     * 
     */
    public Optional<Output<String>> formatType() {
        return Optional.ofNullable(this.formatType);
    }

    /**
     * Boolean that specifies whether UTF-8 encoding errors produce error conditions.
     * 
     */
    @Import(name="ignoreUtf8Errors")
    private @Nullable Output<Boolean> ignoreUtf8Errors;

    /**
     * @return Boolean that specifies whether UTF-8 encoding errors produce error conditions.
     * 
     */
    public Optional<Output<Boolean>> ignoreUtf8Errors() {
        return Optional.ofNullable(this.ignoreUtf8Errors);
    }

    /**
     * Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * String used to convert to and from SQL NULL.
     * 
     */
    @Import(name="nullIfs")
    private @Nullable Output<List<String>> nullIfs;

    /**
     * @return String used to convert to and from SQL NULL.
     * 
     */
    public Optional<Output<List<String>>> nullIfs() {
        return Optional.ofNullable(this.nullIfs);
    }

    /**
     * Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.
     * 
     */
    @Import(name="preserveSpace")
    private @Nullable Output<Boolean> preserveSpace;

    /**
     * @return Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.
     * 
     */
    public Optional<Output<Boolean>> preserveSpace() {
        return Optional.ofNullable(this.preserveSpace);
    }

    /**
     * Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).
     * 
     */
    @Import(name="recordDelimiter")
    private @Nullable Output<String> recordDelimiter;

    /**
     * @return Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).
     * 
     */
    public Optional<Output<String>> recordDelimiter() {
        return Optional.ofNullable(this.recordDelimiter);
    }

    /**
     * Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (�).
     * 
     */
    @Import(name="replaceInvalidCharacters")
    private @Nullable Output<Boolean> replaceInvalidCharacters;

    /**
     * @return Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (�).
     * 
     */
    public Optional<Output<Boolean>> replaceInvalidCharacters() {
        return Optional.ofNullable(this.replaceInvalidCharacters);
    }

    /**
     * The schema in which to create the file format.
     * 
     */
    @Import(name="schema")
    private @Nullable Output<String> schema;

    /**
     * @return The schema in which to create the file format.
     * 
     */
    public Optional<Output<String>> schema() {
        return Optional.ofNullable(this.schema);
    }

    /**
     * Boolean that specifies to skip any blank lines encountered in the data files.
     * 
     */
    @Import(name="skipBlankLines")
    private @Nullable Output<Boolean> skipBlankLines;

    /**
     * @return Boolean that specifies to skip any blank lines encountered in the data files.
     * 
     */
    public Optional<Output<Boolean>> skipBlankLines() {
        return Optional.ofNullable(this.skipBlankLines);
    }

    /**
     * Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.
     * 
     */
    @Import(name="skipByteOrderMark")
    private @Nullable Output<Boolean> skipByteOrderMark;

    /**
     * @return Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.
     * 
     */
    public Optional<Output<Boolean>> skipByteOrderMark() {
        return Optional.ofNullable(this.skipByteOrderMark);
    }

    /**
     * Number of lines at the start of the file to skip.
     * 
     */
    @Import(name="skipHeader")
    private @Nullable Output<Integer> skipHeader;

    /**
     * @return Number of lines at the start of the file to skip.
     * 
     */
    public Optional<Output<Integer>> skipHeader() {
        return Optional.ofNullable(this.skipHeader);
    }

    /**
     * Boolean that instructs the JSON parser to remove object fields or array elements containing null values.
     * 
     */
    @Import(name="stripNullValues")
    private @Nullable Output<Boolean> stripNullValues;

    /**
     * @return Boolean that instructs the JSON parser to remove object fields or array elements containing null values.
     * 
     */
    public Optional<Output<Boolean>> stripNullValues() {
        return Optional.ofNullable(this.stripNullValues);
    }

    /**
     * Boolean that instructs the JSON parser to remove outer brackets.
     * 
     */
    @Import(name="stripOuterArray")
    private @Nullable Output<Boolean> stripOuterArray;

    /**
     * @return Boolean that instructs the JSON parser to remove outer brackets.
     * 
     */
    public Optional<Output<Boolean>> stripOuterArray() {
        return Optional.ofNullable(this.stripOuterArray);
    }

    /**
     * Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.
     * 
     */
    @Import(name="stripOuterElement")
    private @Nullable Output<Boolean> stripOuterElement;

    /**
     * @return Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.
     * 
     */
    public Optional<Output<Boolean>> stripOuterElement() {
        return Optional.ofNullable(this.stripOuterElement);
    }

    /**
     * Defines the format of time values in the data files (data loading) or table (data unloading).
     * 
     */
    @Import(name="timeFormat")
    private @Nullable Output<String> timeFormat;

    /**
     * @return Defines the format of time values in the data files (data loading) or table (data unloading).
     * 
     */
    public Optional<Output<String>> timeFormat() {
        return Optional.ofNullable(this.timeFormat);
    }

    /**
     * Defines the format of timestamp values in the data files (data loading) or table (data unloading).
     * 
     */
    @Import(name="timestampFormat")
    private @Nullable Output<String> timestampFormat;

    /**
     * @return Defines the format of timestamp values in the data files (data loading) or table (data unloading).
     * 
     */
    public Optional<Output<String>> timestampFormat() {
        return Optional.ofNullable(this.timestampFormat);
    }

    /**
     * Boolean that specifies whether to remove white space from fields.
     * 
     */
    @Import(name="trimSpace")
    private @Nullable Output<Boolean> trimSpace;

    /**
     * @return Boolean that specifies whether to remove white space from fields.
     * 
     */
    public Optional<Output<Boolean>> trimSpace() {
        return Optional.ofNullable(this.trimSpace);
    }

    private FileFormatState() {}

    private FileFormatState(FileFormatState $) {
        this.allowDuplicate = $.allowDuplicate;
        this.binaryAsText = $.binaryAsText;
        this.binaryFormat = $.binaryFormat;
        this.comment = $.comment;
        this.compression = $.compression;
        this.database = $.database;
        this.dateFormat = $.dateFormat;
        this.disableAutoConvert = $.disableAutoConvert;
        this.disableSnowflakeData = $.disableSnowflakeData;
        this.emptyFieldAsNull = $.emptyFieldAsNull;
        this.enableOctal = $.enableOctal;
        this.encoding = $.encoding;
        this.errorOnColumnCountMismatch = $.errorOnColumnCountMismatch;
        this.escape = $.escape;
        this.escapeUnenclosedField = $.escapeUnenclosedField;
        this.fieldDelimiter = $.fieldDelimiter;
        this.fieldOptionallyEnclosedBy = $.fieldOptionallyEnclosedBy;
        this.fileExtension = $.fileExtension;
        this.formatType = $.formatType;
        this.ignoreUtf8Errors = $.ignoreUtf8Errors;
        this.name = $.name;
        this.nullIfs = $.nullIfs;
        this.preserveSpace = $.preserveSpace;
        this.recordDelimiter = $.recordDelimiter;
        this.replaceInvalidCharacters = $.replaceInvalidCharacters;
        this.schema = $.schema;
        this.skipBlankLines = $.skipBlankLines;
        this.skipByteOrderMark = $.skipByteOrderMark;
        this.skipHeader = $.skipHeader;
        this.stripNullValues = $.stripNullValues;
        this.stripOuterArray = $.stripOuterArray;
        this.stripOuterElement = $.stripOuterElement;
        this.timeFormat = $.timeFormat;
        this.timestampFormat = $.timestampFormat;
        this.trimSpace = $.trimSpace;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(FileFormatState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private FileFormatState $;

        public Builder() {
            $ = new FileFormatState();
        }

        public Builder(FileFormatState defaults) {
            $ = new FileFormatState(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowDuplicate Boolean that specifies to allow duplicate object field names (only the last one will be preserved).
         * 
         * @return builder
         * 
         */
        public Builder allowDuplicate(@Nullable Output<Boolean> allowDuplicate) {
            $.allowDuplicate = allowDuplicate;
            return this;
        }

        /**
         * @param allowDuplicate Boolean that specifies to allow duplicate object field names (only the last one will be preserved).
         * 
         * @return builder
         * 
         */
        public Builder allowDuplicate(Boolean allowDuplicate) {
            return allowDuplicate(Output.of(allowDuplicate));
        }

        /**
         * @param binaryAsText Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.
         * 
         * @return builder
         * 
         */
        public Builder binaryAsText(@Nullable Output<Boolean> binaryAsText) {
            $.binaryAsText = binaryAsText;
            return this;
        }

        /**
         * @param binaryAsText Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.
         * 
         * @return builder
         * 
         */
        public Builder binaryAsText(Boolean binaryAsText) {
            return binaryAsText(Output.of(binaryAsText));
        }

        /**
         * @param binaryFormat Defines the encoding format for binary input or output.
         * 
         * @return builder
         * 
         */
        public Builder binaryFormat(@Nullable Output<String> binaryFormat) {
            $.binaryFormat = binaryFormat;
            return this;
        }

        /**
         * @param binaryFormat Defines the encoding format for binary input or output.
         * 
         * @return builder
         * 
         */
        public Builder binaryFormat(String binaryFormat) {
            return binaryFormat(Output.of(binaryFormat));
        }

        /**
         * @param comment Specifies a comment for the file format.
         * 
         * @return builder
         * 
         */
        public Builder comment(@Nullable Output<String> comment) {
            $.comment = comment;
            return this;
        }

        /**
         * @param comment Specifies a comment for the file format.
         * 
         * @return builder
         * 
         */
        public Builder comment(String comment) {
            return comment(Output.of(comment));
        }

        /**
         * @param compression Specifies the current compression algorithm for the data file.
         * 
         * @return builder
         * 
         */
        public Builder compression(@Nullable Output<String> compression) {
            $.compression = compression;
            return this;
        }

        /**
         * @param compression Specifies the current compression algorithm for the data file.
         * 
         * @return builder
         * 
         */
        public Builder compression(String compression) {
            return compression(Output.of(compression));
        }

        /**
         * @param database The database in which to create the file format.
         * 
         * @return builder
         * 
         */
        public Builder database(@Nullable Output<String> database) {
            $.database = database;
            return this;
        }

        /**
         * @param database The database in which to create the file format.
         * 
         * @return builder
         * 
         */
        public Builder database(String database) {
            return database(Output.of(database));
        }

        /**
         * @param dateFormat Defines the format of date values in the data files (data loading) or table (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder dateFormat(@Nullable Output<String> dateFormat) {
            $.dateFormat = dateFormat;
            return this;
        }

        /**
         * @param dateFormat Defines the format of date values in the data files (data loading) or table (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder dateFormat(String dateFormat) {
            return dateFormat(Output.of(dateFormat));
        }

        /**
         * @param disableAutoConvert Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.
         * 
         * @return builder
         * 
         */
        public Builder disableAutoConvert(@Nullable Output<Boolean> disableAutoConvert) {
            $.disableAutoConvert = disableAutoConvert;
            return this;
        }

        /**
         * @param disableAutoConvert Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.
         * 
         * @return builder
         * 
         */
        public Builder disableAutoConvert(Boolean disableAutoConvert) {
            return disableAutoConvert(Output.of(disableAutoConvert));
        }

        /**
         * @param disableSnowflakeData Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.
         * 
         * @return builder
         * 
         */
        public Builder disableSnowflakeData(@Nullable Output<Boolean> disableSnowflakeData) {
            $.disableSnowflakeData = disableSnowflakeData;
            return this;
        }

        /**
         * @param disableSnowflakeData Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.
         * 
         * @return builder
         * 
         */
        public Builder disableSnowflakeData(Boolean disableSnowflakeData) {
            return disableSnowflakeData(Output.of(disableSnowflakeData));
        }

        /**
         * @param emptyFieldAsNull Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.
         * 
         * @return builder
         * 
         */
        public Builder emptyFieldAsNull(@Nullable Output<Boolean> emptyFieldAsNull) {
            $.emptyFieldAsNull = emptyFieldAsNull;
            return this;
        }

        /**
         * @param emptyFieldAsNull Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.
         * 
         * @return builder
         * 
         */
        public Builder emptyFieldAsNull(Boolean emptyFieldAsNull) {
            return emptyFieldAsNull(Output.of(emptyFieldAsNull));
        }

        /**
         * @param enableOctal Boolean that enables parsing of octal numbers.
         * 
         * @return builder
         * 
         */
        public Builder enableOctal(@Nullable Output<Boolean> enableOctal) {
            $.enableOctal = enableOctal;
            return this;
        }

        /**
         * @param enableOctal Boolean that enables parsing of octal numbers.
         * 
         * @return builder
         * 
         */
        public Builder enableOctal(Boolean enableOctal) {
            return enableOctal(Output.of(enableOctal));
        }

        /**
         * @param encoding String (constant) that specifies the character set of the source data when loading data into a table.
         * 
         * @return builder
         * 
         */
        public Builder encoding(@Nullable Output<String> encoding) {
            $.encoding = encoding;
            return this;
        }

        /**
         * @param encoding String (constant) that specifies the character set of the source data when loading data into a table.
         * 
         * @return builder
         * 
         */
        public Builder encoding(String encoding) {
            return encoding(Output.of(encoding));
        }

        /**
         * @param errorOnColumnCountMismatch Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.
         * 
         * @return builder
         * 
         */
        public Builder errorOnColumnCountMismatch(@Nullable Output<Boolean> errorOnColumnCountMismatch) {
            $.errorOnColumnCountMismatch = errorOnColumnCountMismatch;
            return this;
        }

        /**
         * @param errorOnColumnCountMismatch Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.
         * 
         * @return builder
         * 
         */
        public Builder errorOnColumnCountMismatch(Boolean errorOnColumnCountMismatch) {
            return errorOnColumnCountMismatch(Output.of(errorOnColumnCountMismatch));
        }

        /**
         * @param escape Single character string used as the escape character for field values.
         * 
         * @return builder
         * 
         */
        public Builder escape(@Nullable Output<String> escape) {
            $.escape = escape;
            return this;
        }

        /**
         * @param escape Single character string used as the escape character for field values.
         * 
         * @return builder
         * 
         */
        public Builder escape(String escape) {
            return escape(Output.of(escape));
        }

        /**
         * @param escapeUnenclosedField Single character string used as the escape character for unenclosed field values only.
         * 
         * @return builder
         * 
         */
        public Builder escapeUnenclosedField(@Nullable Output<String> escapeUnenclosedField) {
            $.escapeUnenclosedField = escapeUnenclosedField;
            return this;
        }

        /**
         * @param escapeUnenclosedField Single character string used as the escape character for unenclosed field values only.
         * 
         * @return builder
         * 
         */
        public Builder escapeUnenclosedField(String escapeUnenclosedField) {
            return escapeUnenclosedField(Output.of(escapeUnenclosedField));
        }

        /**
         * @param fieldDelimiter Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder fieldDelimiter(@Nullable Output<String> fieldDelimiter) {
            $.fieldDelimiter = fieldDelimiter;
            return this;
        }

        /**
         * @param fieldDelimiter Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder fieldDelimiter(String fieldDelimiter) {
            return fieldDelimiter(Output.of(fieldDelimiter));
        }

        /**
         * @param fieldOptionallyEnclosedBy Character used to enclose strings.
         * 
         * @return builder
         * 
         */
        public Builder fieldOptionallyEnclosedBy(@Nullable Output<String> fieldOptionallyEnclosedBy) {
            $.fieldOptionallyEnclosedBy = fieldOptionallyEnclosedBy;
            return this;
        }

        /**
         * @param fieldOptionallyEnclosedBy Character used to enclose strings.
         * 
         * @return builder
         * 
         */
        public Builder fieldOptionallyEnclosedBy(String fieldOptionallyEnclosedBy) {
            return fieldOptionallyEnclosedBy(Output.of(fieldOptionallyEnclosedBy));
        }

        /**
         * @param fileExtension Specifies the extension for files unloaded to a stage.
         * 
         * @return builder
         * 
         */
        public Builder fileExtension(@Nullable Output<String> fileExtension) {
            $.fileExtension = fileExtension;
            return this;
        }

        /**
         * @param fileExtension Specifies the extension for files unloaded to a stage.
         * 
         * @return builder
         * 
         */
        public Builder fileExtension(String fileExtension) {
            return fileExtension(Output.of(fileExtension));
        }

        /**
         * @param formatType Specifies the format of the input files (for data loading) or output files (for data unloading).
         * 
         * @return builder
         * 
         */
        public Builder formatType(@Nullable Output<String> formatType) {
            $.formatType = formatType;
            return this;
        }

        /**
         * @param formatType Specifies the format of the input files (for data loading) or output files (for data unloading).
         * 
         * @return builder
         * 
         */
        public Builder formatType(String formatType) {
            return formatType(Output.of(formatType));
        }

        /**
         * @param ignoreUtf8Errors Boolean that specifies whether UTF-8 encoding errors produce error conditions.
         * 
         * @return builder
         * 
         */
        public Builder ignoreUtf8Errors(@Nullable Output<Boolean> ignoreUtf8Errors) {
            $.ignoreUtf8Errors = ignoreUtf8Errors;
            return this;
        }

        /**
         * @param ignoreUtf8Errors Boolean that specifies whether UTF-8 encoding errors produce error conditions.
         * 
         * @return builder
         * 
         */
        public Builder ignoreUtf8Errors(Boolean ignoreUtf8Errors) {
            return ignoreUtf8Errors(Output.of(ignoreUtf8Errors));
        }

        /**
         * @param name Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param nullIfs String used to convert to and from SQL NULL.
         * 
         * @return builder
         * 
         */
        public Builder nullIfs(@Nullable Output<List<String>> nullIfs) {
            $.nullIfs = nullIfs;
            return this;
        }

        /**
         * @param nullIfs String used to convert to and from SQL NULL.
         * 
         * @return builder
         * 
         */
        public Builder nullIfs(List<String> nullIfs) {
            return nullIfs(Output.of(nullIfs));
        }

        /**
         * @param nullIfs String used to convert to and from SQL NULL.
         * 
         * @return builder
         * 
         */
        public Builder nullIfs(String... nullIfs) {
            return nullIfs(List.of(nullIfs));
        }

        /**
         * @param preserveSpace Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.
         * 
         * @return builder
         * 
         */
        public Builder preserveSpace(@Nullable Output<Boolean> preserveSpace) {
            $.preserveSpace = preserveSpace;
            return this;
        }

        /**
         * @param preserveSpace Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.
         * 
         * @return builder
         * 
         */
        public Builder preserveSpace(Boolean preserveSpace) {
            return preserveSpace(Output.of(preserveSpace));
        }

        /**
         * @param recordDelimiter Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder recordDelimiter(@Nullable Output<String> recordDelimiter) {
            $.recordDelimiter = recordDelimiter;
            return this;
        }

        /**
         * @param recordDelimiter Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder recordDelimiter(String recordDelimiter) {
            return recordDelimiter(Output.of(recordDelimiter));
        }

        /**
         * @param replaceInvalidCharacters Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (�).
         * 
         * @return builder
         * 
         */
        public Builder replaceInvalidCharacters(@Nullable Output<Boolean> replaceInvalidCharacters) {
            $.replaceInvalidCharacters = replaceInvalidCharacters;
            return this;
        }

        /**
         * @param replaceInvalidCharacters Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (�).
         * 
         * @return builder
         * 
         */
        public Builder replaceInvalidCharacters(Boolean replaceInvalidCharacters) {
            return replaceInvalidCharacters(Output.of(replaceInvalidCharacters));
        }

        /**
         * @param schema The schema in which to create the file format.
         * 
         * @return builder
         * 
         */
        public Builder schema(@Nullable Output<String> schema) {
            $.schema = schema;
            return this;
        }

        /**
         * @param schema The schema in which to create the file format.
         * 
         * @return builder
         * 
         */
        public Builder schema(String schema) {
            return schema(Output.of(schema));
        }

        /**
         * @param skipBlankLines Boolean that specifies to skip any blank lines encountered in the data files.
         * 
         * @return builder
         * 
         */
        public Builder skipBlankLines(@Nullable Output<Boolean> skipBlankLines) {
            $.skipBlankLines = skipBlankLines;
            return this;
        }

        /**
         * @param skipBlankLines Boolean that specifies to skip any blank lines encountered in the data files.
         * 
         * @return builder
         * 
         */
        public Builder skipBlankLines(Boolean skipBlankLines) {
            return skipBlankLines(Output.of(skipBlankLines));
        }

        /**
         * @param skipByteOrderMark Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.
         * 
         * @return builder
         * 
         */
        public Builder skipByteOrderMark(@Nullable Output<Boolean> skipByteOrderMark) {
            $.skipByteOrderMark = skipByteOrderMark;
            return this;
        }

        /**
         * @param skipByteOrderMark Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.
         * 
         * @return builder
         * 
         */
        public Builder skipByteOrderMark(Boolean skipByteOrderMark) {
            return skipByteOrderMark(Output.of(skipByteOrderMark));
        }

        /**
         * @param skipHeader Number of lines at the start of the file to skip.
         * 
         * @return builder
         * 
         */
        public Builder skipHeader(@Nullable Output<Integer> skipHeader) {
            $.skipHeader = skipHeader;
            return this;
        }

        /**
         * @param skipHeader Number of lines at the start of the file to skip.
         * 
         * @return builder
         * 
         */
        public Builder skipHeader(Integer skipHeader) {
            return skipHeader(Output.of(skipHeader));
        }

        /**
         * @param stripNullValues Boolean that instructs the JSON parser to remove object fields or array elements containing null values.
         * 
         * @return builder
         * 
         */
        public Builder stripNullValues(@Nullable Output<Boolean> stripNullValues) {
            $.stripNullValues = stripNullValues;
            return this;
        }

        /**
         * @param stripNullValues Boolean that instructs the JSON parser to remove object fields or array elements containing null values.
         * 
         * @return builder
         * 
         */
        public Builder stripNullValues(Boolean stripNullValues) {
            return stripNullValues(Output.of(stripNullValues));
        }

        /**
         * @param stripOuterArray Boolean that instructs the JSON parser to remove outer brackets.
         * 
         * @return builder
         * 
         */
        public Builder stripOuterArray(@Nullable Output<Boolean> stripOuterArray) {
            $.stripOuterArray = stripOuterArray;
            return this;
        }

        /**
         * @param stripOuterArray Boolean that instructs the JSON parser to remove outer brackets.
         * 
         * @return builder
         * 
         */
        public Builder stripOuterArray(Boolean stripOuterArray) {
            return stripOuterArray(Output.of(stripOuterArray));
        }

        /**
         * @param stripOuterElement Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.
         * 
         * @return builder
         * 
         */
        public Builder stripOuterElement(@Nullable Output<Boolean> stripOuterElement) {
            $.stripOuterElement = stripOuterElement;
            return this;
        }

        /**
         * @param stripOuterElement Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.
         * 
         * @return builder
         * 
         */
        public Builder stripOuterElement(Boolean stripOuterElement) {
            return stripOuterElement(Output.of(stripOuterElement));
        }

        /**
         * @param timeFormat Defines the format of time values in the data files (data loading) or table (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder timeFormat(@Nullable Output<String> timeFormat) {
            $.timeFormat = timeFormat;
            return this;
        }

        /**
         * @param timeFormat Defines the format of time values in the data files (data loading) or table (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder timeFormat(String timeFormat) {
            return timeFormat(Output.of(timeFormat));
        }

        /**
         * @param timestampFormat Defines the format of timestamp values in the data files (data loading) or table (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder timestampFormat(@Nullable Output<String> timestampFormat) {
            $.timestampFormat = timestampFormat;
            return this;
        }

        /**
         * @param timestampFormat Defines the format of timestamp values in the data files (data loading) or table (data unloading).
         * 
         * @return builder
         * 
         */
        public Builder timestampFormat(String timestampFormat) {
            return timestampFormat(Output.of(timestampFormat));
        }

        /**
         * @param trimSpace Boolean that specifies whether to remove white space from fields.
         * 
         * @return builder
         * 
         */
        public Builder trimSpace(@Nullable Output<Boolean> trimSpace) {
            $.trimSpace = trimSpace;
            return this;
        }

        /**
         * @param trimSpace Boolean that specifies whether to remove white space from fields.
         * 
         * @return builder
         * 
         */
        public Builder trimSpace(Boolean trimSpace) {
            return trimSpace(Output.of(trimSpace));
        }

        public FileFormatState build() {
            return $;
        }
    }

}
