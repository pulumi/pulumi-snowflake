// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package snowflake

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// ```sh
// $ pulumi import snowflake:index/dynamicTable:DynamicTable dt "mydb|myschema|product"
// ```
type DynamicTable struct {
	pulumi.CustomResourceState

	// Whether auto-clustering is enabled on the dynamic table. Not currently supported for dynamic tables.
	AutomaticClustering pulumi.BoolOutput `pulumi:"automaticClustering"`
	// Number of bytes that will be scanned if the entire dynamic table is scanned in a query.
	Bytes pulumi.IntOutput `pulumi:"bytes"`
	// The clustering key for the dynamic table.
	ClusterBy pulumi.StringOutput `pulumi:"clusterBy"`
	// Specifies a comment for the dynamic table.
	Comment pulumi.StringPtrOutput `pulumi:"comment"`
	// Time when this dynamic table was created.
	CreatedOn pulumi.StringOutput `pulumi:"createdOn"`
	// Timestamp of the data in the base object(s) that is included in the dynamic table.
	DataTimestamp pulumi.StringOutput `pulumi:"dataTimestamp"`
	// The database in which to create the dynamic table.
	Database pulumi.StringOutput `pulumi:"database"`
	// Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
	FullyQualifiedName pulumi.StringOutput `pulumi:"fullyQualifiedName"`
	// Initialize trigger for the dynamic table. Can only be set on creation. Available options are ON*CREATE and ON*SCHEDULE.
	Initialize pulumi.StringPtrOutput `pulumi:"initialize"`
	// TRUE if the dynamic table has been cloned, else FALSE.
	IsClone pulumi.BoolOutput `pulumi:"isClone"`
	// TRUE if the dynamic table is a replica. else FALSE.
	IsReplica pulumi.BoolOutput `pulumi:"isReplica"`
	// Timestamp of last suspension.
	LastSuspendedOn pulumi.StringOutput `pulumi:"lastSuspendedOn"`
	// Specifies the identifier (i.e. name) for the dynamic table; must be unique for the schema in which the dynamic table is created.
	Name pulumi.StringOutput `pulumi:"name"`
	// Specifies whether to replace the dynamic table if it already exists.
	OrReplace pulumi.BoolPtrOutput `pulumi:"orReplace"`
	// Role that owns the dynamic table.
	Owner pulumi.StringOutput `pulumi:"owner"`
	// Specifies the query to use to populate the dynamic table.
	Query pulumi.StringOutput `pulumi:"query"`
	// INCREMENTAL to use incremental refreshes, FULL to recompute the whole table on every refresh, or AUTO to let Snowflake decide.
	RefreshMode pulumi.StringPtrOutput `pulumi:"refreshMode"`
	// Explanation for why FULL refresh mode was chosen. NULL if refresh mode is not FULL.
	RefreshModeReason pulumi.StringOutput `pulumi:"refreshModeReason"`
	// Number of rows in the table.
	Rows pulumi.IntOutput `pulumi:"rows"`
	// Displays ACTIVE for dynamic tables that are actively scheduling refreshes and SUSPENDED for suspended dynamic tables.
	SchedulingState pulumi.StringOutput `pulumi:"schedulingState"`
	// The schema in which to create the dynamic table.
	Schema pulumi.StringOutput `pulumi:"schema"`
	// Specifies the target lag time for the dynamic table.
	TargetLag DynamicTableTargetLagOutput `pulumi:"targetLag"`
	// The warehouse in which to create the dynamic table.
	Warehouse pulumi.StringOutput `pulumi:"warehouse"`
}

// NewDynamicTable registers a new resource with the given unique name, arguments, and options.
func NewDynamicTable(ctx *pulumi.Context,
	name string, args *DynamicTableArgs, opts ...pulumi.ResourceOption) (*DynamicTable, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Database == nil {
		return nil, errors.New("invalid value for required argument 'Database'")
	}
	if args.Query == nil {
		return nil, errors.New("invalid value for required argument 'Query'")
	}
	if args.Schema == nil {
		return nil, errors.New("invalid value for required argument 'Schema'")
	}
	if args.TargetLag == nil {
		return nil, errors.New("invalid value for required argument 'TargetLag'")
	}
	if args.Warehouse == nil {
		return nil, errors.New("invalid value for required argument 'Warehouse'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DynamicTable
	err := ctx.RegisterResource("snowflake:index/dynamicTable:DynamicTable", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDynamicTable gets an existing DynamicTable resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDynamicTable(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DynamicTableState, opts ...pulumi.ResourceOption) (*DynamicTable, error) {
	var resource DynamicTable
	err := ctx.ReadResource("snowflake:index/dynamicTable:DynamicTable", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DynamicTable resources.
type dynamicTableState struct {
	// Whether auto-clustering is enabled on the dynamic table. Not currently supported for dynamic tables.
	AutomaticClustering *bool `pulumi:"automaticClustering"`
	// Number of bytes that will be scanned if the entire dynamic table is scanned in a query.
	Bytes *int `pulumi:"bytes"`
	// The clustering key for the dynamic table.
	ClusterBy *string `pulumi:"clusterBy"`
	// Specifies a comment for the dynamic table.
	Comment *string `pulumi:"comment"`
	// Time when this dynamic table was created.
	CreatedOn *string `pulumi:"createdOn"`
	// Timestamp of the data in the base object(s) that is included in the dynamic table.
	DataTimestamp *string `pulumi:"dataTimestamp"`
	// The database in which to create the dynamic table.
	Database *string `pulumi:"database"`
	// Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
	FullyQualifiedName *string `pulumi:"fullyQualifiedName"`
	// Initialize trigger for the dynamic table. Can only be set on creation. Available options are ON*CREATE and ON*SCHEDULE.
	Initialize *string `pulumi:"initialize"`
	// TRUE if the dynamic table has been cloned, else FALSE.
	IsClone *bool `pulumi:"isClone"`
	// TRUE if the dynamic table is a replica. else FALSE.
	IsReplica *bool `pulumi:"isReplica"`
	// Timestamp of last suspension.
	LastSuspendedOn *string `pulumi:"lastSuspendedOn"`
	// Specifies the identifier (i.e. name) for the dynamic table; must be unique for the schema in which the dynamic table is created.
	Name *string `pulumi:"name"`
	// Specifies whether to replace the dynamic table if it already exists.
	OrReplace *bool `pulumi:"orReplace"`
	// Role that owns the dynamic table.
	Owner *string `pulumi:"owner"`
	// Specifies the query to use to populate the dynamic table.
	Query *string `pulumi:"query"`
	// INCREMENTAL to use incremental refreshes, FULL to recompute the whole table on every refresh, or AUTO to let Snowflake decide.
	RefreshMode *string `pulumi:"refreshMode"`
	// Explanation for why FULL refresh mode was chosen. NULL if refresh mode is not FULL.
	RefreshModeReason *string `pulumi:"refreshModeReason"`
	// Number of rows in the table.
	Rows *int `pulumi:"rows"`
	// Displays ACTIVE for dynamic tables that are actively scheduling refreshes and SUSPENDED for suspended dynamic tables.
	SchedulingState *string `pulumi:"schedulingState"`
	// The schema in which to create the dynamic table.
	Schema *string `pulumi:"schema"`
	// Specifies the target lag time for the dynamic table.
	TargetLag *DynamicTableTargetLag `pulumi:"targetLag"`
	// The warehouse in which to create the dynamic table.
	Warehouse *string `pulumi:"warehouse"`
}

type DynamicTableState struct {
	// Whether auto-clustering is enabled on the dynamic table. Not currently supported for dynamic tables.
	AutomaticClustering pulumi.BoolPtrInput
	// Number of bytes that will be scanned if the entire dynamic table is scanned in a query.
	Bytes pulumi.IntPtrInput
	// The clustering key for the dynamic table.
	ClusterBy pulumi.StringPtrInput
	// Specifies a comment for the dynamic table.
	Comment pulumi.StringPtrInput
	// Time when this dynamic table was created.
	CreatedOn pulumi.StringPtrInput
	// Timestamp of the data in the base object(s) that is included in the dynamic table.
	DataTimestamp pulumi.StringPtrInput
	// The database in which to create the dynamic table.
	Database pulumi.StringPtrInput
	// Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
	FullyQualifiedName pulumi.StringPtrInput
	// Initialize trigger for the dynamic table. Can only be set on creation. Available options are ON*CREATE and ON*SCHEDULE.
	Initialize pulumi.StringPtrInput
	// TRUE if the dynamic table has been cloned, else FALSE.
	IsClone pulumi.BoolPtrInput
	// TRUE if the dynamic table is a replica. else FALSE.
	IsReplica pulumi.BoolPtrInput
	// Timestamp of last suspension.
	LastSuspendedOn pulumi.StringPtrInput
	// Specifies the identifier (i.e. name) for the dynamic table; must be unique for the schema in which the dynamic table is created.
	Name pulumi.StringPtrInput
	// Specifies whether to replace the dynamic table if it already exists.
	OrReplace pulumi.BoolPtrInput
	// Role that owns the dynamic table.
	Owner pulumi.StringPtrInput
	// Specifies the query to use to populate the dynamic table.
	Query pulumi.StringPtrInput
	// INCREMENTAL to use incremental refreshes, FULL to recompute the whole table on every refresh, or AUTO to let Snowflake decide.
	RefreshMode pulumi.StringPtrInput
	// Explanation for why FULL refresh mode was chosen. NULL if refresh mode is not FULL.
	RefreshModeReason pulumi.StringPtrInput
	// Number of rows in the table.
	Rows pulumi.IntPtrInput
	// Displays ACTIVE for dynamic tables that are actively scheduling refreshes and SUSPENDED for suspended dynamic tables.
	SchedulingState pulumi.StringPtrInput
	// The schema in which to create the dynamic table.
	Schema pulumi.StringPtrInput
	// Specifies the target lag time for the dynamic table.
	TargetLag DynamicTableTargetLagPtrInput
	// The warehouse in which to create the dynamic table.
	Warehouse pulumi.StringPtrInput
}

func (DynamicTableState) ElementType() reflect.Type {
	return reflect.TypeOf((*dynamicTableState)(nil)).Elem()
}

type dynamicTableArgs struct {
	// Specifies a comment for the dynamic table.
	Comment *string `pulumi:"comment"`
	// The database in which to create the dynamic table.
	Database string `pulumi:"database"`
	// Initialize trigger for the dynamic table. Can only be set on creation. Available options are ON*CREATE and ON*SCHEDULE.
	Initialize *string `pulumi:"initialize"`
	// Specifies the identifier (i.e. name) for the dynamic table; must be unique for the schema in which the dynamic table is created.
	Name *string `pulumi:"name"`
	// Specifies whether to replace the dynamic table if it already exists.
	OrReplace *bool `pulumi:"orReplace"`
	// Specifies the query to use to populate the dynamic table.
	Query string `pulumi:"query"`
	// INCREMENTAL to use incremental refreshes, FULL to recompute the whole table on every refresh, or AUTO to let Snowflake decide.
	RefreshMode *string `pulumi:"refreshMode"`
	// The schema in which to create the dynamic table.
	Schema string `pulumi:"schema"`
	// Specifies the target lag time for the dynamic table.
	TargetLag DynamicTableTargetLag `pulumi:"targetLag"`
	// The warehouse in which to create the dynamic table.
	Warehouse string `pulumi:"warehouse"`
}

// The set of arguments for constructing a DynamicTable resource.
type DynamicTableArgs struct {
	// Specifies a comment for the dynamic table.
	Comment pulumi.StringPtrInput
	// The database in which to create the dynamic table.
	Database pulumi.StringInput
	// Initialize trigger for the dynamic table. Can only be set on creation. Available options are ON*CREATE and ON*SCHEDULE.
	Initialize pulumi.StringPtrInput
	// Specifies the identifier (i.e. name) for the dynamic table; must be unique for the schema in which the dynamic table is created.
	Name pulumi.StringPtrInput
	// Specifies whether to replace the dynamic table if it already exists.
	OrReplace pulumi.BoolPtrInput
	// Specifies the query to use to populate the dynamic table.
	Query pulumi.StringInput
	// INCREMENTAL to use incremental refreshes, FULL to recompute the whole table on every refresh, or AUTO to let Snowflake decide.
	RefreshMode pulumi.StringPtrInput
	// The schema in which to create the dynamic table.
	Schema pulumi.StringInput
	// Specifies the target lag time for the dynamic table.
	TargetLag DynamicTableTargetLagInput
	// The warehouse in which to create the dynamic table.
	Warehouse pulumi.StringInput
}

func (DynamicTableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dynamicTableArgs)(nil)).Elem()
}

type DynamicTableInput interface {
	pulumi.Input

	ToDynamicTableOutput() DynamicTableOutput
	ToDynamicTableOutputWithContext(ctx context.Context) DynamicTableOutput
}

func (*DynamicTable) ElementType() reflect.Type {
	return reflect.TypeOf((**DynamicTable)(nil)).Elem()
}

func (i *DynamicTable) ToDynamicTableOutput() DynamicTableOutput {
	return i.ToDynamicTableOutputWithContext(context.Background())
}

func (i *DynamicTable) ToDynamicTableOutputWithContext(ctx context.Context) DynamicTableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DynamicTableOutput)
}

// DynamicTableArrayInput is an input type that accepts DynamicTableArray and DynamicTableArrayOutput values.
// You can construct a concrete instance of `DynamicTableArrayInput` via:
//
//	DynamicTableArray{ DynamicTableArgs{...} }
type DynamicTableArrayInput interface {
	pulumi.Input

	ToDynamicTableArrayOutput() DynamicTableArrayOutput
	ToDynamicTableArrayOutputWithContext(context.Context) DynamicTableArrayOutput
}

type DynamicTableArray []DynamicTableInput

func (DynamicTableArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DynamicTable)(nil)).Elem()
}

func (i DynamicTableArray) ToDynamicTableArrayOutput() DynamicTableArrayOutput {
	return i.ToDynamicTableArrayOutputWithContext(context.Background())
}

func (i DynamicTableArray) ToDynamicTableArrayOutputWithContext(ctx context.Context) DynamicTableArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DynamicTableArrayOutput)
}

// DynamicTableMapInput is an input type that accepts DynamicTableMap and DynamicTableMapOutput values.
// You can construct a concrete instance of `DynamicTableMapInput` via:
//
//	DynamicTableMap{ "key": DynamicTableArgs{...} }
type DynamicTableMapInput interface {
	pulumi.Input

	ToDynamicTableMapOutput() DynamicTableMapOutput
	ToDynamicTableMapOutputWithContext(context.Context) DynamicTableMapOutput
}

type DynamicTableMap map[string]DynamicTableInput

func (DynamicTableMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DynamicTable)(nil)).Elem()
}

func (i DynamicTableMap) ToDynamicTableMapOutput() DynamicTableMapOutput {
	return i.ToDynamicTableMapOutputWithContext(context.Background())
}

func (i DynamicTableMap) ToDynamicTableMapOutputWithContext(ctx context.Context) DynamicTableMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DynamicTableMapOutput)
}

type DynamicTableOutput struct{ *pulumi.OutputState }

func (DynamicTableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DynamicTable)(nil)).Elem()
}

func (o DynamicTableOutput) ToDynamicTableOutput() DynamicTableOutput {
	return o
}

func (o DynamicTableOutput) ToDynamicTableOutputWithContext(ctx context.Context) DynamicTableOutput {
	return o
}

// Whether auto-clustering is enabled on the dynamic table. Not currently supported for dynamic tables.
func (o DynamicTableOutput) AutomaticClustering() pulumi.BoolOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.BoolOutput { return v.AutomaticClustering }).(pulumi.BoolOutput)
}

// Number of bytes that will be scanned if the entire dynamic table is scanned in a query.
func (o DynamicTableOutput) Bytes() pulumi.IntOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.IntOutput { return v.Bytes }).(pulumi.IntOutput)
}

// The clustering key for the dynamic table.
func (o DynamicTableOutput) ClusterBy() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.ClusterBy }).(pulumi.StringOutput)
}

// Specifies a comment for the dynamic table.
func (o DynamicTableOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// Time when this dynamic table was created.
func (o DynamicTableOutput) CreatedOn() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.CreatedOn }).(pulumi.StringOutput)
}

// Timestamp of the data in the base object(s) that is included in the dynamic table.
func (o DynamicTableOutput) DataTimestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.DataTimestamp }).(pulumi.StringOutput)
}

// The database in which to create the dynamic table.
func (o DynamicTableOutput) Database() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.Database }).(pulumi.StringOutput)
}

// Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
func (o DynamicTableOutput) FullyQualifiedName() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.FullyQualifiedName }).(pulumi.StringOutput)
}

// Initialize trigger for the dynamic table. Can only be set on creation. Available options are ON*CREATE and ON*SCHEDULE.
func (o DynamicTableOutput) Initialize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringPtrOutput { return v.Initialize }).(pulumi.StringPtrOutput)
}

// TRUE if the dynamic table has been cloned, else FALSE.
func (o DynamicTableOutput) IsClone() pulumi.BoolOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.BoolOutput { return v.IsClone }).(pulumi.BoolOutput)
}

// TRUE if the dynamic table is a replica. else FALSE.
func (o DynamicTableOutput) IsReplica() pulumi.BoolOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.BoolOutput { return v.IsReplica }).(pulumi.BoolOutput)
}

// Timestamp of last suspension.
func (o DynamicTableOutput) LastSuspendedOn() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.LastSuspendedOn }).(pulumi.StringOutput)
}

// Specifies the identifier (i.e. name) for the dynamic table; must be unique for the schema in which the dynamic table is created.
func (o DynamicTableOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Specifies whether to replace the dynamic table if it already exists.
func (o DynamicTableOutput) OrReplace() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.BoolPtrOutput { return v.OrReplace }).(pulumi.BoolPtrOutput)
}

// Role that owns the dynamic table.
func (o DynamicTableOutput) Owner() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.Owner }).(pulumi.StringOutput)
}

// Specifies the query to use to populate the dynamic table.
func (o DynamicTableOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.Query }).(pulumi.StringOutput)
}

// INCREMENTAL to use incremental refreshes, FULL to recompute the whole table on every refresh, or AUTO to let Snowflake decide.
func (o DynamicTableOutput) RefreshMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringPtrOutput { return v.RefreshMode }).(pulumi.StringPtrOutput)
}

// Explanation for why FULL refresh mode was chosen. NULL if refresh mode is not FULL.
func (o DynamicTableOutput) RefreshModeReason() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.RefreshModeReason }).(pulumi.StringOutput)
}

// Number of rows in the table.
func (o DynamicTableOutput) Rows() pulumi.IntOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.IntOutput { return v.Rows }).(pulumi.IntOutput)
}

// Displays ACTIVE for dynamic tables that are actively scheduling refreshes and SUSPENDED for suspended dynamic tables.
func (o DynamicTableOutput) SchedulingState() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.SchedulingState }).(pulumi.StringOutput)
}

// The schema in which to create the dynamic table.
func (o DynamicTableOutput) Schema() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.Schema }).(pulumi.StringOutput)
}

// Specifies the target lag time for the dynamic table.
func (o DynamicTableOutput) TargetLag() DynamicTableTargetLagOutput {
	return o.ApplyT(func(v *DynamicTable) DynamicTableTargetLagOutput { return v.TargetLag }).(DynamicTableTargetLagOutput)
}

// The warehouse in which to create the dynamic table.
func (o DynamicTableOutput) Warehouse() pulumi.StringOutput {
	return o.ApplyT(func(v *DynamicTable) pulumi.StringOutput { return v.Warehouse }).(pulumi.StringOutput)
}

type DynamicTableArrayOutput struct{ *pulumi.OutputState }

func (DynamicTableArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DynamicTable)(nil)).Elem()
}

func (o DynamicTableArrayOutput) ToDynamicTableArrayOutput() DynamicTableArrayOutput {
	return o
}

func (o DynamicTableArrayOutput) ToDynamicTableArrayOutputWithContext(ctx context.Context) DynamicTableArrayOutput {
	return o
}

func (o DynamicTableArrayOutput) Index(i pulumi.IntInput) DynamicTableOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DynamicTable {
		return vs[0].([]*DynamicTable)[vs[1].(int)]
	}).(DynamicTableOutput)
}

type DynamicTableMapOutput struct{ *pulumi.OutputState }

func (DynamicTableMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DynamicTable)(nil)).Elem()
}

func (o DynamicTableMapOutput) ToDynamicTableMapOutput() DynamicTableMapOutput {
	return o
}

func (o DynamicTableMapOutput) ToDynamicTableMapOutputWithContext(ctx context.Context) DynamicTableMapOutput {
	return o
}

func (o DynamicTableMapOutput) MapIndex(k pulumi.StringInput) DynamicTableOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DynamicTable {
		return vs[0].(map[string]*DynamicTable)[vs[1].(string)]
	}).(DynamicTableOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DynamicTableInput)(nil)).Elem(), &DynamicTable{})
	pulumi.RegisterInputType(reflect.TypeOf((*DynamicTableArrayInput)(nil)).Elem(), DynamicTableArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DynamicTableMapInput)(nil)).Elem(), DynamicTableMap{})
	pulumi.RegisterOutputType(DynamicTableOutput{})
	pulumi.RegisterOutputType(DynamicTableArrayOutput{})
	pulumi.RegisterOutputType(DynamicTableMapOutput{})
}
