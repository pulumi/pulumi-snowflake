// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package snowflake

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-snowflake/sdk/v2/go/snowflake/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// ```sh
// $ pulumi import snowflake:index/listing:Listing example '"<listing_name>"'
// ```
type Listing struct {
	pulumi.CustomResourceState

	// Specifies the application package attached to the listing.
	ApplicationPackage pulumi.StringPtrOutput `pulumi:"applicationPackage"`
	// Specifies a comment for the listing.
	Comment pulumi.StringPtrOutput `pulumi:"comment"`
	// Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
	FullyQualifiedName pulumi.StringOutput   `pulumi:"fullyQualifiedName"`
	Manifest           ListingManifestOutput `pulumi:"manifest"`
	// Specifies the listing identifier (name). It must be unique within the organization, regardless of which Snowflake region the account is located in. Must start with an alphabetic character and cannot contain spaces or special characters except for underscores.
	Name pulumi.StringOutput `pulumi:"name"`
	// (Default: fallback to Snowflake default - uses special value that cannot be set in the configuration manually (`default`)) Determines if the listing should be published.
	Publish pulumi.StringPtrOutput `pulumi:"publish"`
	// Specifies the identifier for the share to attach to the listing.
	Share pulumi.StringPtrOutput `pulumi:"share"`
	// Outputs the result of `SHOW LISTINGS` for the given listing.
	ShowOutputs ListingShowOutputArrayOutput `pulumi:"showOutputs"`
}

// NewListing registers a new resource with the given unique name, arguments, and options.
func NewListing(ctx *pulumi.Context,
	name string, args *ListingArgs, opts ...pulumi.ResourceOption) (*Listing, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Manifest == nil {
		return nil, errors.New("invalid value for required argument 'Manifest'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Listing
	err := ctx.RegisterResource("snowflake:index/listing:Listing", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetListing gets an existing Listing resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetListing(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ListingState, opts ...pulumi.ResourceOption) (*Listing, error) {
	var resource Listing
	err := ctx.ReadResource("snowflake:index/listing:Listing", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Listing resources.
type listingState struct {
	// Specifies the application package attached to the listing.
	ApplicationPackage *string `pulumi:"applicationPackage"`
	// Specifies a comment for the listing.
	Comment *string `pulumi:"comment"`
	// Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
	FullyQualifiedName *string          `pulumi:"fullyQualifiedName"`
	Manifest           *ListingManifest `pulumi:"manifest"`
	// Specifies the listing identifier (name). It must be unique within the organization, regardless of which Snowflake region the account is located in. Must start with an alphabetic character and cannot contain spaces or special characters except for underscores.
	Name *string `pulumi:"name"`
	// (Default: fallback to Snowflake default - uses special value that cannot be set in the configuration manually (`default`)) Determines if the listing should be published.
	Publish *string `pulumi:"publish"`
	// Specifies the identifier for the share to attach to the listing.
	Share *string `pulumi:"share"`
	// Outputs the result of `SHOW LISTINGS` for the given listing.
	ShowOutputs []ListingShowOutput `pulumi:"showOutputs"`
}

type ListingState struct {
	// Specifies the application package attached to the listing.
	ApplicationPackage pulumi.StringPtrInput
	// Specifies a comment for the listing.
	Comment pulumi.StringPtrInput
	// Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
	FullyQualifiedName pulumi.StringPtrInput
	Manifest           ListingManifestPtrInput
	// Specifies the listing identifier (name). It must be unique within the organization, regardless of which Snowflake region the account is located in. Must start with an alphabetic character and cannot contain spaces or special characters except for underscores.
	Name pulumi.StringPtrInput
	// (Default: fallback to Snowflake default - uses special value that cannot be set in the configuration manually (`default`)) Determines if the listing should be published.
	Publish pulumi.StringPtrInput
	// Specifies the identifier for the share to attach to the listing.
	Share pulumi.StringPtrInput
	// Outputs the result of `SHOW LISTINGS` for the given listing.
	ShowOutputs ListingShowOutputArrayInput
}

func (ListingState) ElementType() reflect.Type {
	return reflect.TypeOf((*listingState)(nil)).Elem()
}

type listingArgs struct {
	// Specifies the application package attached to the listing.
	ApplicationPackage *string `pulumi:"applicationPackage"`
	// Specifies a comment for the listing.
	Comment  *string         `pulumi:"comment"`
	Manifest ListingManifest `pulumi:"manifest"`
	// Specifies the listing identifier (name). It must be unique within the organization, regardless of which Snowflake region the account is located in. Must start with an alphabetic character and cannot contain spaces or special characters except for underscores.
	Name *string `pulumi:"name"`
	// (Default: fallback to Snowflake default - uses special value that cannot be set in the configuration manually (`default`)) Determines if the listing should be published.
	Publish *string `pulumi:"publish"`
	// Specifies the identifier for the share to attach to the listing.
	Share *string `pulumi:"share"`
}

// The set of arguments for constructing a Listing resource.
type ListingArgs struct {
	// Specifies the application package attached to the listing.
	ApplicationPackage pulumi.StringPtrInput
	// Specifies a comment for the listing.
	Comment  pulumi.StringPtrInput
	Manifest ListingManifestInput
	// Specifies the listing identifier (name). It must be unique within the organization, regardless of which Snowflake region the account is located in. Must start with an alphabetic character and cannot contain spaces or special characters except for underscores.
	Name pulumi.StringPtrInput
	// (Default: fallback to Snowflake default - uses special value that cannot be set in the configuration manually (`default`)) Determines if the listing should be published.
	Publish pulumi.StringPtrInput
	// Specifies the identifier for the share to attach to the listing.
	Share pulumi.StringPtrInput
}

func (ListingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*listingArgs)(nil)).Elem()
}

type ListingInput interface {
	pulumi.Input

	ToListingOutput() ListingOutput
	ToListingOutputWithContext(ctx context.Context) ListingOutput
}

func (*Listing) ElementType() reflect.Type {
	return reflect.TypeOf((**Listing)(nil)).Elem()
}

func (i *Listing) ToListingOutput() ListingOutput {
	return i.ToListingOutputWithContext(context.Background())
}

func (i *Listing) ToListingOutputWithContext(ctx context.Context) ListingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ListingOutput)
}

// ListingArrayInput is an input type that accepts ListingArray and ListingArrayOutput values.
// You can construct a concrete instance of `ListingArrayInput` via:
//
//	ListingArray{ ListingArgs{...} }
type ListingArrayInput interface {
	pulumi.Input

	ToListingArrayOutput() ListingArrayOutput
	ToListingArrayOutputWithContext(context.Context) ListingArrayOutput
}

type ListingArray []ListingInput

func (ListingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Listing)(nil)).Elem()
}

func (i ListingArray) ToListingArrayOutput() ListingArrayOutput {
	return i.ToListingArrayOutputWithContext(context.Background())
}

func (i ListingArray) ToListingArrayOutputWithContext(ctx context.Context) ListingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ListingArrayOutput)
}

// ListingMapInput is an input type that accepts ListingMap and ListingMapOutput values.
// You can construct a concrete instance of `ListingMapInput` via:
//
//	ListingMap{ "key": ListingArgs{...} }
type ListingMapInput interface {
	pulumi.Input

	ToListingMapOutput() ListingMapOutput
	ToListingMapOutputWithContext(context.Context) ListingMapOutput
}

type ListingMap map[string]ListingInput

func (ListingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Listing)(nil)).Elem()
}

func (i ListingMap) ToListingMapOutput() ListingMapOutput {
	return i.ToListingMapOutputWithContext(context.Background())
}

func (i ListingMap) ToListingMapOutputWithContext(ctx context.Context) ListingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ListingMapOutput)
}

type ListingOutput struct{ *pulumi.OutputState }

func (ListingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Listing)(nil)).Elem()
}

func (o ListingOutput) ToListingOutput() ListingOutput {
	return o
}

func (o ListingOutput) ToListingOutputWithContext(ctx context.Context) ListingOutput {
	return o
}

// Specifies the application package attached to the listing.
func (o ListingOutput) ApplicationPackage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Listing) pulumi.StringPtrOutput { return v.ApplicationPackage }).(pulumi.StringPtrOutput)
}

// Specifies a comment for the listing.
func (o ListingOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Listing) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// Fully qualified name of the resource. For more information, see [object name resolution](https://docs.snowflake.com/en/sql-reference/name-resolution).
func (o ListingOutput) FullyQualifiedName() pulumi.StringOutput {
	return o.ApplyT(func(v *Listing) pulumi.StringOutput { return v.FullyQualifiedName }).(pulumi.StringOutput)
}

func (o ListingOutput) Manifest() ListingManifestOutput {
	return o.ApplyT(func(v *Listing) ListingManifestOutput { return v.Manifest }).(ListingManifestOutput)
}

// Specifies the listing identifier (name). It must be unique within the organization, regardless of which Snowflake region the account is located in. Must start with an alphabetic character and cannot contain spaces or special characters except for underscores.
func (o ListingOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Listing) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// (Default: fallback to Snowflake default - uses special value that cannot be set in the configuration manually (`default`)) Determines if the listing should be published.
func (o ListingOutput) Publish() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Listing) pulumi.StringPtrOutput { return v.Publish }).(pulumi.StringPtrOutput)
}

// Specifies the identifier for the share to attach to the listing.
func (o ListingOutput) Share() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Listing) pulumi.StringPtrOutput { return v.Share }).(pulumi.StringPtrOutput)
}

// Outputs the result of `SHOW LISTINGS` for the given listing.
func (o ListingOutput) ShowOutputs() ListingShowOutputArrayOutput {
	return o.ApplyT(func(v *Listing) ListingShowOutputArrayOutput { return v.ShowOutputs }).(ListingShowOutputArrayOutput)
}

type ListingArrayOutput struct{ *pulumi.OutputState }

func (ListingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Listing)(nil)).Elem()
}

func (o ListingArrayOutput) ToListingArrayOutput() ListingArrayOutput {
	return o
}

func (o ListingArrayOutput) ToListingArrayOutputWithContext(ctx context.Context) ListingArrayOutput {
	return o
}

func (o ListingArrayOutput) Index(i pulumi.IntInput) ListingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Listing {
		return vs[0].([]*Listing)[vs[1].(int)]
	}).(ListingOutput)
}

type ListingMapOutput struct{ *pulumi.OutputState }

func (ListingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Listing)(nil)).Elem()
}

func (o ListingMapOutput) ToListingMapOutput() ListingMapOutput {
	return o
}

func (o ListingMapOutput) ToListingMapOutputWithContext(ctx context.Context) ListingMapOutput {
	return o
}

func (o ListingMapOutput) MapIndex(k pulumi.StringInput) ListingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Listing {
		return vs[0].(map[string]*Listing)[vs[1].(string)]
	}).(ListingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ListingInput)(nil)).Elem(), &Listing{})
	pulumi.RegisterInputType(reflect.TypeOf((*ListingArrayInput)(nil)).Elem(), ListingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ListingMapInput)(nil)).Elem(), ListingMap{})
	pulumi.RegisterOutputType(ListingOutput{})
	pulumi.RegisterOutputType(ListingArrayOutput{})
	pulumi.RegisterOutputType(ListingMapOutput{})
}
