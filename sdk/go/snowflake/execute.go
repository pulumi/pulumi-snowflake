// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package snowflake

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-snowflake/sdk/v2/go/snowflake/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// !> **Warning** This is a dangerous resource that allows executing **ANY** SQL statement. It may destroy resources if used incorrectly. It may behave incorrectly combined with other resources. Use at your own risk.
//
// !> **Warning** Do not run `USE ROLE ...` or `USE WAREHOUSE ...` statements as they will cause the provider to produce inconsistent results. Use provider aliases with different roles instead.
//
// !> **Sensitive values** This resource's `execute`, `query`, `revert` and `queryResults` fields are not marked as sensitive in the provider. Ensure that no personal data, sensitive data, export-controlled data, or other regulated data is entered as metadata when using the provider. If you use one of these fields, they may be present in logs, so ensure that the provider logs are properly restricted. For more information, see Sensitive values limitations and [Metadata fields in Snowflake](https://docs.snowflake.com/en/sql-reference/metadata).
//
// > **Note** It can be theoretically used to manage resource that are not supported by the provider. This is risky and may break other resources if used incorrectly.
//
// > **Note** Use `query` parameter with caution. It will fetch **ALL** the results returned by the query provided. Try to limit the number of results by writing query with filters. Query failure does not stop resource creation; it simply results in `queryResults` being empty.
//
// > **Note**: Default timeout is set to 60 minutes for each Terraform operation.
//
// Resource allowing execution of ANY SQL statement.
//
// ## Import
//
// ```sh
// $ pulumi import snowflake:index/execute:Execute example '<random_uuid>'
// ```
type Execute struct {
	pulumi.CustomResourceState

	// SQL statement to execute. Forces recreation of resource on change.
	Execute pulumi.StringOutput `pulumi:"execute"`
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query pulumi.StringPtrOutput `pulumi:"query"`
	// List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.
	QueryResults pulumi.StringMapArrayOutput `pulumi:"queryResults"`
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert pulumi.StringOutput `pulumi:"revert"`
}

// NewExecute registers a new resource with the given unique name, arguments, and options.
func NewExecute(ctx *pulumi.Context,
	name string, args *ExecuteArgs, opts ...pulumi.ResourceOption) (*Execute, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Execute == nil {
		return nil, errors.New("invalid value for required argument 'Execute'")
	}
	if args.Revert == nil {
		return nil, errors.New("invalid value for required argument 'Revert'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Execute
	err := ctx.RegisterResource("snowflake:index/execute:Execute", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetExecute gets an existing Execute resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetExecute(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ExecuteState, opts ...pulumi.ResourceOption) (*Execute, error) {
	var resource Execute
	err := ctx.ReadResource("snowflake:index/execute:Execute", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Execute resources.
type executeState struct {
	// SQL statement to execute. Forces recreation of resource on change.
	Execute *string `pulumi:"execute"`
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query *string `pulumi:"query"`
	// List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.
	QueryResults []map[string]string `pulumi:"queryResults"`
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert *string `pulumi:"revert"`
}

type ExecuteState struct {
	// SQL statement to execute. Forces recreation of resource on change.
	Execute pulumi.StringPtrInput
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query pulumi.StringPtrInput
	// List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.
	QueryResults pulumi.StringMapArrayInput
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert pulumi.StringPtrInput
}

func (ExecuteState) ElementType() reflect.Type {
	return reflect.TypeOf((*executeState)(nil)).Elem()
}

type executeArgs struct {
	// SQL statement to execute. Forces recreation of resource on change.
	Execute string `pulumi:"execute"`
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query *string `pulumi:"query"`
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert string `pulumi:"revert"`
}

// The set of arguments for constructing a Execute resource.
type ExecuteArgs struct {
	// SQL statement to execute. Forces recreation of resource on change.
	Execute pulumi.StringInput
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query pulumi.StringPtrInput
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert pulumi.StringInput
}

func (ExecuteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*executeArgs)(nil)).Elem()
}

type ExecuteInput interface {
	pulumi.Input

	ToExecuteOutput() ExecuteOutput
	ToExecuteOutputWithContext(ctx context.Context) ExecuteOutput
}

func (*Execute) ElementType() reflect.Type {
	return reflect.TypeOf((**Execute)(nil)).Elem()
}

func (i *Execute) ToExecuteOutput() ExecuteOutput {
	return i.ToExecuteOutputWithContext(context.Background())
}

func (i *Execute) ToExecuteOutputWithContext(ctx context.Context) ExecuteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecuteOutput)
}

// ExecuteArrayInput is an input type that accepts ExecuteArray and ExecuteArrayOutput values.
// You can construct a concrete instance of `ExecuteArrayInput` via:
//
//	ExecuteArray{ ExecuteArgs{...} }
type ExecuteArrayInput interface {
	pulumi.Input

	ToExecuteArrayOutput() ExecuteArrayOutput
	ToExecuteArrayOutputWithContext(context.Context) ExecuteArrayOutput
}

type ExecuteArray []ExecuteInput

func (ExecuteArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Execute)(nil)).Elem()
}

func (i ExecuteArray) ToExecuteArrayOutput() ExecuteArrayOutput {
	return i.ToExecuteArrayOutputWithContext(context.Background())
}

func (i ExecuteArray) ToExecuteArrayOutputWithContext(ctx context.Context) ExecuteArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecuteArrayOutput)
}

// ExecuteMapInput is an input type that accepts ExecuteMap and ExecuteMapOutput values.
// You can construct a concrete instance of `ExecuteMapInput` via:
//
//	ExecuteMap{ "key": ExecuteArgs{...} }
type ExecuteMapInput interface {
	pulumi.Input

	ToExecuteMapOutput() ExecuteMapOutput
	ToExecuteMapOutputWithContext(context.Context) ExecuteMapOutput
}

type ExecuteMap map[string]ExecuteInput

func (ExecuteMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Execute)(nil)).Elem()
}

func (i ExecuteMap) ToExecuteMapOutput() ExecuteMapOutput {
	return i.ToExecuteMapOutputWithContext(context.Background())
}

func (i ExecuteMap) ToExecuteMapOutputWithContext(ctx context.Context) ExecuteMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecuteMapOutput)
}

type ExecuteOutput struct{ *pulumi.OutputState }

func (ExecuteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Execute)(nil)).Elem()
}

func (o ExecuteOutput) ToExecuteOutput() ExecuteOutput {
	return o
}

func (o ExecuteOutput) ToExecuteOutputWithContext(ctx context.Context) ExecuteOutput {
	return o
}

// SQL statement to execute. Forces recreation of resource on change.
func (o ExecuteOutput) Execute() pulumi.StringOutput {
	return o.ApplyT(func(v *Execute) pulumi.StringOutput { return v.Execute }).(pulumi.StringOutput)
}

// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
func (o ExecuteOutput) Query() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Execute) pulumi.StringPtrOutput { return v.Query }).(pulumi.StringPtrOutput)
}

// List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.
func (o ExecuteOutput) QueryResults() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *Execute) pulumi.StringMapArrayOutput { return v.QueryResults }).(pulumi.StringMapArrayOutput)
}

// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
func (o ExecuteOutput) Revert() pulumi.StringOutput {
	return o.ApplyT(func(v *Execute) pulumi.StringOutput { return v.Revert }).(pulumi.StringOutput)
}

type ExecuteArrayOutput struct{ *pulumi.OutputState }

func (ExecuteArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Execute)(nil)).Elem()
}

func (o ExecuteArrayOutput) ToExecuteArrayOutput() ExecuteArrayOutput {
	return o
}

func (o ExecuteArrayOutput) ToExecuteArrayOutputWithContext(ctx context.Context) ExecuteArrayOutput {
	return o
}

func (o ExecuteArrayOutput) Index(i pulumi.IntInput) ExecuteOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Execute {
		return vs[0].([]*Execute)[vs[1].(int)]
	}).(ExecuteOutput)
}

type ExecuteMapOutput struct{ *pulumi.OutputState }

func (ExecuteMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Execute)(nil)).Elem()
}

func (o ExecuteMapOutput) ToExecuteMapOutput() ExecuteMapOutput {
	return o
}

func (o ExecuteMapOutput) ToExecuteMapOutputWithContext(ctx context.Context) ExecuteMapOutput {
	return o
}

func (o ExecuteMapOutput) MapIndex(k pulumi.StringInput) ExecuteOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Execute {
		return vs[0].(map[string]*Execute)[vs[1].(string)]
	}).(ExecuteOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ExecuteInput)(nil)).Elem(), &Execute{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExecuteArrayInput)(nil)).Elem(), ExecuteArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExecuteMapInput)(nil)).Elem(), ExecuteMap{})
	pulumi.RegisterOutputType(ExecuteOutput{})
	pulumi.RegisterOutputType(ExecuteArrayOutput{})
	pulumi.RegisterOutputType(ExecuteMapOutput{})
}
