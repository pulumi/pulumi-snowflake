// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package snowflake

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// ```sh
// $ pulumi import snowflake:index/execute:Execute example '<random_uuid>'
// ```
type Execute struct {
	pulumi.CustomResourceState

	// SQL statement to execute. Forces recreation of resource on change.
	Execute pulumi.StringOutput `pulumi:"execute"`
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query pulumi.StringPtrOutput `pulumi:"query"`
	// List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.
	QueryResults pulumi.StringMapArrayOutput `pulumi:"queryResults"`
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert pulumi.StringOutput `pulumi:"revert"`
}

// NewExecute registers a new resource with the given unique name, arguments, and options.
func NewExecute(ctx *pulumi.Context,
	name string, args *ExecuteArgs, opts ...pulumi.ResourceOption) (*Execute, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Execute == nil {
		return nil, errors.New("invalid value for required argument 'Execute'")
	}
	if args.Revert == nil {
		return nil, errors.New("invalid value for required argument 'Revert'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Execute
	err := ctx.RegisterResource("snowflake:index/execute:Execute", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetExecute gets an existing Execute resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetExecute(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ExecuteState, opts ...pulumi.ResourceOption) (*Execute, error) {
	var resource Execute
	err := ctx.ReadResource("snowflake:index/execute:Execute", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Execute resources.
type executeState struct {
	// SQL statement to execute. Forces recreation of resource on change.
	Execute *string `pulumi:"execute"`
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query *string `pulumi:"query"`
	// List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.
	QueryResults []map[string]string `pulumi:"queryResults"`
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert *string `pulumi:"revert"`
}

type ExecuteState struct {
	// SQL statement to execute. Forces recreation of resource on change.
	Execute pulumi.StringPtrInput
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query pulumi.StringPtrInput
	// List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.
	QueryResults pulumi.StringMapArrayInput
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert pulumi.StringPtrInput
}

func (ExecuteState) ElementType() reflect.Type {
	return reflect.TypeOf((*executeState)(nil)).Elem()
}

type executeArgs struct {
	// SQL statement to execute. Forces recreation of resource on change.
	Execute string `pulumi:"execute"`
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query *string `pulumi:"query"`
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert string `pulumi:"revert"`
}

// The set of arguments for constructing a Execute resource.
type ExecuteArgs struct {
	// SQL statement to execute. Forces recreation of resource on change.
	Execute pulumi.StringInput
	// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
	Query pulumi.StringPtrInput
	// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
	Revert pulumi.StringInput
}

func (ExecuteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*executeArgs)(nil)).Elem()
}

type ExecuteInput interface {
	pulumi.Input

	ToExecuteOutput() ExecuteOutput
	ToExecuteOutputWithContext(ctx context.Context) ExecuteOutput
}

func (*Execute) ElementType() reflect.Type {
	return reflect.TypeOf((**Execute)(nil)).Elem()
}

func (i *Execute) ToExecuteOutput() ExecuteOutput {
	return i.ToExecuteOutputWithContext(context.Background())
}

func (i *Execute) ToExecuteOutputWithContext(ctx context.Context) ExecuteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecuteOutput)
}

// ExecuteArrayInput is an input type that accepts ExecuteArray and ExecuteArrayOutput values.
// You can construct a concrete instance of `ExecuteArrayInput` via:
//
//	ExecuteArray{ ExecuteArgs{...} }
type ExecuteArrayInput interface {
	pulumi.Input

	ToExecuteArrayOutput() ExecuteArrayOutput
	ToExecuteArrayOutputWithContext(context.Context) ExecuteArrayOutput
}

type ExecuteArray []ExecuteInput

func (ExecuteArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Execute)(nil)).Elem()
}

func (i ExecuteArray) ToExecuteArrayOutput() ExecuteArrayOutput {
	return i.ToExecuteArrayOutputWithContext(context.Background())
}

func (i ExecuteArray) ToExecuteArrayOutputWithContext(ctx context.Context) ExecuteArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecuteArrayOutput)
}

// ExecuteMapInput is an input type that accepts ExecuteMap and ExecuteMapOutput values.
// You can construct a concrete instance of `ExecuteMapInput` via:
//
//	ExecuteMap{ "key": ExecuteArgs{...} }
type ExecuteMapInput interface {
	pulumi.Input

	ToExecuteMapOutput() ExecuteMapOutput
	ToExecuteMapOutputWithContext(context.Context) ExecuteMapOutput
}

type ExecuteMap map[string]ExecuteInput

func (ExecuteMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Execute)(nil)).Elem()
}

func (i ExecuteMap) ToExecuteMapOutput() ExecuteMapOutput {
	return i.ToExecuteMapOutputWithContext(context.Background())
}

func (i ExecuteMap) ToExecuteMapOutputWithContext(ctx context.Context) ExecuteMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecuteMapOutput)
}

type ExecuteOutput struct{ *pulumi.OutputState }

func (ExecuteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Execute)(nil)).Elem()
}

func (o ExecuteOutput) ToExecuteOutput() ExecuteOutput {
	return o
}

func (o ExecuteOutput) ToExecuteOutputWithContext(ctx context.Context) ExecuteOutput {
	return o
}

// SQL statement to execute. Forces recreation of resource on change.
func (o ExecuteOutput) Execute() pulumi.StringOutput {
	return o.ApplyT(func(v *Execute) pulumi.StringOutput { return v.Execute }).(pulumi.StringOutput)
}

// Optional SQL statement to do a read. Invoked on every resource refresh and every time it is changed.
func (o ExecuteOutput) Query() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Execute) pulumi.StringPtrOutput { return v.Query }).(pulumi.StringPtrOutput)
}

// List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.
func (o ExecuteOutput) QueryResults() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *Execute) pulumi.StringMapArrayOutput { return v.QueryResults }).(pulumi.StringMapArrayOutput)
}

// SQL statement to revert the execute statement. Invoked when resource is being destroyed.
func (o ExecuteOutput) Revert() pulumi.StringOutput {
	return o.ApplyT(func(v *Execute) pulumi.StringOutput { return v.Revert }).(pulumi.StringOutput)
}

type ExecuteArrayOutput struct{ *pulumi.OutputState }

func (ExecuteArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Execute)(nil)).Elem()
}

func (o ExecuteArrayOutput) ToExecuteArrayOutput() ExecuteArrayOutput {
	return o
}

func (o ExecuteArrayOutput) ToExecuteArrayOutputWithContext(ctx context.Context) ExecuteArrayOutput {
	return o
}

func (o ExecuteArrayOutput) Index(i pulumi.IntInput) ExecuteOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Execute {
		return vs[0].([]*Execute)[vs[1].(int)]
	}).(ExecuteOutput)
}

type ExecuteMapOutput struct{ *pulumi.OutputState }

func (ExecuteMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Execute)(nil)).Elem()
}

func (o ExecuteMapOutput) ToExecuteMapOutput() ExecuteMapOutput {
	return o
}

func (o ExecuteMapOutput) ToExecuteMapOutputWithContext(ctx context.Context) ExecuteMapOutput {
	return o
}

func (o ExecuteMapOutput) MapIndex(k pulumi.StringInput) ExecuteOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Execute {
		return vs[0].(map[string]*Execute)[vs[1].(string)]
	}).(ExecuteOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ExecuteInput)(nil)).Elem(), &Execute{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExecuteArrayInput)(nil)).Elem(), ExecuteArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExecuteMapInput)(nil)).Elem(), ExecuteMap{})
	pulumi.RegisterOutputType(ExecuteOutput{})
	pulumi.RegisterOutputType(ExecuteArrayOutput{})
	pulumi.RegisterOutputType(ExecuteMapOutput{})
}
