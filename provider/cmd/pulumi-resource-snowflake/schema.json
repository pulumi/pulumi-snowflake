{
    "name": "snowflake",
    "description": "A Pulumi package for creating and managing snowflake cloud resources.",
    "keywords": [
        "pulumi",
        "snowflake"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`snowflake` Terraform Provider](https://github.com/Snowflake-Labs/terraform-provider-snowflake).",
    "repository": "https://github.com/pulumi/pulumi-snowflake",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "account": {
                "type": "string",
                "description": "The name of the Snowflake account. Can also come from the `SNOWFLAKE_ACCOUNT` environment variable.\n"
            },
            "browserAuth": {
                "type": "boolean",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_USE_BROWSER_AUTH` environment variable.\n"
            },
            "host": {
                "type": "string",
                "description": "Supports passing in a custom host value to the snowflake go driver for use with privatelink.\n"
            },
            "oauthAccessToken": {
                "type": "string",
                "description": "Token for use with OAuth. Generating the token is left to other tools. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_refresh_token` or `password`. Can be sourced from `SNOWFLAKE_OAUTH_ACCESS_TOKEN` environment\nvariable.\n"
            },
            "oauthClientId": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_CLIENT_ID` environment variable.\n"
            },
            "oauthClientSecret": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_CLIENT_SECRET` environment variable.\n"
            },
            "oauthEndpoint": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_ENDPOINT` environment variable.\n"
            },
            "oauthRedirectUrl": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_REDIRECT_URL` environment variable.\n"
            },
            "oauthRefreshToken": {
                "type": "string",
                "description": "Token for use with OAuth. Setup and generation of the token is left to other tools. Should be used in conjunction with\n`oauth_client_id`, `oauth_client_secret`, `oauth_endpoint`, `oauth_redirect_url`. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_access_token` or `password`. Can be sourced from `SNOWFLAKE_OAUTH_REFRESH_TOKEN` environment\nvariable.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for username+password auth. Cannot be used with `browser_auth` or `private_key_path`. Can be source from\n`SNOWFLAKE_PASSWORD` environment variable.\n"
            },
            "privateKey": {
                "type": "string",
                "description": "Private Key for username+private-key auth. Cannot be used with `browser_auth` or `password`. Can be source from\n`SNOWFLAKE_PRIVATE_KEY` environment variable.\n"
            },
            "privateKeyPassphrase": {
                "type": "string",
                "description": "Supports the encryption ciphers aes-128-cbc, aes-128-gcm, aes-192-cbc, aes-192-gcm, aes-256-cbc, aes-256-gcm, and\ndes-ede3-cbc\n"
            },
            "privateKeyPath": {
                "type": "string",
                "description": "Path to a private key for using keypair authentication. Cannot be used with `browser_auth`, `oauth_access_token` or\n`password`. Can be source from `SNOWFLAKE_PRIVATE_KEY_PATH` environment variable.\n"
            },
            "region": {
                "type": "string",
                "description": "[Snowflake region](https://docs.snowflake.com/en/user-guide/intro-regions.html) to use. Can be source from the\n`SNOWFLAKE_REGION` environment variable.\n"
            },
            "role": {
                "type": "string",
                "description": "Snowflake role to use for operations. If left unset, default role for user will be used. Can come from the\n`SNOWFLAKE_ROLE` environment variable.\n"
            },
            "username": {
                "type": "string",
                "description": "Username for username+password authentication. Can come from the `SNOWFLAKE_USER` environment variable.\n"
            },
            "warehouse": {
                "type": "string",
                "description": "Sets the default warehouse. Optional. Can be sourced from SNOWFLAKE_WAREHOUSE enviornment variable.\n"
            }
        },
        "defaults": [
            "account",
            "region",
            "username"
        ]
    },
    "types": {
        "snowflake:index/DatabaseReplicationConfiguration:DatabaseReplicationConfiguration": {
            "properties": {
                "accounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ignoreEditionCheck": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accounts"
            ]
        },
        "snowflake:index/DatabaseTag:DatabaseTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/ExternalFunctionArg:ExternalFunctionArg": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/ExternalFunctionHeader:ExternalFunctionHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/ExternalTableColumn:ExternalTableColumn": {
            "properties": {
                "as": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "as",
                "name",
                "type"
            ]
        },
        "snowflake:index/ExternalTableTag:ExternalTableTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/FunctionArgument:FunctionArgument": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/FunctionGrantArgument:FunctionGrantArgument": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/MaterializedViewTag:MaterializedViewTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/ProcedureArgument:ProcedureArgument": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/ProcedureGrantArgument:ProcedureGrantArgument": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/RoleTag:RoleTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/SchemaTag:SchemaTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/StageTag:StageTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/TableColumn:TableColumn": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "default": {
                    "$ref": "#/types/snowflake:index/TableColumnDefault:TableColumnDefault",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identity": {
                    "$ref": "#/types/snowflake:index/TableColumnIdentity:TableColumnIdentity",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nullable": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/TableColumnDefault:TableColumnDefault": {
            "properties": {
                "constant": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expression": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sequence": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "snowflake:index/TableColumnIdentity:TableColumnIdentity": {
            "properties": {
                "startNum": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stepNum": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "snowflake:index/TablePrimaryKey:TablePrimaryKey": {
            "properties": {
                "keys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "keys"
            ]
        },
        "snowflake:index/TableTag:TableTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/UserTag:UserTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/ViewTag:ViewTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/WarehouseTag:WarehouseTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/getDatabasesDatabase:getDatabasesDatabase": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdOn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isCurrent": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isDefault": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "options": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "origin": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "owner": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicationConfigurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/getDatabasesDatabaseReplicationConfiguration:getDatabasesDatabaseReplicationConfiguration"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionTime": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "createdOn",
                "isCurrent",
                "isDefault",
                "name",
                "options",
                "origin",
                "owner",
                "replicationConfigurations",
                "retentionTime"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getDatabasesDatabaseReplicationConfiguration:getDatabasesDatabaseReplicationConfiguration": {
            "properties": {
                "accounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ignoreEditionCheck": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accounts",
                "ignoreEditionCheck"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getExternalFunctionsExternalFunction:getExternalFunctionsExternalFunction": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "language": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "language",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getExternalTablesExternalTable:getExternalTablesExternalTable": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getFileFormatsFileFormat:getFileFormatsFileFormat": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "formatType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "formatType",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getFunctionsFunction:getFunctionsFunction": {
            "properties": {
                "argumentTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "returnType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "argumentTypes",
                "comment",
                "database",
                "name",
                "returnType",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getMaskingPoliciesMaskingPolicy:getMaskingPoliciesMaskingPolicy": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "kind": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "kind",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getMaterializedViewsMaterializedView:getMaterializedViewsMaterializedView": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getPipesPipe:getPipesPipe": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "integration": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "integration",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getProceduresProcedure:getProceduresProcedure": {
            "properties": {
                "argumentTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "returnType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "argumentTypes",
                "comment",
                "database",
                "name",
                "returnType",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getResourceMonitorsResourceMonitor:getResourceMonitorsResourceMonitor": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "creditQuota": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequency": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "creditQuota",
                "frequency",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getRowAccessPoliciesRowAccessPolicy:getRowAccessPoliciesRowAccessPolicy": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getSchemasSchema:getSchemasSchema": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getSequencesSequence:getSequencesSequence": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getStagesStage:getStagesStage": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storageIntegration": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema",
                "storageIntegration"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getStorageIntegrationsStorageIntegration:getStorageIntegrationsStorageIntegration": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "enabled",
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getStreamsStream:getStreamsStream": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "table": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema",
                "table"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getTablesTable:getTablesTable": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getTasksTask:getTasksTask": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "warehouse": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema",
                "warehouse"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getUsersUser:getUsersUser": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultNamespace": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultRole": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultSecondaryRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultWarehouse": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "displayName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "email": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hasRsaPublicKey": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "loginName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "defaultNamespace",
                "defaultRole",
                "defaultSecondaryRoles",
                "defaultWarehouse",
                "disabled",
                "displayName",
                "email",
                "firstName",
                "hasRsaPublicKey",
                "lastName",
                "loginName",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getViewsView:getViewsView": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "schema": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getWarehousesWarehouse:getWarehousesWarehouse": {
            "properties": {
                "comment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "scalingPolicy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "size": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "state": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "name",
                "scalingPolicy",
                "size",
                "state",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the snowflake package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "account": {
                "type": "string",
                "description": "The name of the Snowflake account. Can also come from the `SNOWFLAKE_ACCOUNT` environment variable.\n"
            },
            "browserAuth": {
                "type": "boolean",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_USE_BROWSER_AUTH` environment variable.\n"
            },
            "host": {
                "type": "string",
                "description": "Supports passing in a custom host value to the snowflake go driver for use with privatelink.\n"
            },
            "oauthAccessToken": {
                "type": "string",
                "description": "Token for use with OAuth. Generating the token is left to other tools. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_refresh_token` or `password`. Can be sourced from `SNOWFLAKE_OAUTH_ACCESS_TOKEN` environment\nvariable.\n"
            },
            "oauthClientId": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_CLIENT_ID` environment variable.\n"
            },
            "oauthClientSecret": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_CLIENT_SECRET` environment variable.\n"
            },
            "oauthEndpoint": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_ENDPOINT` environment variable.\n"
            },
            "oauthRedirectUrl": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_REDIRECT_URL` environment variable.\n"
            },
            "oauthRefreshToken": {
                "type": "string",
                "description": "Token for use with OAuth. Setup and generation of the token is left to other tools. Should be used in conjunction with\n`oauth_client_id`, `oauth_client_secret`, `oauth_endpoint`, `oauth_redirect_url`. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_access_token` or `password`. Can be sourced from `SNOWFLAKE_OAUTH_REFRESH_TOKEN` environment\nvariable.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for username+password auth. Cannot be used with `browser_auth` or `private_key_path`. Can be source from\n`SNOWFLAKE_PASSWORD` environment variable.\n"
            },
            "privateKey": {
                "type": "string",
                "description": "Private Key for username+private-key auth. Cannot be used with `browser_auth` or `password`. Can be source from\n`SNOWFLAKE_PRIVATE_KEY` environment variable.\n"
            },
            "privateKeyPassphrase": {
                "type": "string",
                "description": "Supports the encryption ciphers aes-128-cbc, aes-128-gcm, aes-192-cbc, aes-192-gcm, aes-256-cbc, aes-256-gcm, and\ndes-ede3-cbc\n"
            },
            "privateKeyPath": {
                "type": "string",
                "description": "Path to a private key for using keypair authentication. Cannot be used with `browser_auth`, `oauth_access_token` or\n`password`. Can be source from `SNOWFLAKE_PRIVATE_KEY_PATH` environment variable.\n"
            },
            "region": {
                "type": "string",
                "description": "[Snowflake region](https://docs.snowflake.com/en/user-guide/intro-regions.html) to use. Can be source from the\n`SNOWFLAKE_REGION` environment variable.\n"
            },
            "role": {
                "type": "string",
                "description": "Snowflake role to use for operations. If left unset, default role for user will be used. Can come from the\n`SNOWFLAKE_ROLE` environment variable.\n"
            },
            "username": {
                "type": "string",
                "description": "Username for username+password authentication. Can come from the `SNOWFLAKE_USER` environment variable.\n"
            },
            "warehouse": {
                "type": "string",
                "description": "Sets the default warehouse. Optional. Can be sourced from SNOWFLAKE_WAREHOUSE enviornment variable.\n"
            }
        },
        "required": [
            "account",
            "region",
            "username"
        ],
        "inputProperties": {
            "account": {
                "type": "string",
                "description": "The name of the Snowflake account. Can also come from the `SNOWFLAKE_ACCOUNT` environment variable.\n"
            },
            "browserAuth": {
                "type": "boolean",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_USE_BROWSER_AUTH` environment variable.\n"
            },
            "host": {
                "type": "string",
                "description": "Supports passing in a custom host value to the snowflake go driver for use with privatelink.\n"
            },
            "oauthAccessToken": {
                "type": "string",
                "description": "Token for use with OAuth. Generating the token is left to other tools. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_refresh_token` or `password`. Can be sourced from `SNOWFLAKE_OAUTH_ACCESS_TOKEN` environment\nvariable.\n"
            },
            "oauthClientId": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_CLIENT_ID` environment variable.\n"
            },
            "oauthClientSecret": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_CLIENT_SECRET` environment variable.\n"
            },
            "oauthEndpoint": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_ENDPOINT` environment variable.\n"
            },
            "oauthRedirectUrl": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can be sourced from `SNOWFLAKE_OAUTH_REDIRECT_URL` environment variable.\n"
            },
            "oauthRefreshToken": {
                "type": "string",
                "description": "Token for use with OAuth. Setup and generation of the token is left to other tools. Should be used in conjunction with\n`oauth_client_id`, `oauth_client_secret`, `oauth_endpoint`, `oauth_redirect_url`. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_access_token` or `password`. Can be sourced from `SNOWFLAKE_OAUTH_REFRESH_TOKEN` environment\nvariable.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for username+password auth. Cannot be used with `browser_auth` or `private_key_path`. Can be source from\n`SNOWFLAKE_PASSWORD` environment variable.\n"
            },
            "privateKey": {
                "type": "string",
                "description": "Private Key for username+private-key auth. Cannot be used with `browser_auth` or `password`. Can be source from\n`SNOWFLAKE_PRIVATE_KEY` environment variable.\n"
            },
            "privateKeyPassphrase": {
                "type": "string",
                "description": "Supports the encryption ciphers aes-128-cbc, aes-128-gcm, aes-192-cbc, aes-192-gcm, aes-256-cbc, aes-256-gcm, and\ndes-ede3-cbc\n"
            },
            "privateKeyPath": {
                "type": "string",
                "description": "Path to a private key for using keypair authentication. Cannot be used with `browser_auth`, `oauth_access_token` or\n`password`. Can be source from `SNOWFLAKE_PRIVATE_KEY_PATH` environment variable.\n"
            },
            "region": {
                "type": "string",
                "description": "[Snowflake region](https://docs.snowflake.com/en/user-guide/intro-regions.html) to use. Can be source from the\n`SNOWFLAKE_REGION` environment variable.\n"
            },
            "role": {
                "type": "string",
                "description": "Snowflake role to use for operations. If left unset, default role for user will be used. Can come from the\n`SNOWFLAKE_ROLE` environment variable.\n"
            },
            "username": {
                "type": "string",
                "description": "Username for username+password authentication. Can come from the `SNOWFLAKE_USER` environment variable.\n"
            },
            "warehouse": {
                "type": "string",
                "description": "Sets the default warehouse. Optional. Can be sourced from SNOWFLAKE_WAREHOUSE enviornment variable.\n"
            }
        },
        "requiredInputs": [
            "account",
            "region",
            "username"
        ]
    },
    "resources": {
        "snowflake:index/accountGrant:AccountGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.AccountGrant(\"grant\", {\n    privilege: \"CREATE ROLE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.AccountGrant(\"grant\",\n    privilege=\"CREATE ROLE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.AccountGrant(\"grant\", new Snowflake.AccountGrantArgs\n        {\n            Privilege = \"CREATE ROLE\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewAccountGrant(ctx, \"grant\", \u0026snowflake.AccountGrantArgs{\n\t\t\tPrivilege: pulumi.String(\"CREATE ROLE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new AccountGrant(\"grant\", AccountGrantArgs.builder()        \n            .privilege(\"CREATE ROLE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:AccountGrant\n    properties:\n      privilege: CREATE ROLE\n      roles:\n        - role1\n        - role2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is account name | | | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/accountGrant:AccountGrant example 'accountName|||USAGE|true'\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the account.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the account.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccountGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the account.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/apiIntegration:ApiIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst apiIntegration = new snowflake.ApiIntegration(\"api_integration\", {\n    apiAllowedPrefixes: [\"https://123456.execute-api.us-west-2.amazonaws.com/prod/\"],\n    apiAwsRoleArn: \"arn:aws:iam::000000000001:/role/test\",\n    apiProvider: \"aws_api_gateway\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\napi_integration = snowflake.ApiIntegration(\"apiIntegration\",\n    api_allowed_prefixes=[\"https://123456.execute-api.us-west-2.amazonaws.com/prod/\"],\n    api_aws_role_arn=\"arn:aws:iam::000000000001:/role/test\",\n    api_provider=\"aws_api_gateway\",\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var apiIntegration = new Snowflake.ApiIntegration(\"apiIntegration\", new Snowflake.ApiIntegrationArgs\n        {\n            ApiAllowedPrefixes = \n            {\n                \"https://123456.execute-api.us-west-2.amazonaws.com/prod/\",\n            },\n            ApiAwsRoleArn = \"arn:aws:iam::000000000001:/role/test\",\n            ApiProvider = \"aws_api_gateway\",\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewApiIntegration(ctx, \"apiIntegration\", \u0026snowflake.ApiIntegrationArgs{\n\t\t\tApiAllowedPrefixes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://123456.execute-api.us-west-2.amazonaws.com/prod/\"),\n\t\t\t},\n\t\t\tApiAwsRoleArn: pulumi.String(\"arn:aws:iam::000000000001:/role/test\"),\n\t\t\tApiProvider:   pulumi.String(\"aws_api_gateway\"),\n\t\t\tEnabled:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var apiIntegration = new ApiIntegration(\"apiIntegration\", ApiIntegrationArgs.builder()        \n            .apiAllowedPrefixes(\"https://123456.execute-api.us-west-2.amazonaws.com/prod/\")\n            .apiAwsRoleArn(\"arn:aws:iam::000000000001:/role/test\")\n            .apiProvider(\"aws_api_gateway\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  apiIntegration:\n    type: snowflake:ApiIntegration\n    properties:\n      apiAllowedPrefixes:\n        - https://123456.execute-api.us-west-2.amazonaws.com/prod/\n      apiAwsRoleArn: arn:aws:iam::000000000001:/role/test\n      apiProvider: aws_api_gateway\n      enabled: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/apiIntegration:ApiIntegration example name\n```\n\n ",
            "properties": {
                "apiAllowedPrefixes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly limits external functions that use the integration to reference one or more HTTPS proxy service endpoints and\nresources within those proxies.\n"
                },
                "apiAwsExternalId": {
                    "type": "string",
                    "description": "The external ID that Snowflake will use when assuming the AWS role.\n"
                },
                "apiAwsIamUserArn": {
                    "type": "string",
                    "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                },
                "apiAwsRoleArn": {
                    "type": "string",
                    "description": "ARN of a cloud platform role.\n"
                },
                "apiBlockedPrefixes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Lists the endpoints and resources in the HTTPS proxy service that are not allowed to be called from Snowflake.\n"
                },
                "apiProvider": {
                    "type": "string",
                    "description": "Specifies the HTTPS proxy service type.\n"
                },
                "azureAdApplicationId": {
                    "type": "string",
                    "description": "The 'Application (client) id' of the Azure AD app for your remote service.\n"
                },
                "azureConsentUrl": {
                    "type": "string"
                },
                "azureMultiTenantAppName": {
                    "type": "string"
                },
                "azureTenantId": {
                    "type": "string",
                    "description": "Specifies the ID for your Office 365 tenant that all Azure API Management instances belong to.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the API integration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this API integration is enabled or disabled. If the API integration is disabled, any external function\nthat relies on it will not work.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the API integration. This name follows the rules for Object Identifiers. The name should be unique\namong api integrations in your account.\n"
                }
            },
            "required": [
                "apiAllowedPrefixes",
                "apiAwsExternalId",
                "apiAwsIamUserArn",
                "apiProvider",
                "azureConsentUrl",
                "azureMultiTenantAppName",
                "createdOn",
                "name"
            ],
            "inputProperties": {
                "apiAllowedPrefixes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly limits external functions that use the integration to reference one or more HTTPS proxy service endpoints and\nresources within those proxies.\n"
                },
                "apiAwsRoleArn": {
                    "type": "string",
                    "description": "ARN of a cloud platform role.\n"
                },
                "apiBlockedPrefixes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Lists the endpoints and resources in the HTTPS proxy service that are not allowed to be called from Snowflake.\n"
                },
                "apiProvider": {
                    "type": "string",
                    "description": "Specifies the HTTPS proxy service type.\n"
                },
                "azureAdApplicationId": {
                    "type": "string",
                    "description": "The 'Application (client) id' of the Azure AD app for your remote service.\n"
                },
                "azureTenantId": {
                    "type": "string",
                    "description": "Specifies the ID for your Office 365 tenant that all Azure API Management instances belong to.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this API integration is enabled or disabled. If the API integration is disabled, any external function\nthat relies on it will not work.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the API integration. This name follows the rules for Object Identifiers. The name should be unique\namong api integrations in your account.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "apiAllowedPrefixes",
                "apiProvider"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiIntegration resources.\n",
                "properties": {
                    "apiAllowedPrefixes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Explicitly limits external functions that use the integration to reference one or more HTTPS proxy service endpoints and\nresources within those proxies.\n"
                    },
                    "apiAwsExternalId": {
                        "type": "string",
                        "description": "The external ID that Snowflake will use when assuming the AWS role.\n"
                    },
                    "apiAwsIamUserArn": {
                        "type": "string",
                        "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                    },
                    "apiAwsRoleArn": {
                        "type": "string",
                        "description": "ARN of a cloud platform role.\n"
                    },
                    "apiBlockedPrefixes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Lists the endpoints and resources in the HTTPS proxy service that are not allowed to be called from Snowflake.\n"
                    },
                    "apiProvider": {
                        "type": "string",
                        "description": "Specifies the HTTPS proxy service type.\n"
                    },
                    "azureAdApplicationId": {
                        "type": "string",
                        "description": "The 'Application (client) id' of the Azure AD app for your remote service.\n"
                    },
                    "azureConsentUrl": {
                        "type": "string"
                    },
                    "azureMultiTenantAppName": {
                        "type": "string"
                    },
                    "azureTenantId": {
                        "type": "string",
                        "description": "Specifies the ID for your Office 365 tenant that all Azure API Management instances belong to.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the API integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether this API integration is enabled or disabled. If the API integration is disabled, any external function\nthat relies on it will not work.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the API integration. This name follows the rules for Object Identifiers. The name should be unique\namong api integrations in your account.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/database:Database": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst test = new snowflake.Database(\"test\", {\n    comment: \"test comment\",\n    dataRetentionTimeInDays: 3,\n});\nconst test2 = new snowflake.Database(\"test2\", {\n    comment: \"test comment 2\",\n    replicationConfiguration: {\n        accounts: [\n            \"test_account1\",\n            \"test_account_2\",\n        ],\n        ignoreEditionCheck: true,\n    },\n});\nconst test3 = new snowflake.Database(\"test3\", {\n    comment: \"test comment\",\n    dataRetentionTimeInDays: 3,\n    fromReplica: \"org1\\\".\\\"account1\\\".\\\"primary_db_name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntest = snowflake.Database(\"test\",\n    comment=\"test comment\",\n    data_retention_time_in_days=3)\ntest2 = snowflake.Database(\"test2\",\n    comment=\"test comment 2\",\n    replication_configuration=snowflake.DatabaseReplicationConfigurationArgs(\n        accounts=[\n            \"test_account1\",\n            \"test_account_2\",\n        ],\n        ignore_edition_check=True,\n    ))\ntest3 = snowflake.Database(\"test3\",\n    comment=\"test comment\",\n    data_retention_time_in_days=3,\n    from_replica=\"org1\\\".\\\"account1\\\".\\\"primary_db_name\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Snowflake.Database(\"test\", new Snowflake.DatabaseArgs\n        {\n            Comment = \"test comment\",\n            DataRetentionTimeInDays = 3,\n        });\n        var test2 = new Snowflake.Database(\"test2\", new Snowflake.DatabaseArgs\n        {\n            Comment = \"test comment 2\",\n            ReplicationConfiguration = new Snowflake.Inputs.DatabaseReplicationConfigurationArgs\n            {\n                Accounts = \n                {\n                    \"test_account1\",\n                    \"test_account_2\",\n                },\n                IgnoreEditionCheck = true,\n            },\n        });\n        var test3 = new Snowflake.Database(\"test3\", new Snowflake.DatabaseArgs\n        {\n            Comment = \"test comment\",\n            DataRetentionTimeInDays = 3,\n            FromReplica = \"org1\\\".\\\"account1\\\".\\\"primary_db_name\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewDatabase(ctx, \"test\", \u0026snowflake.DatabaseArgs{\n\t\t\tComment:                 pulumi.String(\"test comment\"),\n\t\t\tDataRetentionTimeInDays: pulumi.Int(3),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewDatabase(ctx, \"test2\", \u0026snowflake.DatabaseArgs{\n\t\t\tComment: pulumi.String(\"test comment 2\"),\n\t\t\tReplicationConfiguration: \u0026DatabaseReplicationConfigurationArgs{\n\t\t\t\tAccounts: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"test_account1\"),\n\t\t\t\t\tpulumi.String(\"test_account_2\"),\n\t\t\t\t},\n\t\t\t\tIgnoreEditionCheck: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewDatabase(ctx, \"test3\", \u0026snowflake.DatabaseArgs{\n\t\t\tComment:                 pulumi.String(\"test comment\"),\n\t\t\tDataRetentionTimeInDays: pulumi.Int(3),\n\t\t\tFromReplica:             pulumi.String(\"org1\\\".\\\"account1\\\".\\\"primary_db_name\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Database(\"test\", DatabaseArgs.builder()        \n            .comment(\"test comment\")\n            .dataRetentionTimeInDays(3)\n            .build());\n\n        var test2 = new Database(\"test2\", DatabaseArgs.builder()        \n            .comment(\"test comment 2\")\n            .replicationConfiguration(DatabaseReplicationConfigurationArgs.builder()\n                .accounts(                \n                    \"test_account1\",\n                    \"test_account_2\")\n                .ignoreEditionCheck(true)\n                .build())\n            .build());\n\n        var test3 = new Database(\"test3\", DatabaseArgs.builder()        \n            .comment(\"test comment\")\n            .dataRetentionTimeInDays(3)\n            .fromReplica(\"org1\\\".\\\"account1\\\".\\\"primary_db_name\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: snowflake:Database\n    properties:\n      comment: test comment\n      dataRetentionTimeInDays: 3\n  test2:\n    type: snowflake:Database\n    properties:\n      comment: test comment 2\n      replicationConfiguration:\n        accounts:\n          - test_account1\n          - test_account_2\n        ignoreEditionCheck: true\n  test3:\n    type: snowflake:Database\n    properties:\n      comment: test comment\n      dataRetentionTimeInDays: 3\n      fromReplica: org1\".\"account1\".\"primary_db_name\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/database:Database example name\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string"
                },
                "dataRetentionTimeInDays": {
                    "type": "integer"
                },
                "fromDatabase": {
                    "type": "string",
                    "description": "Specify a database to create a clone from.\n"
                },
                "fromReplica": {
                    "type": "string",
                    "description": "Specify a fully-qualified path to a database to create a replica from. A fully qualified path follows the format of\n\"\u003corganization_name\u003e\".\"\u003caccount_name\u003e\".\"\u003cdb_name\u003e\". An example would be: \"myorg1\".\"account1\".\"db1\"\n"
                },
                "fromShare": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specify a provider and a share in this map to create a database from a share.\n"
                },
                "name": {
                    "type": "string"
                },
                "replicationConfiguration": {
                    "$ref": "#/types/snowflake:index/DatabaseReplicationConfiguration:DatabaseReplicationConfiguration",
                    "description": "When set, specifies the configurations for database replication.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/DatabaseTag:DatabaseTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "required": [
                "dataRetentionTimeInDays",
                "name"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string"
                },
                "dataRetentionTimeInDays": {
                    "type": "integer"
                },
                "fromDatabase": {
                    "type": "string",
                    "description": "Specify a database to create a clone from.\n",
                    "willReplaceOnChanges": true
                },
                "fromReplica": {
                    "type": "string",
                    "description": "Specify a fully-qualified path to a database to create a replica from. A fully qualified path follows the format of\n\"\u003corganization_name\u003e\".\"\u003caccount_name\u003e\".\"\u003cdb_name\u003e\". An example would be: \"myorg1\".\"account1\".\"db1\"\n",
                    "willReplaceOnChanges": true
                },
                "fromShare": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specify a provider and a share in this map to create a database from a share.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string"
                },
                "replicationConfiguration": {
                    "$ref": "#/types/snowflake:index/DatabaseReplicationConfiguration:DatabaseReplicationConfiguration",
                    "description": "When set, specifies the configurations for database replication.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/DatabaseTag:DatabaseTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Database resources.\n",
                "properties": {
                    "comment": {
                        "type": "string"
                    },
                    "dataRetentionTimeInDays": {
                        "type": "integer"
                    },
                    "fromDatabase": {
                        "type": "string",
                        "description": "Specify a database to create a clone from.\n",
                        "willReplaceOnChanges": true
                    },
                    "fromReplica": {
                        "type": "string",
                        "description": "Specify a fully-qualified path to a database to create a replica from. A fully qualified path follows the format of\n\"\u003corganization_name\u003e\".\"\u003caccount_name\u003e\".\"\u003cdb_name\u003e\". An example would be: \"myorg1\".\"account1\".\"db1\"\n",
                        "willReplaceOnChanges": true
                    },
                    "fromShare": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specify a provider and a share in this map to create a database from a share.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string"
                    },
                    "replicationConfiguration": {
                        "$ref": "#/types/snowflake:index/DatabaseReplicationConfiguration:DatabaseReplicationConfiguration",
                        "description": "When set, specifies the configurations for database replication.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/DatabaseTag:DatabaseTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/databaseGrant:DatabaseGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.DatabaseGrant(\"grant\", {\n    databaseName: \"db\",\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.DatabaseGrant(\"grant\",\n    database_name=\"db\",\n    privilege=\"USAGE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.DatabaseGrant(\"grant\", new Snowflake.DatabaseGrantArgs\n        {\n            DatabaseName = \"db\",\n            Privilege = \"USAGE\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            Shares = \n            {\n                \"share1\",\n                \"share2\",\n            },\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewDatabaseGrant(ctx, \"grant\", \u0026snowflake.DatabaseGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"db\"),\n\t\t\tPrivilege:    pulumi.String(\"USAGE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new DatabaseGrant(\"grant\", DatabaseGrantArgs.builder()        \n            .databaseName(\"db\")\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:DatabaseGrant\n    properties:\n      databaseName: db\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | | | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/databaseGrant:DatabaseGrant example 'databaseName|||USAGE|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the database.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the database.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatabaseGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the database.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares.\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/externalFunction:ExternalFunction": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst testExtFunc = new snowflake.ExternalFunction(\"test_ext_func\", {\n    apiIntegration: \"api_integration_name\",\n    args: [\n        {\n            name: \"arg1\",\n            type: \"varchar\",\n        },\n        {\n            name: \"arg2\",\n            type: \"varchar\",\n        },\n    ],\n    database: \"my_test_db\",\n    returnBehavior: \"IMMUTABLE\",\n    returnType: \"varchar\",\n    schema: \"my_test_schema\",\n    urlOfProxyAndResource: \"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntest_ext_func = snowflake.ExternalFunction(\"testExtFunc\",\n    api_integration=\"api_integration_name\",\n    args=[\n        snowflake.ExternalFunctionArgArgs(\n            name=\"arg1\",\n            type=\"varchar\",\n        ),\n        snowflake.ExternalFunctionArgArgs(\n            name=\"arg2\",\n            type=\"varchar\",\n        ),\n    ],\n    database=\"my_test_db\",\n    return_behavior=\"IMMUTABLE\",\n    return_type=\"varchar\",\n    schema=\"my_test_schema\",\n    url_of_proxy_and_resource=\"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var testExtFunc = new Snowflake.ExternalFunction(\"testExtFunc\", new Snowflake.ExternalFunctionArgs\n        {\n            ApiIntegration = \"api_integration_name\",\n            Args = \n            {\n                new Snowflake.Inputs.ExternalFunctionArgArgs\n                {\n                    Name = \"arg1\",\n                    Type = \"varchar\",\n                },\n                new Snowflake.Inputs.ExternalFunctionArgArgs\n                {\n                    Name = \"arg2\",\n                    Type = \"varchar\",\n                },\n            },\n            Database = \"my_test_db\",\n            ReturnBehavior = \"IMMUTABLE\",\n            ReturnType = \"varchar\",\n            Schema = \"my_test_schema\",\n            UrlOfProxyAndResource = \"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewExternalFunction(ctx, \"testExtFunc\", \u0026snowflake.ExternalFunctionArgs{\n\t\t\tApiIntegration: pulumi.String(\"api_integration_name\"),\n\t\t\tArgs: ExternalFunctionArgArray{\n\t\t\t\t\u0026ExternalFunctionArgArgs{\n\t\t\t\t\tName: pulumi.String(\"arg1\"),\n\t\t\t\t\tType: pulumi.String(\"varchar\"),\n\t\t\t\t},\n\t\t\t\t\u0026ExternalFunctionArgArgs{\n\t\t\t\t\tName: pulumi.String(\"arg2\"),\n\t\t\t\t\tType: pulumi.String(\"varchar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDatabase:              pulumi.String(\"my_test_db\"),\n\t\t\tReturnBehavior:        pulumi.String(\"IMMUTABLE\"),\n\t\t\tReturnType:            pulumi.String(\"varchar\"),\n\t\t\tSchema:                pulumi.String(\"my_test_schema\"),\n\t\t\tUrlOfProxyAndResource: pulumi.String(\"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testExtFunc = new ExternalFunction(\"testExtFunc\", ExternalFunctionArgs.builder()        \n            .apiIntegration(\"api_integration_name\")\n            .args(            \n                ExternalFunctionArgArgs.builder()\n                    .name(\"arg1\")\n                    .type(\"varchar\")\n                    .build(),\n                ExternalFunctionArgArgs.builder()\n                    .name(\"arg2\")\n                    .type(\"varchar\")\n                    .build())\n            .database(\"my_test_db\")\n            .returnBehavior(\"IMMUTABLE\")\n            .returnType(\"varchar\")\n            .schema(\"my_test_schema\")\n            .urlOfProxyAndResource(\"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testExtFunc:\n    type: snowflake:ExternalFunction\n    properties:\n      apiIntegration: api_integration_name\n      args:\n        - name: arg1\n          type: varchar\n        - name: arg2\n          type: varchar\n      database: my_test_db\n      returnBehavior: IMMUTABLE\n      returnType: varchar\n      schema: my_test_schema\n      urlOfProxyAndResource: https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | external function name | \u003clist of function arg types, separated with '-'\u003e\n\n```sh\n $ pulumi import snowflake:index/externalFunction:ExternalFunction example 'dbName|schemaName|externalFunctionName|varchar-varchar-varchar'\n```\n\n ",
            "properties": {
                "apiIntegration": {
                    "type": "string",
                    "description": "The name of the API integration object that should be used to authenticate the call to the proxy service.\n"
                },
                "args": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalFunctionArg:ExternalFunctionArg"
                    },
                    "description": "Specifies the arguments/inputs for the external function. These should correspond to the arguments that the remote\nservice expects.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A description of the external function.\n"
                },
                "compression": {
                    "type": "string",
                    "description": "If specified, the JSON payload is compressed when sent from Snowflake to the proxy service, and when sent back from the\nproxy service to Snowflake.\n"
                },
                "contextHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Binds Snowflake context function results to HTTP headers.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the external function was created.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the external function.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalFunctionHeader:ExternalFunctionHeader"
                    },
                    "description": "Allows users to specify key-value metadata that is sent with every request as HTTP headers.\n"
                },
                "maxBatchRows": {
                    "type": "integer",
                    "description": "This specifies the maximum number of rows in each batch sent to the proxy service.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the external function. The identifier can contain the schema name and database name, as\nwell as the function name. The function's signature (name and argument data types) must be unique within the schema.\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the external function when called with null inputs.\n"
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n"
                },
                "returnNullAllowed": {
                    "type": "boolean",
                    "description": "Indicates whether the function can return NULL values or must return only NON-NULL values.\n"
                },
                "returnType": {
                    "type": "string",
                    "description": "Specifies the data type returned by the external function.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the external function.\n"
                },
                "urlOfProxyAndResource": {
                    "type": "string",
                    "description": "This is the invocation URL of the proxy service and resource through which Snowflake calls the remote service.\n"
                }
            },
            "required": [
                "apiIntegration",
                "createdOn",
                "database",
                "name",
                "returnBehavior",
                "returnType",
                "schema",
                "urlOfProxyAndResource"
            ],
            "inputProperties": {
                "apiIntegration": {
                    "type": "string",
                    "description": "The name of the API integration object that should be used to authenticate the call to the proxy service.\n",
                    "willReplaceOnChanges": true
                },
                "args": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalFunctionArg:ExternalFunctionArg"
                    },
                    "description": "Specifies the arguments/inputs for the external function. These should correspond to the arguments that the remote\nservice expects.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "A description of the external function.\n",
                    "willReplaceOnChanges": true
                },
                "compression": {
                    "type": "string",
                    "description": "If specified, the JSON payload is compressed when sent from Snowflake to the proxy service, and when sent back from the\nproxy service to Snowflake.\n",
                    "willReplaceOnChanges": true
                },
                "contextHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Binds Snowflake context function results to HTTP headers.\n",
                    "willReplaceOnChanges": true
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the external function.\n",
                    "willReplaceOnChanges": true
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalFunctionHeader:ExternalFunctionHeader"
                    },
                    "description": "Allows users to specify key-value metadata that is sent with every request as HTTP headers.\n",
                    "willReplaceOnChanges": true
                },
                "maxBatchRows": {
                    "type": "integer",
                    "description": "This specifies the maximum number of rows in each batch sent to the proxy service.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the external function. The identifier can contain the schema name and database name, as\nwell as the function name. The function's signature (name and argument data types) must be unique within the schema.\n",
                    "willReplaceOnChanges": true
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the external function when called with null inputs.\n",
                    "willReplaceOnChanges": true
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n",
                    "willReplaceOnChanges": true
                },
                "returnNullAllowed": {
                    "type": "boolean",
                    "description": "Indicates whether the function can return NULL values or must return only NON-NULL values.\n",
                    "willReplaceOnChanges": true
                },
                "returnType": {
                    "type": "string",
                    "description": "Specifies the data type returned by the external function.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the external function.\n",
                    "willReplaceOnChanges": true
                },
                "urlOfProxyAndResource": {
                    "type": "string",
                    "description": "This is the invocation URL of the proxy service and resource through which Snowflake calls the remote service.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "apiIntegration",
                "database",
                "returnBehavior",
                "returnType",
                "schema",
                "urlOfProxyAndResource"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalFunction resources.\n",
                "properties": {
                    "apiIntegration": {
                        "type": "string",
                        "description": "The name of the API integration object that should be used to authenticate the call to the proxy service.\n",
                        "willReplaceOnChanges": true
                    },
                    "args": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ExternalFunctionArg:ExternalFunctionArg"
                        },
                        "description": "Specifies the arguments/inputs for the external function. These should correspond to the arguments that the remote\nservice expects.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "A description of the external function.\n",
                        "willReplaceOnChanges": true
                    },
                    "compression": {
                        "type": "string",
                        "description": "If specified, the JSON payload is compressed when sent from Snowflake to the proxy service, and when sent back from the\nproxy service to Snowflake.\n",
                        "willReplaceOnChanges": true
                    },
                    "contextHeaders": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Binds Snowflake context function results to HTTP headers.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the external function was created.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the external function.\n",
                        "willReplaceOnChanges": true
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ExternalFunctionHeader:ExternalFunctionHeader"
                        },
                        "description": "Allows users to specify key-value metadata that is sent with every request as HTTP headers.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxBatchRows": {
                        "type": "integer",
                        "description": "This specifies the maximum number of rows in each batch sent to the proxy service.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the external function. The identifier can contain the schema name and database name, as\nwell as the function name. The function's signature (name and argument data types) must be unique within the schema.\n",
                        "willReplaceOnChanges": true
                    },
                    "nullInputBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the external function when called with null inputs.\n",
                        "willReplaceOnChanges": true
                    },
                    "returnBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the function when returning results\n",
                        "willReplaceOnChanges": true
                    },
                    "returnNullAllowed": {
                        "type": "boolean",
                        "description": "Indicates whether the function can return NULL values or must return only NON-NULL values.\n",
                        "willReplaceOnChanges": true
                    },
                    "returnType": {
                        "type": "string",
                        "description": "Specifies the data type returned by the external function.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the external function.\n",
                        "willReplaceOnChanges": true
                    },
                    "urlOfProxyAndResource": {
                        "type": "string",
                        "description": "This is the invocation URL of the proxy service and resource through which Snowflake calls the remote service.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/externalOauthIntegration:ExternalOauthIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst azure = new snowflake.ExternalOauthIntegration(\"azure\", {\n    audienceUrls: [\"https://analysis.windows.net/powerbi/connector/Snowflake\"],\n    enabled: true,\n    issuer: \"https://sts.windows.net/00000000-0000-0000-0000-000000000000\",\n    jwsKeysUrls: [\"https://login.windows.net/common/discovery/keys\"],\n    snowflakeUserMappingAttribute: \"LOGIN_NAME\",\n    tokenUserMappingClaims: [\"upn\"],\n    type: \"AZURE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nazure = snowflake.ExternalOauthIntegration(\"azure\",\n    audience_urls=[\"https://analysis.windows.net/powerbi/connector/Snowflake\"],\n    enabled=True,\n    issuer=\"https://sts.windows.net/00000000-0000-0000-0000-000000000000\",\n    jws_keys_urls=[\"https://login.windows.net/common/discovery/keys\"],\n    snowflake_user_mapping_attribute=\"LOGIN_NAME\",\n    token_user_mapping_claims=[\"upn\"],\n    type=\"AZURE\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var azure = new Snowflake.ExternalOauthIntegration(\"azure\", new Snowflake.ExternalOauthIntegrationArgs\n        {\n            AudienceUrls = \n            {\n                \"https://analysis.windows.net/powerbi/connector/Snowflake\",\n            },\n            Enabled = true,\n            Issuer = \"https://sts.windows.net/00000000-0000-0000-0000-000000000000\",\n            JwsKeysUrls = \n            {\n                \"https://login.windows.net/common/discovery/keys\",\n            },\n            SnowflakeUserMappingAttribute = \"LOGIN_NAME\",\n            TokenUserMappingClaims = \n            {\n                \"upn\",\n            },\n            Type = \"AZURE\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewExternalOauthIntegration(ctx, \"azure\", \u0026snowflake.ExternalOauthIntegrationArgs{\n\t\t\tAudienceUrls: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://analysis.windows.net/powerbi/connector/Snowflake\"),\n\t\t\t},\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tIssuer:  pulumi.String(\"https://sts.windows.net/00000000-0000-0000-0000-000000000000\"),\n\t\t\tJwsKeysUrls: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://login.windows.net/common/discovery/keys\"),\n\t\t\t},\n\t\t\tSnowflakeUserMappingAttribute: pulumi.String(\"LOGIN_NAME\"),\n\t\t\tTokenUserMappingClaims: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"upn\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var azure = new ExternalOauthIntegration(\"azure\", ExternalOauthIntegrationArgs.builder()        \n            .audienceUrls(\"https://analysis.windows.net/powerbi/connector/Snowflake\")\n            .enabled(true)\n            .issuer(\"https://sts.windows.net/00000000-0000-0000-0000-000000000000\")\n            .jwsKeysUrls(\"https://login.windows.net/common/discovery/keys\")\n            .snowflakeUserMappingAttribute(\"LOGIN_NAME\")\n            .tokenUserMappingClaims(\"upn\")\n            .type(\"AZURE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  azure:\n    type: snowflake:ExternalOauthIntegration\n    properties:\n      audienceUrls:\n        - https://analysis.windows.net/powerbi/connector/Snowflake\n      enabled: true\n      issuer: https://sts.windows.net/00000000-0000-0000-0000-000000000000\n      jwsKeysUrls:\n        - https://login.windows.net/common/discovery/keys\n      snowflakeUserMappingAttribute: LOGIN_NAME\n      tokenUserMappingClaims:\n        - upn\n      type: AZURE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/externalOauthIntegration:ExternalOauthIntegration example name\n```\n\n ",
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of roles that the client can set as the primary role.\n"
                },
                "anyRoleMode": {
                    "type": "string",
                    "description": "Specifies whether the OAuth client or user can use a role that is not defined in the OAuth access token.\n"
                },
                "audienceUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies additional values that can be used for the access token's audience validation on top of using the Customer's\nSnowflake Account URL\n"
                },
                "blockedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of roles that a client cannot set as the primary role. Do not include ACCOUNTADMIN, ORGADMIN or\nSECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the OAuth integration.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the External OAUTH integration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether to initiate operation of the integration or suspend it.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Specifies the URL to define the OAuth 2.0 authorization server.\n"
                },
                "jwsKeysUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the endpoint or a list of endpoints from which to download public keys or certificates to validate an External\nOAuth access token. The maximum number of URLs that can be specified in the list is 3.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the External Oath integration. This name follows the rules for Object Identifiers. The name should\nbe unique among security integrations in your account.\n"
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies a second RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers. Used for\nkey rotation.\n"
                },
                "scopeDelimiter": {
                    "type": "string",
                    "description": "Specifies the scope delimiter in the authorization token.\n"
                },
                "snowflakeUserMappingAttribute": {
                    "type": "string",
                    "description": "Indicates which Snowflake user record attribute should be used to map the access token to a Snowflake user record.\n"
                },
                "tokenUserMappingClaims": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the access token claim or claims that can be used to map the access token to a Snowflake user record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the OAuth 2.0 authorization server to be Okta, Microsoft Azure AD, Ping Identity PingFederate, or a Custom\nOAuth 2.0 authorization server.\n"
                }
            },
            "required": [
                "createdOn",
                "enabled",
                "issuer",
                "name",
                "snowflakeUserMappingAttribute",
                "tokenUserMappingClaims",
                "type"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of roles that the client can set as the primary role.\n"
                },
                "anyRoleMode": {
                    "type": "string",
                    "description": "Specifies whether the OAuth client or user can use a role that is not defined in the OAuth access token.\n"
                },
                "audienceUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies additional values that can be used for the access token's audience validation on top of using the Customer's\nSnowflake Account URL\n"
                },
                "blockedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of roles that a client cannot set as the primary role. Do not include ACCOUNTADMIN, ORGADMIN or\nSECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the OAuth integration.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether to initiate operation of the integration or suspend it.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Specifies the URL to define the OAuth 2.0 authorization server.\n"
                },
                "jwsKeysUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the endpoint or a list of endpoints from which to download public keys or certificates to validate an External\nOAuth access token. The maximum number of URLs that can be specified in the list is 3.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the External Oath integration. This name follows the rules for Object Identifiers. The name should\nbe unique among security integrations in your account.\n",
                    "willReplaceOnChanges": true
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies a second RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers. Used for\nkey rotation.\n"
                },
                "scopeDelimiter": {
                    "type": "string",
                    "description": "Specifies the scope delimiter in the authorization token.\n"
                },
                "snowflakeUserMappingAttribute": {
                    "type": "string",
                    "description": "Indicates which Snowflake user record attribute should be used to map the access token to a Snowflake user record.\n"
                },
                "tokenUserMappingClaims": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the access token claim or claims that can be used to map the access token to a Snowflake user record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the OAuth 2.0 authorization server to be Okta, Microsoft Azure AD, Ping Identity PingFederate, or a Custom\nOAuth 2.0 authorization server.\n"
                }
            },
            "requiredInputs": [
                "enabled",
                "issuer",
                "snowflakeUserMappingAttribute",
                "tokenUserMappingClaims",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalOauthIntegration resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of roles that the client can set as the primary role.\n"
                    },
                    "anyRoleMode": {
                        "type": "string",
                        "description": "Specifies whether the OAuth client or user can use a role that is not defined in the OAuth access token.\n"
                    },
                    "audienceUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies additional values that can be used for the access token's audience validation on top of using the Customer's\nSnowflake Account URL\n"
                    },
                    "blockedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of roles that a client cannot set as the primary role. Do not include ACCOUNTADMIN, ORGADMIN or\nSECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the OAuth integration.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the External OAUTH integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether to initiate operation of the integration or suspend it.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Specifies the URL to define the OAuth 2.0 authorization server.\n"
                    },
                    "jwsKeysUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the endpoint or a list of endpoints from which to download public keys or certificates to validate an External\nOAuth access token. The maximum number of URLs that can be specified in the list is 3.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the External Oath integration. This name follows the rules for Object Identifiers. The name should\nbe unique among security integrations in your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "rsaPublicKey": {
                        "type": "string",
                        "description": "Specifies a Base64-encoded RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers.\n"
                    },
                    "rsaPublicKey2": {
                        "type": "string",
                        "description": "Specifies a second RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers. Used for\nkey rotation.\n"
                    },
                    "scopeDelimiter": {
                        "type": "string",
                        "description": "Specifies the scope delimiter in the authorization token.\n"
                    },
                    "snowflakeUserMappingAttribute": {
                        "type": "string",
                        "description": "Indicates which Snowflake user record attribute should be used to map the access token to a Snowflake user record.\n"
                    },
                    "tokenUserMappingClaims": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the access token claim or claims that can be used to map the access token to a Snowflake user record.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the OAuth 2.0 authorization server to be Okta, Microsoft Azure AD, Ping Identity PingFederate, or a Custom\nOAuth 2.0 authorization server.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/externalTable:ExternalTable": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst externalTable = new snowflake.ExternalTable(\"external_table\", {\n    columns: [\n        {\n            name: \"id\",\n            type: \"int\",\n        },\n        {\n            name: \"data\",\n            type: \"text\",\n        },\n    ],\n    comment: \"External table\",\n    database: \"db\",\n    schema: \"schema\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexternal_table = snowflake.ExternalTable(\"externalTable\",\n    columns=[\n        snowflake.ExternalTableColumnArgs(\n            name=\"id\",\n            type=\"int\",\n        ),\n        snowflake.ExternalTableColumnArgs(\n            name=\"data\",\n            type=\"text\",\n        ),\n    ],\n    comment=\"External table\",\n    database=\"db\",\n    schema=\"schema\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var externalTable = new Snowflake.ExternalTable(\"externalTable\", new Snowflake.ExternalTableArgs\n        {\n            Columns = \n            {\n                new Snowflake.Inputs.ExternalTableColumnArgs\n                {\n                    Name = \"id\",\n                    Type = \"int\",\n                },\n                new Snowflake.Inputs.ExternalTableColumnArgs\n                {\n                    Name = \"data\",\n                    Type = \"text\",\n                },\n            },\n            Comment = \"External table\",\n            Database = \"db\",\n            Schema = \"schema\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewExternalTable(ctx, \"externalTable\", \u0026snowflake.ExternalTableArgs{\n\t\t\tColumns: ExternalTableColumnArray{\n\t\t\t\t\u0026ExternalTableColumnArgs{\n\t\t\t\t\tName: pulumi.String(\"id\"),\n\t\t\t\t\tType: pulumi.String(\"int\"),\n\t\t\t\t},\n\t\t\t\t\u0026ExternalTableColumnArgs{\n\t\t\t\t\tName: pulumi.String(\"data\"),\n\t\t\t\t\tType: pulumi.String(\"text\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tComment:  pulumi.String(\"External table\"),\n\t\t\tDatabase: pulumi.String(\"db\"),\n\t\t\tSchema:   pulumi.String(\"schema\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var externalTable = new ExternalTable(\"externalTable\", ExternalTableArgs.builder()        \n            .columns(            \n                ExternalTableColumnArgs.builder()\n                    .name(\"id\")\n                    .type(\"int\")\n                    .build(),\n                ExternalTableColumnArgs.builder()\n                    .name(\"data\")\n                    .type(\"text\")\n                    .build())\n            .comment(\"External table\")\n            .database(\"db\")\n            .schema(\"schema\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  externalTable:\n    type: snowflake:ExternalTable\n    properties:\n      columns:\n        - name: id\n          type: int\n        - name: data\n          type: text\n      comment: External table\n      database: db\n      schema: schema\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | external table name\n\n```sh\n $ pulumi import snowflake:index/externalTable:ExternalTable example 'dbName|schemaName|externalTableName'\n```\n\n ",
            "properties": {
                "autoRefresh": {
                    "type": "boolean",
                    "description": "Specifies whether to automatically refresh the external table metadata once, immediately after the external table is\ncreated.\n"
                },
                "awsSnsTopic": {
                    "type": "string",
                    "description": "Specifies the aws sns topic for the external table.\n"
                },
                "columns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalTableColumn:ExternalTableColumn"
                    },
                    "description": "Definitions of a column to create in the external table. Minimum one required.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the external table.\n"
                },
                "copyGrants": {
                    "type": "boolean",
                    "description": "Specifies to retain the access permissions from the original table when an external table is recreated using the CREATE\nOR REPLACE TABLE variant\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the external table.\n"
                },
                "fileFormat": {
                    "type": "string",
                    "description": "Specifies the file format for the external table.\n"
                },
                "location": {
                    "type": "string",
                    "description": "Specifies a location for the external table.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the external table; must be unique for the database and schema in which the externalTable\nis created.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Name of the role that owns the external table.\n"
                },
                "partitionBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies any partition columns to evaluate for the external table.\n"
                },
                "pattern": {
                    "type": "string",
                    "description": "Specifies the file names and/or paths on the external stage to match.\n"
                },
                "refreshOnCreate": {
                    "type": "boolean",
                    "description": "Specifies weather to refresh when an external table is created.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the external table.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalTableTag:ExternalTableTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "required": [
                "columns",
                "database",
                "fileFormat",
                "location",
                "name",
                "owner",
                "schema"
            ],
            "inputProperties": {
                "autoRefresh": {
                    "type": "boolean",
                    "description": "Specifies whether to automatically refresh the external table metadata once, immediately after the external table is\ncreated.\n",
                    "willReplaceOnChanges": true
                },
                "awsSnsTopic": {
                    "type": "string",
                    "description": "Specifies the aws sns topic for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "columns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalTableColumn:ExternalTableColumn"
                    },
                    "description": "Definitions of a column to create in the external table. Minimum one required.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "copyGrants": {
                    "type": "boolean",
                    "description": "Specifies to retain the access permissions from the original table when an external table is recreated using the CREATE\nOR REPLACE TABLE variant\n",
                    "willReplaceOnChanges": true
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the external table.\n",
                    "willReplaceOnChanges": true
                },
                "fileFormat": {
                    "type": "string",
                    "description": "Specifies the file format for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "location": {
                    "type": "string",
                    "description": "Specifies a location for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the external table; must be unique for the database and schema in which the externalTable\nis created.\n",
                    "willReplaceOnChanges": true
                },
                "partitionBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies any partition columns to evaluate for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "pattern": {
                    "type": "string",
                    "description": "Specifies the file names and/or paths on the external stage to match.\n",
                    "willReplaceOnChanges": true
                },
                "refreshOnCreate": {
                    "type": "boolean",
                    "description": "Specifies weather to refresh when an external table is created.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the external table.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalTableTag:ExternalTableTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "requiredInputs": [
                "columns",
                "database",
                "fileFormat",
                "location",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalTable resources.\n",
                "properties": {
                    "autoRefresh": {
                        "type": "boolean",
                        "description": "Specifies whether to automatically refresh the external table metadata once, immediately after the external table is\ncreated.\n",
                        "willReplaceOnChanges": true
                    },
                    "awsSnsTopic": {
                        "type": "string",
                        "description": "Specifies the aws sns topic for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "columns": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ExternalTableColumn:ExternalTableColumn"
                        },
                        "description": "Definitions of a column to create in the external table. Minimum one required.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "copyGrants": {
                        "type": "boolean",
                        "description": "Specifies to retain the access permissions from the original table when an external table is recreated using the CREATE\nOR REPLACE TABLE variant\n",
                        "willReplaceOnChanges": true
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "fileFormat": {
                        "type": "string",
                        "description": "Specifies the file format for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "location": {
                        "type": "string",
                        "description": "Specifies a location for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the external table; must be unique for the database and schema in which the externalTable\nis created.\n",
                        "willReplaceOnChanges": true
                    },
                    "owner": {
                        "type": "string",
                        "description": "Name of the role that owns the external table.\n"
                    },
                    "partitionBies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies any partition columns to evaluate for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Specifies the file names and/or paths on the external stage to match.\n",
                        "willReplaceOnChanges": true
                    },
                    "refreshOnCreate": {
                        "type": "boolean",
                        "description": "Specifies weather to refresh when an external table is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ExternalTableTag:ExternalTableTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/externalTableGrant:ExternalTableGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.ExternalTableGrant(\"grant\", {\n    databaseName: \"db\",\n    externalTableName: \"external_table\",\n    onFuture: false,\n    privilege: \"select\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.ExternalTableGrant(\"grant\",\n    database_name=\"db\",\n    external_table_name=\"external_table\",\n    on_future=False,\n    privilege=\"select\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.ExternalTableGrant(\"grant\", new Snowflake.ExternalTableGrantArgs\n        {\n            DatabaseName = \"db\",\n            ExternalTableName = \"external_table\",\n            OnFuture = false,\n            Privilege = \"select\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            Shares = \n            {\n                \"share1\",\n                \"share2\",\n            },\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewExternalTableGrant(ctx, \"grant\", \u0026snowflake.ExternalTableGrantArgs{\n\t\t\tDatabaseName:      pulumi.String(\"db\"),\n\t\t\tExternalTableName: pulumi.String(\"external_table\"),\n\t\t\tOnFuture:          pulumi.Bool(false),\n\t\t\tPrivilege:         pulumi.String(\"select\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new ExternalTableGrant(\"grant\", ExternalTableGrantArgs.builder()        \n            .databaseName(\"db\")\n            .externalTableName(\"external_table\")\n            .onFuture(false)\n            .privilege(\"select\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:ExternalTableGrant\n    properties:\n      databaseName: db\n      externalTableName: external_table\n      onFuture: false\n      privilege: select\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | external table name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/externalTableGrant:ExternalTableGrant example 'dbName|schemaName|externalTableName|SELECT|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future external tables on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "externalTableName": {
                    "type": "string",
                    "description": "The name of the external table on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future external tables in the given\nschema. When this is true and no schema_name is provided apply this grant on all future external tables in the given\ndatabase. The external_table_name and shares fields must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future external table.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future external tables on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future external tables on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "externalTableName": {
                    "type": "string",
                    "description": "The name of the external table on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future external tables in the given\nschema. When this is true and no schema_name is provided apply this grant on all future external tables in the given\ndatabase. The external_table_name and shares fields must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future external table.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future external tables on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalTableGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future external tables on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "externalTableName": {
                        "type": "string",
                        "description": "The name of the external table on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future external tables in the given\nschema. When this is true and no schema_name is provided apply this grant on all future external tables in the given\ndatabase. The external_table_name and shares fields must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future external tables on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/fileFormat:FileFormat": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst exampleFileFormat = new snowflake.FileFormat(\"example_file_format\", {\n    database: \"EXAMPLE_DB\",\n    formatType: \"CSV\",\n    schema: \"EXAMPLE_SCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexample_file_format = snowflake.FileFormat(\"exampleFileFormat\",\n    database=\"EXAMPLE_DB\",\n    format_type=\"CSV\",\n    schema=\"EXAMPLE_SCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleFileFormat = new Snowflake.FileFormat(\"exampleFileFormat\", new Snowflake.FileFormatArgs\n        {\n            Database = \"EXAMPLE_DB\",\n            FormatType = \"CSV\",\n            Schema = \"EXAMPLE_SCHEMA\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewFileFormat(ctx, \"exampleFileFormat\", \u0026snowflake.FileFormatArgs{\n\t\t\tDatabase:   pulumi.String(\"EXAMPLE_DB\"),\n\t\t\tFormatType: pulumi.String(\"CSV\"),\n\t\t\tSchema:     pulumi.String(\"EXAMPLE_SCHEMA\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleFileFormat = new FileFormat(\"exampleFileFormat\", FileFormatArgs.builder()        \n            .database(\"EXAMPLE_DB\")\n            .formatType(\"CSV\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleFileFormat:\n    type: snowflake:FileFormat\n    properties:\n      database: EXAMPLE_DB\n      formatType: CSV\n      schema: EXAMPLE_SCHEMA\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | file format name\n\n```sh\n $ pulumi import snowflake:index/fileFormat:FileFormat example 'dbName|schemaName|fileFormatName'\n```\n\n ",
            "properties": {
                "allowDuplicate": {
                    "type": "boolean",
                    "description": "Boolean that specifies to allow duplicate object field names (only the last one will be preserved).\n"
                },
                "binaryAsText": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.\n"
                },
                "binaryFormat": {
                    "type": "string",
                    "description": "Defines the encoding format for binary input or output.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the file format.\n"
                },
                "compression": {
                    "type": "string",
                    "description": "Specifies the current compression algorithm for the data file.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the file format.\n"
                },
                "dateFormat": {
                    "type": "string",
                    "description": "Defines the format of date values in the data files (data loading) or table (data unloading).\n"
                },
                "disableAutoConvert": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to\nnative representation.\n"
                },
                "disableSnowflakeData": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.\n"
                },
                "emptyFieldAsNull": {
                    "type": "boolean",
                    "description": "Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive\ndelimiters.\n"
                },
                "enableOctal": {
                    "type": "boolean",
                    "description": "Boolean that enables parsing of octal numbers.\n"
                },
                "encoding": {
                    "type": "string",
                    "description": "String (constant) that specifies the character set of the source data when loading data into a table.\n"
                },
                "errorOnColumnCountMismatch": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input\nfile does not match the number of columns in the corresponding table.\n"
                },
                "escape": {
                    "type": "string",
                    "description": "Single character string used as the escape character for field values.\n"
                },
                "escapeUnenclosedField": {
                    "type": "string",
                    "description": "Single character string used as the escape character for unenclosed field values only.\n"
                },
                "fieldDelimiter": {
                    "type": "string",
                    "description": "Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or\nunloaded file (data unloading).\n"
                },
                "fieldOptionallyEnclosedBy": {
                    "type": "string",
                    "description": "Character used to enclose strings.\n"
                },
                "fileExtension": {
                    "type": "string",
                    "description": "Specifies the extension for files unloaded to a stage.\n"
                },
                "formatType": {
                    "type": "string",
                    "description": "Specifies the format of the input files (for data loading) or output files (for data unloading).\n"
                },
                "ignoreUtf8Errors": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether UTF-8 encoding errors produce error conditions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the file format; must be unique for the database and schema in which the file format is\ncreated.\n"
                },
                "nullIfs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String used to convert to and from SQL NULL.\n"
                },
                "preserveSpace": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.\n"
                },
                "recordDelimiter": {
                    "type": "string",
                    "description": "Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or\nunloaded file (data unloading).\n"
                },
                "replaceInvalidCharacters": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character ().\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the file format.\n"
                },
                "skipBlankLines": {
                    "type": "boolean",
                    "description": "Boolean that specifies to skip any blank lines encountered in the data files.\n"
                },
                "skipByteOrderMark": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.\n"
                },
                "skipHeader": {
                    "type": "integer",
                    "description": "Number of lines at the start of the file to skip.\n"
                },
                "stripNullValues": {
                    "type": "boolean",
                    "description": "Boolean that instructs the JSON parser to remove object fields or array elements containing null values.\n"
                },
                "stripOuterArray": {
                    "type": "boolean",
                    "description": "Boolean that instructs the JSON parser to remove outer brackets.\n"
                },
                "stripOuterElement": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate\ndocuments.\n"
                },
                "timeFormat": {
                    "type": "string",
                    "description": "Defines the format of time values in the data files (data loading) or table (data unloading).\n"
                },
                "timestampFormat": {
                    "type": "string",
                    "description": "Defines the format of timestamp values in the data files (data loading) or table (data unloading).\n"
                },
                "trimSpace": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to remove white space from fields.\n"
                },
                "validateUtf8": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to validate UTF-8 character encoding in string column data.\n"
                }
            },
            "required": [
                "database",
                "formatType",
                "name",
                "schema"
            ],
            "inputProperties": {
                "allowDuplicate": {
                    "type": "boolean",
                    "description": "Boolean that specifies to allow duplicate object field names (only the last one will be preserved).\n"
                },
                "binaryAsText": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.\n"
                },
                "binaryFormat": {
                    "type": "string",
                    "description": "Defines the encoding format for binary input or output.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the file format.\n"
                },
                "compression": {
                    "type": "string",
                    "description": "Specifies the current compression algorithm for the data file.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the file format.\n",
                    "willReplaceOnChanges": true
                },
                "dateFormat": {
                    "type": "string",
                    "description": "Defines the format of date values in the data files (data loading) or table (data unloading).\n"
                },
                "disableAutoConvert": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to\nnative representation.\n"
                },
                "disableSnowflakeData": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.\n"
                },
                "emptyFieldAsNull": {
                    "type": "boolean",
                    "description": "Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive\ndelimiters.\n"
                },
                "enableOctal": {
                    "type": "boolean",
                    "description": "Boolean that enables parsing of octal numbers.\n"
                },
                "encoding": {
                    "type": "string",
                    "description": "String (constant) that specifies the character set of the source data when loading data into a table.\n"
                },
                "errorOnColumnCountMismatch": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input\nfile does not match the number of columns in the corresponding table.\n"
                },
                "escape": {
                    "type": "string",
                    "description": "Single character string used as the escape character for field values.\n"
                },
                "escapeUnenclosedField": {
                    "type": "string",
                    "description": "Single character string used as the escape character for unenclosed field values only.\n"
                },
                "fieldDelimiter": {
                    "type": "string",
                    "description": "Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or\nunloaded file (data unloading).\n"
                },
                "fieldOptionallyEnclosedBy": {
                    "type": "string",
                    "description": "Character used to enclose strings.\n"
                },
                "fileExtension": {
                    "type": "string",
                    "description": "Specifies the extension for files unloaded to a stage.\n"
                },
                "formatType": {
                    "type": "string",
                    "description": "Specifies the format of the input files (for data loading) or output files (for data unloading).\n",
                    "willReplaceOnChanges": true
                },
                "ignoreUtf8Errors": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether UTF-8 encoding errors produce error conditions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the file format; must be unique for the database and schema in which the file format is\ncreated.\n",
                    "willReplaceOnChanges": true
                },
                "nullIfs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String used to convert to and from SQL NULL.\n"
                },
                "preserveSpace": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.\n"
                },
                "recordDelimiter": {
                    "type": "string",
                    "description": "Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or\nunloaded file (data unloading).\n"
                },
                "replaceInvalidCharacters": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character ().\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the file format.\n",
                    "willReplaceOnChanges": true
                },
                "skipBlankLines": {
                    "type": "boolean",
                    "description": "Boolean that specifies to skip any blank lines encountered in the data files.\n"
                },
                "skipByteOrderMark": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.\n"
                },
                "skipHeader": {
                    "type": "integer",
                    "description": "Number of lines at the start of the file to skip.\n"
                },
                "stripNullValues": {
                    "type": "boolean",
                    "description": "Boolean that instructs the JSON parser to remove object fields or array elements containing null values.\n"
                },
                "stripOuterArray": {
                    "type": "boolean",
                    "description": "Boolean that instructs the JSON parser to remove outer brackets.\n"
                },
                "stripOuterElement": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate\ndocuments.\n"
                },
                "timeFormat": {
                    "type": "string",
                    "description": "Defines the format of time values in the data files (data loading) or table (data unloading).\n"
                },
                "timestampFormat": {
                    "type": "string",
                    "description": "Defines the format of timestamp values in the data files (data loading) or table (data unloading).\n"
                },
                "trimSpace": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to remove white space from fields.\n"
                },
                "validateUtf8": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to validate UTF-8 character encoding in string column data.\n"
                }
            },
            "requiredInputs": [
                "database",
                "formatType",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FileFormat resources.\n",
                "properties": {
                    "allowDuplicate": {
                        "type": "boolean",
                        "description": "Boolean that specifies to allow duplicate object field names (only the last one will be preserved).\n"
                    },
                    "binaryAsText": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.\n"
                    },
                    "binaryFormat": {
                        "type": "string",
                        "description": "Defines the encoding format for binary input or output.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the file format.\n"
                    },
                    "compression": {
                        "type": "string",
                        "description": "Specifies the current compression algorithm for the data file.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the file format.\n",
                        "willReplaceOnChanges": true
                    },
                    "dateFormat": {
                        "type": "string",
                        "description": "Defines the format of date values in the data files (data loading) or table (data unloading).\n"
                    },
                    "disableAutoConvert": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to\nnative representation.\n"
                    },
                    "disableSnowflakeData": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.\n"
                    },
                    "emptyFieldAsNull": {
                        "type": "boolean",
                        "description": "Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive\ndelimiters.\n"
                    },
                    "enableOctal": {
                        "type": "boolean",
                        "description": "Boolean that enables parsing of octal numbers.\n"
                    },
                    "encoding": {
                        "type": "string",
                        "description": "String (constant) that specifies the character set of the source data when loading data into a table.\n"
                    },
                    "errorOnColumnCountMismatch": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input\nfile does not match the number of columns in the corresponding table.\n"
                    },
                    "escape": {
                        "type": "string",
                        "description": "Single character string used as the escape character for field values.\n"
                    },
                    "escapeUnenclosedField": {
                        "type": "string",
                        "description": "Single character string used as the escape character for unenclosed field values only.\n"
                    },
                    "fieldDelimiter": {
                        "type": "string",
                        "description": "Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or\nunloaded file (data unloading).\n"
                    },
                    "fieldOptionallyEnclosedBy": {
                        "type": "string",
                        "description": "Character used to enclose strings.\n"
                    },
                    "fileExtension": {
                        "type": "string",
                        "description": "Specifies the extension for files unloaded to a stage.\n"
                    },
                    "formatType": {
                        "type": "string",
                        "description": "Specifies the format of the input files (for data loading) or output files (for data unloading).\n",
                        "willReplaceOnChanges": true
                    },
                    "ignoreUtf8Errors": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether UTF-8 encoding errors produce error conditions.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the file format; must be unique for the database and schema in which the file format is\ncreated.\n",
                        "willReplaceOnChanges": true
                    },
                    "nullIfs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "String used to convert to and from SQL NULL.\n"
                    },
                    "preserveSpace": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.\n"
                    },
                    "recordDelimiter": {
                        "type": "string",
                        "description": "Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or\nunloaded file (data unloading).\n"
                    },
                    "replaceInvalidCharacters": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character ().\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the file format.\n",
                        "willReplaceOnChanges": true
                    },
                    "skipBlankLines": {
                        "type": "boolean",
                        "description": "Boolean that specifies to skip any blank lines encountered in the data files.\n"
                    },
                    "skipByteOrderMark": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.\n"
                    },
                    "skipHeader": {
                        "type": "integer",
                        "description": "Number of lines at the start of the file to skip.\n"
                    },
                    "stripNullValues": {
                        "type": "boolean",
                        "description": "Boolean that instructs the JSON parser to remove object fields or array elements containing null values.\n"
                    },
                    "stripOuterArray": {
                        "type": "boolean",
                        "description": "Boolean that instructs the JSON parser to remove outer brackets.\n"
                    },
                    "stripOuterElement": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate\ndocuments.\n"
                    },
                    "timeFormat": {
                        "type": "string",
                        "description": "Defines the format of time values in the data files (data loading) or table (data unloading).\n"
                    },
                    "timestampFormat": {
                        "type": "string",
                        "description": "Defines the format of timestamp values in the data files (data loading) or table (data unloading).\n"
                    },
                    "trimSpace": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to remove white space from fields.\n"
                    },
                    "validateUtf8": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to validate UTF-8 character encoding in string column data.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/fileFormatGrant:FileFormatGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.FileFormatGrant(\"grant\", {\n    databaseName: \"db\",\n    fileFormatName: \"file_format\",\n    onFuture: false,\n    privilege: \"select\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.FileFormatGrant(\"grant\",\n    database_name=\"db\",\n    file_format_name=\"file_format\",\n    on_future=False,\n    privilege=\"select\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.FileFormatGrant(\"grant\", new Snowflake.FileFormatGrantArgs\n        {\n            DatabaseName = \"db\",\n            FileFormatName = \"file_format\",\n            OnFuture = false,\n            Privilege = \"select\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewFileFormatGrant(ctx, \"grant\", \u0026snowflake.FileFormatGrantArgs{\n\t\t\tDatabaseName:   pulumi.String(\"db\"),\n\t\t\tFileFormatName: pulumi.String(\"file_format\"),\n\t\t\tOnFuture:       pulumi.Bool(false),\n\t\t\tPrivilege:      pulumi.String(\"select\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new FileFormatGrant(\"grant\", FileFormatGrantArgs.builder()        \n            .databaseName(\"db\")\n            .fileFormatName(\"file_format\")\n            .onFuture(false)\n            .privilege(\"select\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:FileFormatGrant\n    properties:\n      databaseName: db\n      fileFormatName: file_format\n      onFuture: false\n      privilege: select\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | file format name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/fileFormatGrant:FileFormatGrant example 'dbName|schemaName|fileFormatName|USAGE|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future file formats on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "fileFormatName": {
                    "type": "string",
                    "description": "The name of the file format on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future file formats in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future file formats in the given database. The\nfile_format_name field must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future file format.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future file formats on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future file formats on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "fileFormatName": {
                    "type": "string",
                    "description": "The name of the file format on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future file formats in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future file formats in the given database. The\nfile_format_name field must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future file format.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future file formats on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FileFormatGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future file formats on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "fileFormatName": {
                        "type": "string",
                        "description": "The name of the file format on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future file formats in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future file formats in the given database. The\nfile_format_name field must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future file format.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future file formats on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/function:Function": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var db = new Database(\"db\", DatabaseArgs.builder()        \n            .dataRetentionDays(1)\n            .build());\n\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .database(db.name())\n            .dataRetentionDays(1)\n            .build());\n\n        var testFunctJava = new Function(\"testFunctJava\", FunctionArgs.builder()        \n            .database(\"MY_DB\")\n            .schema(\"MY_SCHEMA\")\n            .arguments(FunctionArgumentArgs.builder()\n                .name(\"arg1\")\n                .type(\"number\")\n                .build())\n            .comment(\"Example for java language\")\n            .returnType(\"varchar\")\n            .language(\"java\")\n            .handler(\"CoolFunc.test\")\n            .statement(\"class CoolFunc {public static String test(int n) {return \\\"hello!\\\";}}\")\n            .build());\n\n        var pythonTest = new Function(\"pythonTest\", FunctionArgs.builder()        \n            .database(\"MY_DB\")\n            .schema(\"MY_SCHEMA\")\n            .arguments(FunctionArgumentArgs.builder()\n                .name(\"arg1\")\n                .type(\"number\")\n                .build())\n            .comment(\"Example for Python language\")\n            .returnType(\"NUMBER(38,0)\")\n            .nullInputBehavior(\"CALLED ON NULL INPUT\")\n            .returnBehavior(\"VOLATILE\")\n            .language(\"python\")\n            .runtimeVersion(\"3.8\")\n            .handler(\"add_py\")\n            .statement(\"def add_py(i): return i+1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  db:\n    type: snowflake:Database\n    properties:\n      dataRetentionDays: 1\n  schema:\n    type: snowflake:Schema\n    properties:\n      database: ${db.name}\n      dataRetentionDays: 1\n  testFunctJava:\n    type: snowflake:Function\n    properties:\n      database: MY_DB\n      schema: MY_SCHEMA\n      arguments:\n        - name: arg1\n          type: number\n      comment: Example for java language\n      returnType: varchar\n      language: java\n      handler: CoolFunc.test\n      statement: class CoolFunc {public static String test(int n) {return \"hello!\";}}\n  pythonTest:\n    type: snowflake:Function\n    properties:\n      database: MY_DB\n      schema: MY_SCHEMA\n      arguments:\n        - name: arg1\n          type: number\n      comment: Example for Python language\n      returnType: NUMBER(38,0)\n      nullInputBehavior: CALLED ON NULL INPUT\n      returnBehavior: VOLATILE\n      language: python\n      runtimeVersion: 3.8\n      handler: add_py\n      statement: 'def add_py(i): return i+1'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | function name | \u003clist of arg types, separated with '-'\u003e\n\n```sh\n $ pulumi import snowflake:index/function:Function example 'dbName|schemaName|functionName|varchar-varchar-varchar'\n```\n\n ",
            "properties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/FunctionArgument:FunctionArgument"
                    },
                    "description": "List of the arguments for the function\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the function.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the function. Don't use the | character.\n"
                },
                "handler": {
                    "type": "string",
                    "description": "The handler method for Java / Python function.\n"
                },
                "imports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Imports for Java / Python functions. For Java this a list of jar files, for Python this is a list of Python files.\n"
                },
                "language": {
                    "type": "string",
                    "description": "The language of the statement\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the function; does not have to be unique for the schema in which the function is created.\nDon't use the | character.\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when called with null inputs.\n"
                },
                "packages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of package imports to use for Java / Python functions. For Java, package imports should be of the form:\npackage_name:version_number, where package_name is snowflake_domain:package. For Python use it should be:\n('numpy','pandas','xgboost==1.5.0').\n"
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n"
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the function\n"
                },
                "runtimeVersion": {
                    "type": "string",
                    "description": "Required for Python functions. Specifies Python runtime version.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the function. Don't use the | character.\n"
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the javascript / java / sql / python code used to create the function.\n"
                },
                "targetPath": {
                    "type": "string",
                    "description": "The target path for the Java / Python functions. For Java, it is the path of compiled jar files and for the Python it is\nthe path of the Python files.\n"
                }
            },
            "required": [
                "database",
                "name",
                "returnType",
                "schema",
                "statement"
            ],
            "inputProperties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/FunctionArgument:FunctionArgument"
                    },
                    "description": "List of the arguments for the function\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the function.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the function. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "handler": {
                    "type": "string",
                    "description": "The handler method for Java / Python function.\n",
                    "willReplaceOnChanges": true
                },
                "imports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Imports for Java / Python functions. For Java this a list of jar files, for Python this is a list of Python files.\n",
                    "willReplaceOnChanges": true
                },
                "language": {
                    "type": "string",
                    "description": "The language of the statement\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the function; does not have to be unique for the schema in which the function is created.\nDon't use the | character.\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when called with null inputs.\n",
                    "willReplaceOnChanges": true
                },
                "packages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of package imports to use for Java / Python functions. For Java, package imports should be of the form:\npackage_name:version_number, where package_name is snowflake_domain:package. For Python use it should be:\n('numpy','pandas','xgboost==1.5.0').\n",
                    "willReplaceOnChanges": true
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n",
                    "willReplaceOnChanges": true
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the function\n",
                    "willReplaceOnChanges": true
                },
                "runtimeVersion": {
                    "type": "string",
                    "description": "Required for Python functions. Specifies Python runtime version.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the function. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the javascript / java / sql / python code used to create the function.\n",
                    "willReplaceOnChanges": true
                },
                "targetPath": {
                    "type": "string",
                    "description": "The target path for the Java / Python functions. For Java, it is the path of compiled jar files and for the Python it is\nthe path of the Python files.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "returnType",
                "schema",
                "statement"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Function resources.\n",
                "properties": {
                    "arguments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/FunctionArgument:FunctionArgument"
                        },
                        "description": "List of the arguments for the function\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the function.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the function. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "handler": {
                        "type": "string",
                        "description": "The handler method for Java / Python function.\n",
                        "willReplaceOnChanges": true
                    },
                    "imports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Imports for Java / Python functions. For Java this a list of jar files, for Python this is a list of Python files.\n",
                        "willReplaceOnChanges": true
                    },
                    "language": {
                        "type": "string",
                        "description": "The language of the statement\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the function; does not have to be unique for the schema in which the function is created.\nDon't use the | character.\n"
                    },
                    "nullInputBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the function when called with null inputs.\n",
                        "willReplaceOnChanges": true
                    },
                    "packages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of package imports to use for Java / Python functions. For Java, package imports should be of the form:\npackage_name:version_number, where package_name is snowflake_domain:package. For Python use it should be:\n('numpy','pandas','xgboost==1.5.0').\n",
                        "willReplaceOnChanges": true
                    },
                    "returnBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the function when returning results\n",
                        "willReplaceOnChanges": true
                    },
                    "returnType": {
                        "type": "string",
                        "description": "The return type of the function\n",
                        "willReplaceOnChanges": true
                    },
                    "runtimeVersion": {
                        "type": "string",
                        "description": "Required for Python functions. Specifies Python runtime version.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the function. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "statement": {
                        "type": "string",
                        "description": "Specifies the javascript / java / sql / python code used to create the function.\n",
                        "willReplaceOnChanges": true
                    },
                    "targetPath": {
                        "type": "string",
                        "description": "The target path for the Java / Python functions. For Java, it is the path of compiled jar files and for the Python it is\nthe path of the Python files.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/functionGrant:FunctionGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.FunctionGrant(\"grant\", {\n    arguments: [\n        {\n            name: \"a\",\n            type: \"array\",\n        },\n        {\n            name: \"b\",\n            type: \"string\",\n        },\n    ],\n    databaseName: \"db\",\n    functionName: \"function\",\n    onFuture: false,\n    privilege: \"USAGE\",\n    returnType: \"string\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.FunctionGrant(\"grant\",\n    arguments=[\n        snowflake.FunctionGrantArgumentArgs(\n            name=\"a\",\n            type=\"array\",\n        ),\n        snowflake.FunctionGrantArgumentArgs(\n            name=\"b\",\n            type=\"string\",\n        ),\n    ],\n    database_name=\"db\",\n    function_name=\"function\",\n    on_future=False,\n    privilege=\"USAGE\",\n    return_type=\"string\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.FunctionGrant(\"grant\", new Snowflake.FunctionGrantArgs\n        {\n            Arguments = \n            {\n                new Snowflake.Inputs.FunctionGrantArgumentArgs\n                {\n                    Name = \"a\",\n                    Type = \"array\",\n                },\n                new Snowflake.Inputs.FunctionGrantArgumentArgs\n                {\n                    Name = \"b\",\n                    Type = \"string\",\n                },\n            },\n            DatabaseName = \"db\",\n            FunctionName = \"function\",\n            OnFuture = false,\n            Privilege = \"USAGE\",\n            ReturnType = \"string\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            Shares = \n            {\n                \"share1\",\n                \"share2\",\n            },\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewFunctionGrant(ctx, \"grant\", \u0026snowflake.FunctionGrantArgs{\n\t\t\tArguments: FunctionGrantArgumentArray{\n\t\t\t\t\u0026FunctionGrantArgumentArgs{\n\t\t\t\t\tName: pulumi.String(\"a\"),\n\t\t\t\t\tType: pulumi.String(\"array\"),\n\t\t\t\t},\n\t\t\t\t\u0026FunctionGrantArgumentArgs{\n\t\t\t\t\tName: pulumi.String(\"b\"),\n\t\t\t\t\tType: pulumi.String(\"string\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDatabaseName: pulumi.String(\"db\"),\n\t\t\tFunctionName: pulumi.String(\"function\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"USAGE\"),\n\t\t\tReturnType:   pulumi.String(\"string\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new FunctionGrant(\"grant\", FunctionGrantArgs.builder()        \n            .arguments(            \n                FunctionGrantArgumentArgs.builder()\n                    .name(\"a\")\n                    .type(\"array\")\n                    .build(),\n                FunctionGrantArgumentArgs.builder()\n                    .name(\"b\")\n                    .type(\"string\")\n                    .build())\n            .databaseName(\"db\")\n            .functionName(\"function\")\n            .onFuture(false)\n            .privilege(\"USAGE\")\n            .returnType(\"string\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:FunctionGrant\n    properties:\n      arguments:\n        - name: a\n          type: array\n        - name: b\n          type: string\n      databaseName: db\n      functionName: function\n      onFuture: false\n      privilege: USAGE\n      returnType: string\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | function signature | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/functionGrant:FunctionGrant example 'dbName|schemaName|functionName(ARG1 ARG1TYPE, ARG2 ARG2TYPE):RETURNTYPE|USAGE|false'\n```\n\n ",
            "properties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/FunctionGrantArgument:FunctionGrantArgument"
                    },
                    "description": "List of the arguments for the function (must be present if function has arguments and function_name is present)\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future functions on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "functionName": {
                    "type": "string",
                    "description": "The name of the function on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future functions in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future functions in the given database. The\nfunction_name, arguments, return_type, and shares fields must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future function. Must be one of `USAGE` or `OWNERSHIP`.\n"
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the function (must be present if function_name is present)\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future functions on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "schemaName"
            ],
            "inputProperties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/FunctionGrantArgument:FunctionGrantArgument"
                    },
                    "description": "List of the arguments for the function (must be present if function has arguments and function_name is present)\n",
                    "willReplaceOnChanges": true
                },
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future functions on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "functionName": {
                    "type": "string",
                    "description": "The name of the function on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future functions in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future functions in the given database. The\nfunction_name, arguments, return_type, and shares fields must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future function. Must be one of `USAGE` or `OWNERSHIP`.\n",
                    "willReplaceOnChanges": true
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the function (must be present if function_name is present)\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future functions on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FunctionGrant resources.\n",
                "properties": {
                    "arguments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/FunctionGrantArgument:FunctionGrantArgument"
                        },
                        "description": "List of the arguments for the function (must be present if function has arguments and function_name is present)\n",
                        "willReplaceOnChanges": true
                    },
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future functions on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "functionName": {
                        "type": "string",
                        "description": "The name of the function on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future functions in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future functions in the given database. The\nfunction_name, arguments, return_type, and shares fields must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future function. Must be one of `USAGE` or `OWNERSHIP`.\n",
                        "willReplaceOnChanges": true
                    },
                    "returnType": {
                        "type": "string",
                        "description": "The return type of the function (must be present if function_name is present)\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future functions on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/integrationGrant:IntegrationGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.IntegrationGrant(\"grant\", {\n    integrationName: \"integration\",\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.IntegrationGrant(\"grant\",\n    integration_name=\"integration\",\n    privilege=\"USAGE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.IntegrationGrant(\"grant\", new Snowflake.IntegrationGrantArgs\n        {\n            IntegrationName = \"integration\",\n            Privilege = \"USAGE\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewIntegrationGrant(ctx, \"grant\", \u0026snowflake.IntegrationGrantArgs{\n\t\t\tIntegrationName: pulumi.String(\"integration\"),\n\t\t\tPrivilege:       pulumi.String(\"USAGE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new IntegrationGrant(\"grant\", IntegrationGrantArgs.builder()        \n            .integrationName(\"integration\")\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:IntegrationGrant\n    properties:\n      integrationName: integration\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is integration name ||| privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/integrationGrant:IntegrationGrant example 'intName|||USAGE|true'\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "integrationName": {
                    "type": "string",
                    "description": "Identifier for the integration; must be unique for your account.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the integration.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "integrationName"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "integrationName": {
                    "type": "string",
                    "description": "Identifier for the integration; must be unique for your account.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the integration.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "integrationName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "integrationName": {
                        "type": "string",
                        "description": "Identifier for the integration; must be unique for your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the integration.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/managedAccount:ManagedAccount": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst account = new snowflake.ManagedAccount(\"account\", {\n    adminName: \"admin\",\n    adminPassword: \"secret\",\n    cloud: \"aws\",\n    comment: \"A managed account.\",\n    locator: \"managed-account\",\n    region: \"us-west-2\",\n    type: \"READER\",\n});\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var account = new ManagedAccount(\"account\", ManagedAccountArgs.builder()        \n            .adminName(\"admin\")\n            .adminPassword(\"secret\")\n            .cloud(\"aws\")\n            .comment(\"A managed account.\")\n            .locator(\"managed-account\")\n            .region(\"us-west-2\")\n            .type(\"READER\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  account:\n    type: snowflake:ManagedAccount\n    properties:\n      adminName: admin\n      adminPassword: secret\n      cloud: aws\n      comment: A managed account.\n      locator: managed-account\n      region: us-west-2\n      type: READER\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/managedAccount:ManagedAccount example name\n```\n\n ",
            "properties": {
                "adminName": {
                    "type": "string",
                    "description": "Identifier, as well as login name, for the initial user in the managed account. This user serves as the account\nadministrator for the account.\n"
                },
                "adminPassword": {
                    "type": "string",
                    "description": "Password for the initial user in the managed account.\n"
                },
                "cloud": {
                    "type": "string",
                    "description": "Cloud in which the managed account is located.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the managed account.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the managed account was created.\n"
                },
                "locator": {
                    "type": "string",
                    "description": "Display name of the managed account.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the managed account; must be unique for your account.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Snowflake Region in which the managed account is located.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of managed account.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL for accessing the managed account, particularly through the web interface.\n"
                }
            },
            "required": [
                "adminName",
                "adminPassword",
                "cloud",
                "createdOn",
                "locator",
                "name",
                "region",
                "url"
            ],
            "inputProperties": {
                "adminName": {
                    "type": "string",
                    "description": "Identifier, as well as login name, for the initial user in the managed account. This user serves as the account\nadministrator for the account.\n",
                    "willReplaceOnChanges": true
                },
                "adminPassword": {
                    "type": "string",
                    "description": "Password for the initial user in the managed account.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the managed account.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the managed account; must be unique for your account.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of managed account.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "adminName",
                "adminPassword"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedAccount resources.\n",
                "properties": {
                    "adminName": {
                        "type": "string",
                        "description": "Identifier, as well as login name, for the initial user in the managed account. This user serves as the account\nadministrator for the account.\n",
                        "willReplaceOnChanges": true
                    },
                    "adminPassword": {
                        "type": "string",
                        "description": "Password for the initial user in the managed account.\n",
                        "willReplaceOnChanges": true
                    },
                    "cloud": {
                        "type": "string",
                        "description": "Cloud in which the managed account is located.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the managed account.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the managed account was created.\n"
                    },
                    "locator": {
                        "type": "string",
                        "description": "Display name of the managed account.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Identifier for the managed account; must be unique for your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "region": {
                        "type": "string",
                        "description": "Snowflake Region in which the managed account is located.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of managed account.\n",
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "type": "string",
                        "description": "URL for accessing the managed account, particularly through the web interface.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/maskingPolicy:MaskingPolicy": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst exampleMaskingPolicy = new snowflake.MaskingPolicy(\"example_masking_policy\", {\n    database: \"EXAMPLE_DB\",\n    maskingExpression: \"case when current_role() in ('ANALYST') then val else sha2(val, 512) end\",\n    returnDataType: \"string\",\n    schema: \"EXAMPLE_SCHEMA\",\n    valueDataType: \"string\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexample_masking_policy = snowflake.MaskingPolicy(\"exampleMaskingPolicy\",\n    database=\"EXAMPLE_DB\",\n    masking_expression=\"case when current_role() in ('ANALYST') then val else sha2(val, 512) end\",\n    return_data_type=\"string\",\n    schema=\"EXAMPLE_SCHEMA\",\n    value_data_type=\"string\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleMaskingPolicy = new Snowflake.MaskingPolicy(\"exampleMaskingPolicy\", new Snowflake.MaskingPolicyArgs\n        {\n            Database = \"EXAMPLE_DB\",\n            MaskingExpression = \"case when current_role() in ('ANALYST') then val else sha2(val, 512) end\",\n            ReturnDataType = \"string\",\n            Schema = \"EXAMPLE_SCHEMA\",\n            ValueDataType = \"string\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewMaskingPolicy(ctx, \"exampleMaskingPolicy\", \u0026snowflake.MaskingPolicyArgs{\n\t\t\tDatabase:          pulumi.String(\"EXAMPLE_DB\"),\n\t\t\tMaskingExpression: pulumi.String(\"case when current_role() in ('ANALYST') then val else sha2(val, 512) end\"),\n\t\t\tReturnDataType:    pulumi.String(\"string\"),\n\t\t\tSchema:            pulumi.String(\"EXAMPLE_SCHEMA\"),\n\t\t\tValueDataType:     pulumi.String(\"string\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleMaskingPolicy = new MaskingPolicy(\"exampleMaskingPolicy\", MaskingPolicyArgs.builder()        \n            .database(\"EXAMPLE_DB\")\n            .maskingExpression(\"case when current_role() in ('ANALYST') then val else sha2(val, 512) end\")\n            .returnDataType(\"string\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .valueDataType(\"string\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleMaskingPolicy:\n    type: snowflake:MaskingPolicy\n    properties:\n      database: EXAMPLE_DB\n      maskingExpression: case when current_role() in ('ANALYST') then val else sha2(val, 512) end\n      returnDataType: string\n      schema: EXAMPLE_SCHEMA\n      valueDataType: string\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | policy name\n\n```sh\n $ pulumi import snowflake:index/maskingPolicy:MaskingPolicy example 'dbName|schemaName|policyName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the masking policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the masking policy.\n"
                },
                "maskingExpression": {
                    "type": "string",
                    "description": "Specifies the SQL expression that transforms the data.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the masking policy; must be unique for the database and schema in which the masking policy\nis created.\n"
                },
                "returnDataType": {
                    "type": "string",
                    "description": "Specifies the data type to return.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the masking policy.\n"
                },
                "valueDataType": {
                    "type": "string",
                    "description": "Specifies the data type to mask.\n"
                }
            },
            "required": [
                "database",
                "maskingExpression",
                "name",
                "returnDataType",
                "schema",
                "valueDataType"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the masking policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the masking policy.\n",
                    "willReplaceOnChanges": true
                },
                "maskingExpression": {
                    "type": "string",
                    "description": "Specifies the SQL expression that transforms the data.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the masking policy; must be unique for the database and schema in which the masking policy\nis created.\n",
                    "willReplaceOnChanges": true
                },
                "returnDataType": {
                    "type": "string",
                    "description": "Specifies the data type to return.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the masking policy.\n",
                    "willReplaceOnChanges": true
                },
                "valueDataType": {
                    "type": "string",
                    "description": "Specifies the data type to mask.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "maskingExpression",
                "returnDataType",
                "schema",
                "valueDataType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaskingPolicy resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the masking policy.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the masking policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "maskingExpression": {
                        "type": "string",
                        "description": "Specifies the SQL expression that transforms the data.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the masking policy; must be unique for the database and schema in which the masking policy\nis created.\n",
                        "willReplaceOnChanges": true
                    },
                    "returnDataType": {
                        "type": "string",
                        "description": "Specifies the data type to return.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the masking policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "valueDataType": {
                        "type": "string",
                        "description": "Specifies the data type to mask.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/maskingPolicyGrant:MaskingPolicyGrant": {
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the masking policy on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "maskingPolicyName": {
                    "type": "string",
                    "description": "The name of the masking policy on which to grant privileges immediately.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the masking policy.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the masking policy on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "maskingPolicyName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the masking policy on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "maskingPolicyName": {
                    "type": "string",
                    "description": "The name of the masking policy on which to grant privileges immediately.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the masking policy.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the masking policy on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "maskingPolicyName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaskingPolicyGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the masking policy on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "maskingPolicyName": {
                        "type": "string",
                        "description": "The name of the masking policy on which to grant privileges immediately.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the masking policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the masking policy on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/materializedView:MaterializedView": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst view = new snowflake.MaterializedView(\"view\", {\n    database: \"db\",\n    schema: \"schema\",\n    warehouse: \"warehouse\",\n    comment: \"comment\",\n    statement: \"select * from foo;\\n\",\n    orReplace: false,\n    isSecure: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nview = snowflake.MaterializedView(\"view\",\n    database=\"db\",\n    schema=\"schema\",\n    warehouse=\"warehouse\",\n    comment=\"comment\",\n    statement=\"select * from foo;\\n\",\n    or_replace=False,\n    is_secure=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var view = new Snowflake.MaterializedView(\"view\", new Snowflake.MaterializedViewArgs\n        {\n            Database = \"db\",\n            Schema = \"schema\",\n            Warehouse = \"warehouse\",\n            Comment = \"comment\",\n            Statement = @\"select * from foo;\n\",\n            OrReplace = false,\n            IsSecure = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewMaterializedView(ctx, \"view\", \u0026snowflake.MaterializedViewArgs{\n\t\t\tDatabase:  pulumi.String(\"db\"),\n\t\t\tSchema:    pulumi.String(\"schema\"),\n\t\t\tWarehouse: pulumi.String(\"warehouse\"),\n\t\t\tComment:   pulumi.String(\"comment\"),\n\t\t\tStatement: pulumi.String(\"select * from foo;\\n\"),\n\t\t\tOrReplace: pulumi.Bool(false),\n\t\t\tIsSecure:  pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var view = new MaterializedView(\"view\", MaterializedViewArgs.builder()        \n            .database(\"db\")\n            .schema(\"schema\")\n            .warehouse(\"warehouse\")\n            .comment(\"comment\")\n            .statement(\"\"\"\nselect * from foo;\n            \"\"\")\n            .orReplace(false)\n            .isSecure(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  view:\n    type: snowflake:MaterializedView\n    properties:\n      database: db\n      schema: schema\n      warehouse: warehouse\n      comment: comment\n      statement: |\n        select * from foo;\n      orReplace: false\n      isSecure: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | view name\n\n```sh\n $ pulumi import snowflake:index/materializedView:MaterializedView example 'dbName|schemaName|viewName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the view.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the view. Don't use the | character.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the view is secure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the view; must be unique for the schema in which the view is created.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Overwrites the View if it exists.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the view. Don't use the | character.\n"
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the query used to create the view.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/MaterializedViewTag:MaterializedViewTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse name.\n"
                }
            },
            "required": [
                "database",
                "name",
                "schema",
                "statement",
                "warehouse"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the view.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the view. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the view is secure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the view; must be unique for the schema in which the view is created.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Overwrites the View if it exists.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the view. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the query used to create the view.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/MaterializedViewTag:MaterializedViewTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse name.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "schema",
                "statement",
                "warehouse"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaterializedView resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the view.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the view. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "isSecure": {
                        "type": "boolean",
                        "description": "Specifies that the view is secure.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the view; must be unique for the schema in which the view is created.\n"
                    },
                    "orReplace": {
                        "type": "boolean",
                        "description": "Overwrites the View if it exists.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the view. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "statement": {
                        "type": "string",
                        "description": "Specifies the query used to create the view.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/MaterializedViewTag:MaterializedViewTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    },
                    "warehouse": {
                        "type": "string",
                        "description": "The warehouse name.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/materializedViewGrant:MaterializedViewGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.MaterializedViewGrant(\"grant\", {\n    databaseName: \"db\",\n    materializedViewName: \"materialized_view\",\n    onFuture: false,\n    privilege: \"select\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.MaterializedViewGrant(\"grant\",\n    database_name=\"db\",\n    materialized_view_name=\"materialized_view\",\n    on_future=False,\n    privilege=\"select\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.MaterializedViewGrant(\"grant\", new Snowflake.MaterializedViewGrantArgs\n        {\n            DatabaseName = \"db\",\n            MaterializedViewName = \"materialized_view\",\n            OnFuture = false,\n            Privilege = \"select\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            Shares = \n            {\n                \"share1\",\n                \"share2\",\n            },\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewMaterializedViewGrant(ctx, \"grant\", \u0026snowflake.MaterializedViewGrantArgs{\n\t\t\tDatabaseName:         pulumi.String(\"db\"),\n\t\t\tMaterializedViewName: pulumi.String(\"materialized_view\"),\n\t\t\tOnFuture:             pulumi.Bool(false),\n\t\t\tPrivilege:            pulumi.String(\"select\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new MaterializedViewGrant(\"grant\", MaterializedViewGrantArgs.builder()        \n            .databaseName(\"db\")\n            .materializedViewName(\"materialized_view\")\n            .onFuture(false)\n            .privilege(\"select\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:MaterializedViewGrant\n    properties:\n      databaseName: db\n      materializedViewName: materialized_view\n      onFuture: false\n      privilege: select\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | materialized view name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/materializedViewGrant:MaterializedViewGrant example 'dbName|schemaName|materializedViewName|SELECT|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future materialized views on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "materializedViewName": {
                    "type": "string",
                    "description": "The name of the materialized view on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future materialized views in the given\nschema. When this is true and no schema_name is provided apply this grant on all future materialized views in the given\ndatabase. The materialized_view_name and shares fields must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future materialized view view.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future materialized views on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future materialized views on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "materializedViewName": {
                    "type": "string",
                    "description": "The name of the materialized view on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future materialized views in the given\nschema. When this is true and no schema_name is provided apply this grant on all future materialized views in the given\ndatabase. The materialized_view_name and shares fields must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future materialized view view.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future materialized views on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaterializedViewGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future materialized views on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "materializedViewName": {
                        "type": "string",
                        "description": "The name of the materialized view on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future materialized views in the given\nschema. When this is true and no schema_name is provided apply this grant on all future materialized views in the given\ndatabase. The materialized_view_name and shares fields must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future materialized view view.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future materialized views on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/networkPolicy:NetworkPolicy": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst policy = new snowflake.NetworkPolicy(\"policy\", {\n    allowedIpLists: [\"192.168.0.100/24\"],\n    blockedIpLists: [\"192.168.0.101\"],\n    comment: \"A policy.\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\npolicy = snowflake.NetworkPolicy(\"policy\",\n    allowed_ip_lists=[\"192.168.0.100/24\"],\n    blocked_ip_lists=[\"192.168.0.101\"],\n    comment=\"A policy.\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var policy = new Snowflake.NetworkPolicy(\"policy\", new Snowflake.NetworkPolicyArgs\n        {\n            AllowedIpLists = \n            {\n                \"192.168.0.100/24\",\n            },\n            BlockedIpLists = \n            {\n                \"192.168.0.101\",\n            },\n            Comment = \"A policy.\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewNetworkPolicy(ctx, \"policy\", \u0026snowflake.NetworkPolicyArgs{\n\t\t\tAllowedIpLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.168.0.100/24\"),\n\t\t\t},\n\t\t\tBlockedIpLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.168.0.101\"),\n\t\t\t},\n\t\t\tComment: pulumi.String(\"A policy.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var policy = new NetworkPolicy(\"policy\", NetworkPolicyArgs.builder()        \n            .allowedIpLists(\"192.168.0.100/24\")\n            .blockedIpLists(\"192.168.0.101\")\n            .comment(\"A policy.\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  policy:\n    type: snowflake:NetworkPolicy\n    properties:\n      allowedIpLists:\n        - 192.168.0.100/24\n      blockedIpLists:\n        - 192.168.0.101\n      comment: A policy.\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/networkPolicy:NetworkPolicy example policyname\n```\n\n ",
            "properties": {
                "allowedIpLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more IPv4 addresses (CIDR notation) that are allowed access to your Snowflake account\n"
                },
                "blockedIpLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more IPv4 addresses (CIDR notation) that are denied access to your Snowflake account\u003cbr\u003e\u003cbr\u003e**Do not**\nadd `0.0.0.0/0` to `blocked_ip_list`\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the network policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n"
                }
            },
            "required": [
                "allowedIpLists",
                "name"
            ],
            "inputProperties": {
                "allowedIpLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more IPv4 addresses (CIDR notation) that are allowed access to your Snowflake account\n"
                },
                "blockedIpLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more IPv4 addresses (CIDR notation) that are denied access to your Snowflake account\u003cbr\u003e\u003cbr\u003e**Do not**\nadd `0.0.0.0/0` to `blocked_ip_list`\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the network policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "allowedIpLists"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkPolicy resources.\n",
                "properties": {
                    "allowedIpLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies one or more IPv4 addresses (CIDR notation) that are allowed access to your Snowflake account\n"
                    },
                    "blockedIpLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies one or more IPv4 addresses (CIDR notation) that are denied access to your Snowflake account\u003cbr\u003e\u003cbr\u003e**Do not**\nadd `0.0.0.0/0` to `blocked_ip_list`\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the network policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/networkPolicyAttachment:NetworkPolicyAttachment": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst attach = new snowflake.NetworkPolicyAttachment(\"attach\", {\n    networkPolicyName: \"policy\",\n    setForAccount: false,\n    users: [\n        \"user1\",\n        \"user2\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nattach = snowflake.NetworkPolicyAttachment(\"attach\",\n    network_policy_name=\"policy\",\n    set_for_account=False,\n    users=[\n        \"user1\",\n        \"user2\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var attach = new Snowflake.NetworkPolicyAttachment(\"attach\", new Snowflake.NetworkPolicyAttachmentArgs\n        {\n            NetworkPolicyName = \"policy\",\n            SetForAccount = false,\n            Users = \n            {\n                \"user1\",\n                \"user2\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewNetworkPolicyAttachment(ctx, \"attach\", \u0026snowflake.NetworkPolicyAttachmentArgs{\n\t\t\tNetworkPolicyName: pulumi.String(\"policy\"),\n\t\t\tSetForAccount:     pulumi.Bool(false),\n\t\t\tUsers: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user1\"),\n\t\t\t\tpulumi.String(\"user2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var attach = new NetworkPolicyAttachment(\"attach\", NetworkPolicyAttachmentArgs.builder()        \n            .networkPolicyName(\"policy\")\n            .setForAccount(false)\n            .users(            \n                \"user1\",\n                \"user2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attach:\n    type: snowflake:NetworkPolicyAttachment\n    properties:\n      networkPolicyName: policy\n      setForAccount: false\n      users:\n        - user1\n        - user2\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/networkPolicyAttachment:NetworkPolicyAttachment example attachment_policyname\n```\n\n ",
            "properties": {
                "networkPolicyName": {
                    "type": "string",
                    "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n"
                },
                "setForAccount": {
                    "type": "boolean",
                    "description": "Specifies whether the network policy should be applied globally to your Snowflake account\u003cbr\u003e\u003cbr\u003e**Note:** The Snowflake\nuser running `terraform apply` must be on an IP address allowed by the network policy to set that policy globally on the\nSnowflake account.\u003cbr\u003e\u003cbr\u003eAdditionally, a Snowflake account can only have one network policy set globally at any given\ntime. This resource does not enforce one-policy-per-account, it is the user's responsibility to enforce this. If\nmultiple network policy resources have `set_for_account: true`, the final policy set on the account will be\nnon-deterministic.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies which users the network policy should be attached to\n"
                }
            },
            "required": [
                "networkPolicyName"
            ],
            "inputProperties": {
                "networkPolicyName": {
                    "type": "string",
                    "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n",
                    "willReplaceOnChanges": true
                },
                "setForAccount": {
                    "type": "boolean",
                    "description": "Specifies whether the network policy should be applied globally to your Snowflake account\u003cbr\u003e\u003cbr\u003e**Note:** The Snowflake\nuser running `terraform apply` must be on an IP address allowed by the network policy to set that policy globally on the\nSnowflake account.\u003cbr\u003e\u003cbr\u003eAdditionally, a Snowflake account can only have one network policy set globally at any given\ntime. This resource does not enforce one-policy-per-account, it is the user's responsibility to enforce this. If\nmultiple network policy resources have `set_for_account: true`, the final policy set on the account will be\nnon-deterministic.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies which users the network policy should be attached to\n"
                }
            },
            "requiredInputs": [
                "networkPolicyName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkPolicyAttachment resources.\n",
                "properties": {
                    "networkPolicyName": {
                        "type": "string",
                        "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "setForAccount": {
                        "type": "boolean",
                        "description": "Specifies whether the network policy should be applied globally to your Snowflake account\u003cbr\u003e\u003cbr\u003e**Note:** The Snowflake\nuser running `terraform apply` must be on an IP address allowed by the network policy to set that policy globally on the\nSnowflake account.\u003cbr\u003e\u003cbr\u003eAdditionally, a Snowflake account can only have one network policy set globally at any given\ntime. This resource does not enforce one-policy-per-account, it is the user's responsibility to enforce this. If\nmultiple network policy resources have `set_for_account: true`, the final policy set on the account will be\nnon-deterministic.\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies which users the network policy should be attached to\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/notificationIntegration:NotificationIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst integration = new snowflake.NotificationIntegration(\"integration\", {\n    awsSnsRoleArn: \"...\",\n    awsSnsTopicArn: \"...\",\n    awsSqsArn: \"...\",\n    awsSqsRoleArn: \"...\",\n    azureStorageQueuePrimaryUri: \"...\",\n    azureTenantId: \"...\",\n    comment: \"A notification integration.\",\n    direction: \"OUTBOUND\",\n    enabled: true,\n    notificationProvider: \"AWS_SNS\",\n    type: \"QUEUE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nintegration = snowflake.NotificationIntegration(\"integration\",\n    aws_sns_role_arn=\"...\",\n    aws_sns_topic_arn=\"...\",\n    aws_sqs_arn=\"...\",\n    aws_sqs_role_arn=\"...\",\n    azure_storage_queue_primary_uri=\"...\",\n    azure_tenant_id=\"...\",\n    comment=\"A notification integration.\",\n    direction=\"OUTBOUND\",\n    enabled=True,\n    notification_provider=\"AWS_SNS\",\n    type=\"QUEUE\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var integration = new Snowflake.NotificationIntegration(\"integration\", new Snowflake.NotificationIntegrationArgs\n        {\n            AwsSnsRoleArn = \"...\",\n            AwsSnsTopicArn = \"...\",\n            AwsSqsArn = \"...\",\n            AwsSqsRoleArn = \"...\",\n            AzureStorageQueuePrimaryUri = \"...\",\n            AzureTenantId = \"...\",\n            Comment = \"A notification integration.\",\n            Direction = \"OUTBOUND\",\n            Enabled = true,\n            NotificationProvider = \"AWS_SNS\",\n            Type = \"QUEUE\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewNotificationIntegration(ctx, \"integration\", \u0026snowflake.NotificationIntegrationArgs{\n\t\t\tAwsSnsRoleArn:               pulumi.String(\"...\"),\n\t\t\tAwsSnsTopicArn:              pulumi.String(\"...\"),\n\t\t\tAwsSqsArn:                   pulumi.String(\"...\"),\n\t\t\tAwsSqsRoleArn:               pulumi.String(\"...\"),\n\t\t\tAzureStorageQueuePrimaryUri: pulumi.String(\"...\"),\n\t\t\tAzureTenantId:               pulumi.String(\"...\"),\n\t\t\tComment:                     pulumi.String(\"A notification integration.\"),\n\t\t\tDirection:                   pulumi.String(\"OUTBOUND\"),\n\t\t\tEnabled:                     pulumi.Bool(true),\n\t\t\tNotificationProvider:        pulumi.String(\"AWS_SNS\"),\n\t\t\tType:                        pulumi.String(\"QUEUE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var integration = new NotificationIntegration(\"integration\", NotificationIntegrationArgs.builder()        \n            .awsSnsRoleArn(\"...\")\n            .awsSnsTopicArn(\"...\")\n            .awsSqsArn(\"...\")\n            .awsSqsRoleArn(\"...\")\n            .azureStorageQueuePrimaryUri(\"...\")\n            .azureTenantId(\"...\")\n            .comment(\"A notification integration.\")\n            .direction(\"OUTBOUND\")\n            .enabled(true)\n            .notificationProvider(\"AWS_SNS\")\n            .type(\"QUEUE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  integration:\n    type: snowflake:NotificationIntegration\n    properties:\n      awsSnsRoleArn: '...'\n      awsSnsTopicArn: '...'\n      awsSqsArn: '...'\n      awsSqsRoleArn: '...'\n      azureStorageQueuePrimaryUri: '...'\n      azureTenantId: '...'\n      comment: A notification integration.\n      direction: OUTBOUND\n      enabled: true\n      notificationProvider: AWS_SNS\n      type: QUEUE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/notificationIntegration:NotificationIntegration example name\n```\n\n ",
            "properties": {
                "awsSnsExternalId": {
                    "type": "string",
                    "description": "The external ID that Snowflake will use when assuming the AWS role\n"
                },
                "awsSnsIamUserArn": {
                    "type": "string",
                    "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                },
                "awsSnsRoleArn": {
                    "type": "string",
                    "description": "AWS IAM role ARN for notification integration to assume\n"
                },
                "awsSnsTopicArn": {
                    "type": "string",
                    "description": "AWS SNS Topic ARN for notification integration to connect to\n"
                },
                "awsSqsArn": {
                    "type": "string",
                    "description": "AWS SQS queue ARN for notification integration to connect to\n"
                },
                "awsSqsExternalId": {
                    "type": "string",
                    "description": "The external ID that Snowflake will use when assuming the AWS role\n"
                },
                "awsSqsIamUserArn": {
                    "type": "string",
                    "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                },
                "awsSqsRoleArn": {
                    "type": "string",
                    "description": "AWS IAM role ARN for notification integration to assume\n"
                },
                "azureStorageQueuePrimaryUri": {
                    "type": "string",
                    "description": "The queue ID for the Azure Queue Storage queue created for Event Grid notifications\n"
                },
                "azureTenantId": {
                    "type": "string",
                    "description": "The ID of the Azure Active Directory tenant used for identity management\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A comment for the integration\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the notification integration was created.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction of the cloud messaging with respect to Snowflake (required only for error notifications)\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "gcpPubsubServiceAccount": {
                    "type": "string",
                    "description": "The GCP service account identifier that Snowflake will use when assuming the GCP role\n"
                },
                "gcpPubsubSubscriptionName": {
                    "type": "string",
                    "description": "The subscription id that Snowflake will listen to when using the GCP_PUBSUB provider.\n"
                },
                "name": {
                    "type": "string"
                },
                "notificationProvider": {
                    "type": "string",
                    "description": "The third-party cloud message queuing service (e.g. AZURE_STORAGE_QUEUE, AWS_SQS, AWS_SNS)\n"
                },
                "type": {
                    "type": "string",
                    "description": "A type of integration\n"
                }
            },
            "required": [
                "awsSnsExternalId",
                "awsSnsIamUserArn",
                "awsSqsExternalId",
                "awsSqsIamUserArn",
                "createdOn",
                "gcpPubsubServiceAccount",
                "name"
            ],
            "inputProperties": {
                "awsSnsRoleArn": {
                    "type": "string",
                    "description": "AWS IAM role ARN for notification integration to assume\n"
                },
                "awsSnsTopicArn": {
                    "type": "string",
                    "description": "AWS SNS Topic ARN for notification integration to connect to\n"
                },
                "awsSqsArn": {
                    "type": "string",
                    "description": "AWS SQS queue ARN for notification integration to connect to\n"
                },
                "awsSqsRoleArn": {
                    "type": "string",
                    "description": "AWS IAM role ARN for notification integration to assume\n"
                },
                "azureStorageQueuePrimaryUri": {
                    "type": "string",
                    "description": "The queue ID for the Azure Queue Storage queue created for Event Grid notifications\n"
                },
                "azureTenantId": {
                    "type": "string",
                    "description": "The ID of the Azure Active Directory tenant used for identity management\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A comment for the integration\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction of the cloud messaging with respect to Snowflake (required only for error notifications)\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean"
                },
                "gcpPubsubSubscriptionName": {
                    "type": "string",
                    "description": "The subscription id that Snowflake will listen to when using the GCP_PUBSUB provider.\n"
                },
                "name": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "notificationProvider": {
                    "type": "string",
                    "description": "The third-party cloud message queuing service (e.g. AZURE_STORAGE_QUEUE, AWS_SQS, AWS_SNS)\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "A type of integration\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NotificationIntegration resources.\n",
                "properties": {
                    "awsSnsExternalId": {
                        "type": "string",
                        "description": "The external ID that Snowflake will use when assuming the AWS role\n"
                    },
                    "awsSnsIamUserArn": {
                        "type": "string",
                        "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                    },
                    "awsSnsRoleArn": {
                        "type": "string",
                        "description": "AWS IAM role ARN for notification integration to assume\n"
                    },
                    "awsSnsTopicArn": {
                        "type": "string",
                        "description": "AWS SNS Topic ARN for notification integration to connect to\n"
                    },
                    "awsSqsArn": {
                        "type": "string",
                        "description": "AWS SQS queue ARN for notification integration to connect to\n"
                    },
                    "awsSqsExternalId": {
                        "type": "string",
                        "description": "The external ID that Snowflake will use when assuming the AWS role\n"
                    },
                    "awsSqsIamUserArn": {
                        "type": "string",
                        "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                    },
                    "awsSqsRoleArn": {
                        "type": "string",
                        "description": "AWS IAM role ARN for notification integration to assume\n"
                    },
                    "azureStorageQueuePrimaryUri": {
                        "type": "string",
                        "description": "The queue ID for the Azure Queue Storage queue created for Event Grid notifications\n"
                    },
                    "azureTenantId": {
                        "type": "string",
                        "description": "The ID of the Azure Active Directory tenant used for identity management\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A comment for the integration\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the notification integration was created.\n"
                    },
                    "direction": {
                        "type": "string",
                        "description": "Direction of the cloud messaging with respect to Snowflake (required only for error notifications)\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "gcpPubsubServiceAccount": {
                        "type": "string",
                        "description": "The GCP service account identifier that Snowflake will use when assuming the GCP role\n"
                    },
                    "gcpPubsubSubscriptionName": {
                        "type": "string",
                        "description": "The subscription id that Snowflake will listen to when using the GCP_PUBSUB provider.\n"
                    },
                    "name": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "notificationProvider": {
                        "type": "string",
                        "description": "The third-party cloud message queuing service (e.g. AZURE_STORAGE_QUEUE, AWS_SQS, AWS_SNS)\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "A type of integration\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/oauthIntegration:OauthIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst tableauDesktop = new snowflake.OauthIntegration(\"tableau_desktop\", {\n    blockedRolesLists: [\"SYSADMIN\"],\n    enabled: true,\n    oauthClient: \"TABLEAU_DESKTOP\",\n    oauthIssueRefreshTokens: true,\n    oauthRefreshTokenValidity: 3600,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntableau_desktop = snowflake.OauthIntegration(\"tableauDesktop\",\n    blocked_roles_lists=[\"SYSADMIN\"],\n    enabled=True,\n    oauth_client=\"TABLEAU_DESKTOP\",\n    oauth_issue_refresh_tokens=True,\n    oauth_refresh_token_validity=3600)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var tableauDesktop = new Snowflake.OauthIntegration(\"tableauDesktop\", new Snowflake.OauthIntegrationArgs\n        {\n            BlockedRolesLists = \n            {\n                \"SYSADMIN\",\n            },\n            Enabled = true,\n            OauthClient = \"TABLEAU_DESKTOP\",\n            OauthIssueRefreshTokens = true,\n            OauthRefreshTokenValidity = 3600,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewOauthIntegration(ctx, \"tableauDesktop\", \u0026snowflake.OauthIntegrationArgs{\n\t\t\tBlockedRolesLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"SYSADMIN\"),\n\t\t\t},\n\t\t\tEnabled:                   pulumi.Bool(true),\n\t\t\tOauthClient:               pulumi.String(\"TABLEAU_DESKTOP\"),\n\t\t\tOauthIssueRefreshTokens:   pulumi.Bool(true),\n\t\t\tOauthRefreshTokenValidity: pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var tableauDesktop = new OauthIntegration(\"tableauDesktop\", OauthIntegrationArgs.builder()        \n            .blockedRolesLists(\"SYSADMIN\")\n            .enabled(true)\n            .oauthClient(\"TABLEAU_DESKTOP\")\n            .oauthIssueRefreshTokens(true)\n            .oauthRefreshTokenValidity(3600)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  tableauDesktop:\n    type: snowflake:OauthIntegration\n    properties:\n      blockedRolesLists:\n        - SYSADMIN\n      enabled: true\n      oauthClient: TABLEAU_DESKTOP\n      oauthIssueRefreshTokens: true\n      oauthRefreshTokenValidity: 3600\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/oauthIntegration:OauthIntegration example name\n```\n\n ",
            "properties": {
                "blockedRolesLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of roles that a user cannot explicitly consent to using after authenticating. Do not include ACCOUNTADMIN, ORGADMIN\nor SECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the OAuth integration.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the OAuth integration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this OAuth integration is enabled or disabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the OAuth integration. This name follows the rules for Object Identifiers. The name should be\nunique among security integrations in your account.\n"
                },
                "oauthClient": {
                    "type": "string",
                    "description": "Specifies the OAuth client type.\n"
                },
                "oauthIssueRefreshTokens": {
                    "type": "boolean",
                    "description": "Specifies whether to allow the client to exchange a refresh token for an access token when the current access token has\nexpired.\n"
                },
                "oauthRefreshTokenValidity": {
                    "type": "integer",
                    "description": "Specifies how long refresh tokens should be valid (in seconds). OAUTH_ISSUE_REFRESH_TOKENS must be set to TRUE.\n"
                },
                "oauthUseSecondaryRoles": {
                    "type": "string",
                    "description": "Specifies whether default secondary roles set in the user properties are activated by default in the session being\nopened.\n"
                }
            },
            "required": [
                "createdOn",
                "name",
                "oauthClient"
            ],
            "inputProperties": {
                "blockedRolesLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of roles that a user cannot explicitly consent to using after authenticating. Do not include ACCOUNTADMIN, ORGADMIN\nor SECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the OAuth integration.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this OAuth integration is enabled or disabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the OAuth integration. This name follows the rules for Object Identifiers. The name should be\nunique among security integrations in your account.\n",
                    "willReplaceOnChanges": true
                },
                "oauthClient": {
                    "type": "string",
                    "description": "Specifies the OAuth client type.\n"
                },
                "oauthIssueRefreshTokens": {
                    "type": "boolean",
                    "description": "Specifies whether to allow the client to exchange a refresh token for an access token when the current access token has\nexpired.\n"
                },
                "oauthRefreshTokenValidity": {
                    "type": "integer",
                    "description": "Specifies how long refresh tokens should be valid (in seconds). OAUTH_ISSUE_REFRESH_TOKENS must be set to TRUE.\n"
                },
                "oauthUseSecondaryRoles": {
                    "type": "string",
                    "description": "Specifies whether default secondary roles set in the user properties are activated by default in the session being\nopened.\n"
                }
            },
            "requiredInputs": [
                "oauthClient"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OauthIntegration resources.\n",
                "properties": {
                    "blockedRolesLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of roles that a user cannot explicitly consent to using after authenticating. Do not include ACCOUNTADMIN, ORGADMIN\nor SECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the OAuth integration.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the OAuth integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether this OAuth integration is enabled or disabled.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the OAuth integration. This name follows the rules for Object Identifiers. The name should be\nunique among security integrations in your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "oauthClient": {
                        "type": "string",
                        "description": "Specifies the OAuth client type.\n"
                    },
                    "oauthIssueRefreshTokens": {
                        "type": "boolean",
                        "description": "Specifies whether to allow the client to exchange a refresh token for an access token when the current access token has\nexpired.\n"
                    },
                    "oauthRefreshTokenValidity": {
                        "type": "integer",
                        "description": "Specifies how long refresh tokens should be valid (in seconds). OAUTH_ISSUE_REFRESH_TOKENS must be set to TRUE.\n"
                    },
                    "oauthUseSecondaryRoles": {
                        "type": "string",
                        "description": "Specifies whether default secondary roles set in the user properties are activated by default in the session being\nopened.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/pipe:Pipe": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst pipe = new snowflake.Pipe(\"pipe\", {\n    autoIngest: false,\n    awsSnsTopicArn: \"...\",\n    comment: \"A pipe.\",\n    copyStatement: \"copy into mytable from @mystage\",\n    database: \"db\",\n    notificationChannel: \"...\",\n    owner: \"role1\",\n    schema: \"schema\",\n});\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var pipe = new Pipe(\"pipe\", PipeArgs.builder()        \n            .autoIngest(false)\n            .awsSnsTopicArn(\"...\")\n            .comment(\"A pipe.\")\n            .copyStatement(\"copy into mytable from @mystage\")\n            .database(\"db\")\n            .notificationChannel(\"...\")\n            .owner(\"role1\")\n            .schema(\"schema\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pipe:\n    type: snowflake:Pipe\n    properties:\n      autoIngest: false\n      awsSnsTopicArn: '...'\n      comment: A pipe.\n      copyStatement: copy into mytable from @mystage\n      database: db\n      notificationChannel: '...'\n      owner: role1\n      schema: schema\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | pipe name\n\n```sh\n $ pulumi import snowflake:index/pipe:Pipe example 'dbName|schemaName|pipeName'\n```\n\n ",
            "properties": {
                "autoIngest": {
                    "type": "boolean",
                    "description": "Specifies a auto_ingest param for the pipe.\n"
                },
                "awsSnsTopicArn": {
                    "type": "string",
                    "description": "Specifies the Amazon Resource Name (ARN) for the SNS topic for your S3 bucket.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the pipe.\n"
                },
                "copyStatement": {
                    "type": "string",
                    "description": "Specifies the copy statement for the pipe.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the pipe.\n"
                },
                "errorIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the notification integration used for error notifications.\n"
                },
                "integration": {
                    "type": "string",
                    "description": "Specifies an integration for the pipe.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the pipe; must be unique for the database and schema in which the pipe is created.\n"
                },
                "notificationChannel": {
                    "type": "string",
                    "description": "Amazon Resource Name of the Amazon SQS queue for the stage named in the DEFINITION column.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Name of the role that owns the pipe.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the pipe.\n"
                }
            },
            "required": [
                "copyStatement",
                "database",
                "name",
                "notificationChannel",
                "owner",
                "schema"
            ],
            "inputProperties": {
                "autoIngest": {
                    "type": "boolean",
                    "description": "Specifies a auto_ingest param for the pipe.\n",
                    "willReplaceOnChanges": true
                },
                "awsSnsTopicArn": {
                    "type": "string",
                    "description": "Specifies the Amazon Resource Name (ARN) for the SNS topic for your S3 bucket.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the pipe.\n"
                },
                "copyStatement": {
                    "type": "string",
                    "description": "Specifies the copy statement for the pipe.\n",
                    "willReplaceOnChanges": true
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the pipe.\n",
                    "willReplaceOnChanges": true
                },
                "errorIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the notification integration used for error notifications.\n"
                },
                "integration": {
                    "type": "string",
                    "description": "Specifies an integration for the pipe.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the pipe; must be unique for the database and schema in which the pipe is created.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the pipe.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "copyStatement",
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Pipe resources.\n",
                "properties": {
                    "autoIngest": {
                        "type": "boolean",
                        "description": "Specifies a auto_ingest param for the pipe.\n",
                        "willReplaceOnChanges": true
                    },
                    "awsSnsTopicArn": {
                        "type": "string",
                        "description": "Specifies the Amazon Resource Name (ARN) for the SNS topic for your S3 bucket.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the pipe.\n"
                    },
                    "copyStatement": {
                        "type": "string",
                        "description": "Specifies the copy statement for the pipe.\n",
                        "willReplaceOnChanges": true
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the pipe.\n",
                        "willReplaceOnChanges": true
                    },
                    "errorIntegration": {
                        "type": "string",
                        "description": "Specifies the name of the notification integration used for error notifications.\n"
                    },
                    "integration": {
                        "type": "string",
                        "description": "Specifies an integration for the pipe.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the pipe; must be unique for the database and schema in which the pipe is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "notificationChannel": {
                        "type": "string",
                        "description": "Amazon Resource Name of the Amazon SQS queue for the stage named in the DEFINITION column.\n"
                    },
                    "owner": {
                        "type": "string",
                        "description": "Name of the role that owns the pipe.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the pipe.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/pipeGrant:PipeGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.PipeGrant(\"grant\", {\n    databaseName: \"db\",\n    onFuture: false,\n    pipeName: \"pipe\",\n    privilege: \"operate\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.PipeGrant(\"grant\",\n    database_name=\"db\",\n    on_future=False,\n    pipe_name=\"pipe\",\n    privilege=\"operate\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.PipeGrant(\"grant\", new Snowflake.PipeGrantArgs\n        {\n            DatabaseName = \"db\",\n            OnFuture = false,\n            PipeName = \"pipe\",\n            Privilege = \"operate\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewPipeGrant(ctx, \"grant\", \u0026snowflake.PipeGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"db\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPipeName:     pulumi.String(\"pipe\"),\n\t\t\tPrivilege:    pulumi.String(\"operate\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new PipeGrant(\"grant\", PipeGrantArgs.builder()        \n            .databaseName(\"db\")\n            .onFuture(false)\n            .pipeName(\"pipe\")\n            .privilege(\"operate\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:PipeGrant\n    properties:\n      databaseName: db\n      onFuture: false\n      pipeName: pipe\n      privilege: operate\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | pipe name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/pipeGrant:PipeGrant example 'dbName|schemaName|pipeName|OPERATE|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future pipes on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future pipes in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future pipes in the given database. The pipe_name\nfield must be unset in order to use on_future.\n"
                },
                "pipeName": {
                    "type": "string",
                    "description": "The name of the pipe on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future pipe.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future pipes on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future pipes on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future pipes in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future pipes in the given database. The pipe_name\nfield must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "pipeName": {
                    "type": "string",
                    "description": "The name of the pipe on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future pipe.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future pipes on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PipeGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future pipes on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future pipes in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future pipes in the given database. The pipe_name\nfield must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "pipeName": {
                        "type": "string",
                        "description": "The name of the pipe on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future pipe.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future pipes on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/procedure:Procedure": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var db = new Database(\"db\", DatabaseArgs.builder()        \n            .dataRetentionDays(1)\n            .build());\n\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .database(db.name())\n            .dataRetentionDays(1)\n            .build());\n\n        var proc = new Procedure(\"proc\", ProcedureArgs.builder()        \n            .database(db.name())\n            .schema(schema.name())\n            .language(\"JAVASCRIPT\")\n            .arguments(            \n                ProcedureArgumentArgs.builder()\n                    .name(\"arg1\")\n                    .type(\"varchar\")\n                    .build(),\n                ProcedureArgumentArgs.builder()\n                    .name(\"arg2\")\n                    .type(\"DATE\")\n                    .build())\n            .comment(\"Procedure with 2 arguments\")\n            .returnType(\"VARCHAR\")\n            .executeAs(\"CALLER\")\n            .returnBehavior(\"IMMUTABLE\")\n            .nullInputBehavior(\"RETURNS NULL ON NULL INPUT\")\n            .statement(\"\"\"\nvar X=1\nreturn X\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  db:\n    type: snowflake:Database\n    properties:\n      dataRetentionDays: 1\n  schema:\n    type: snowflake:Schema\n    properties:\n      database: ${db.name}\n      dataRetentionDays: 1\n  proc:\n    type: snowflake:Procedure\n    properties:\n      database: ${db.name}\n      schema: ${schema.name}\n      language: JAVASCRIPT\n      arguments:\n        - name: arg1\n          type: varchar\n        - name: arg2\n          type: DATE\n      comment: Procedure with 2 arguments\n      returnType: VARCHAR\n      executeAs: CALLER\n      returnBehavior: IMMUTABLE\n      nullInputBehavior: RETURNS NULL ON NULL INPUT\n      statement: |\n        var X=1\n        return X\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | stored procedure name | \u003clist of arg types, separated with '-'\u003e\n\n```sh\n $ pulumi import snowflake:index/procedure:Procedure example 'dbName|schemaName|procedureName|varchar-varchar-varchar'\n```\n\n ",
            "properties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ProcedureArgument:ProcedureArgument"
                    },
                    "description": "List of the arguments for the procedure\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the procedure.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the procedure. Don't use the | character.\n"
                },
                "executeAs": {
                    "type": "string",
                    "description": "Sets execute context - see caller's rights and owner's rights\n"
                },
                "language": {
                    "type": "string",
                    "description": "Specifies the language of the stored procedure code.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the procedure; does not have to be unique for the schema in which the procedure is created.\nDon't use the | character.\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the procedure when called with null inputs.\n"
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n"
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the procedure\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the procedure. Don't use the | character.\n"
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the javascript code used to create the procedure.\n"
                }
            },
            "required": [
                "database",
                "name",
                "returnType",
                "schema",
                "statement"
            ],
            "inputProperties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ProcedureArgument:ProcedureArgument"
                    },
                    "description": "List of the arguments for the procedure\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the procedure.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the procedure. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "executeAs": {
                    "type": "string",
                    "description": "Sets execute context - see caller's rights and owner's rights\n"
                },
                "language": {
                    "type": "string",
                    "description": "Specifies the language of the stored procedure code.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the procedure; does not have to be unique for the schema in which the procedure is created.\nDon't use the | character.\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the procedure when called with null inputs.\n",
                    "willReplaceOnChanges": true
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n",
                    "willReplaceOnChanges": true
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the procedure\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the procedure. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the javascript code used to create the procedure.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "returnType",
                "schema",
                "statement"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Procedure resources.\n",
                "properties": {
                    "arguments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ProcedureArgument:ProcedureArgument"
                        },
                        "description": "List of the arguments for the procedure\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the procedure.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the procedure. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "executeAs": {
                        "type": "string",
                        "description": "Sets execute context - see caller's rights and owner's rights\n"
                    },
                    "language": {
                        "type": "string",
                        "description": "Specifies the language of the stored procedure code.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the procedure; does not have to be unique for the schema in which the procedure is created.\nDon't use the | character.\n"
                    },
                    "nullInputBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the procedure when called with null inputs.\n",
                        "willReplaceOnChanges": true
                    },
                    "returnBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the function when returning results\n",
                        "willReplaceOnChanges": true
                    },
                    "returnType": {
                        "type": "string",
                        "description": "The return type of the procedure\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the procedure. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "statement": {
                        "type": "string",
                        "description": "Specifies the javascript code used to create the procedure.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/procedureGrant:ProcedureGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.ProcedureGrant(\"grant\", {\n    arguments: [\n        {\n            name: \"a\",\n            type: \"array\",\n        },\n        {\n            name: \"b\",\n            type: \"string\",\n        },\n    ],\n    databaseName: \"db\",\n    onFuture: false,\n    privilege: \"select\",\n    procedureName: \"procedure\",\n    returnType: \"string\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.ProcedureGrant(\"grant\",\n    arguments=[\n        snowflake.ProcedureGrantArgumentArgs(\n            name=\"a\",\n            type=\"array\",\n        ),\n        snowflake.ProcedureGrantArgumentArgs(\n            name=\"b\",\n            type=\"string\",\n        ),\n    ],\n    database_name=\"db\",\n    on_future=False,\n    privilege=\"select\",\n    procedure_name=\"procedure\",\n    return_type=\"string\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.ProcedureGrant(\"grant\", new Snowflake.ProcedureGrantArgs\n        {\n            Arguments = \n            {\n                new Snowflake.Inputs.ProcedureGrantArgumentArgs\n                {\n                    Name = \"a\",\n                    Type = \"array\",\n                },\n                new Snowflake.Inputs.ProcedureGrantArgumentArgs\n                {\n                    Name = \"b\",\n                    Type = \"string\",\n                },\n            },\n            DatabaseName = \"db\",\n            OnFuture = false,\n            Privilege = \"select\",\n            ProcedureName = \"procedure\",\n            ReturnType = \"string\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            Shares = \n            {\n                \"share1\",\n                \"share2\",\n            },\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewProcedureGrant(ctx, \"grant\", \u0026snowflake.ProcedureGrantArgs{\n\t\t\tArguments: ProcedureGrantArgumentArray{\n\t\t\t\t\u0026ProcedureGrantArgumentArgs{\n\t\t\t\t\tName: pulumi.String(\"a\"),\n\t\t\t\t\tType: pulumi.String(\"array\"),\n\t\t\t\t},\n\t\t\t\t\u0026ProcedureGrantArgumentArgs{\n\t\t\t\t\tName: pulumi.String(\"b\"),\n\t\t\t\t\tType: pulumi.String(\"string\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDatabaseName:  pulumi.String(\"db\"),\n\t\t\tOnFuture:      pulumi.Bool(false),\n\t\t\tPrivilege:     pulumi.String(\"select\"),\n\t\t\tProcedureName: pulumi.String(\"procedure\"),\n\t\t\tReturnType:    pulumi.String(\"string\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new ProcedureGrant(\"grant\", ProcedureGrantArgs.builder()        \n            .arguments(            \n                ProcedureGrantArgumentArgs.builder()\n                    .name(\"a\")\n                    .type(\"array\")\n                    .build(),\n                ProcedureGrantArgumentArgs.builder()\n                    .name(\"b\")\n                    .type(\"string\")\n                    .build())\n            .databaseName(\"db\")\n            .onFuture(false)\n            .privilege(\"select\")\n            .procedureName(\"procedure\")\n            .returnType(\"string\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:ProcedureGrant\n    properties:\n      arguments:\n        - name: a\n          type: array\n        - name: b\n          type: string\n      databaseName: db\n      onFuture: false\n      privilege: select\n      procedureName: procedure\n      returnType: string\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | procedure signature | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/procedureGrant:ProcedureGrant example 'dbName|schemaName|procedureName(ARG1 ARG1TYPE, ARG2 ARG2TYPE):RETURNTYPE|USAGE|false'\n```\n\n ",
            "properties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ProcedureGrantArgument:ProcedureGrantArgument"
                    },
                    "description": "List of the arguments for the procedure (must be present if procedure has arguments and procedure_name is present)\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future procedures on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future procedures in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future procedures in the given database. The\nprocedure_name and shares fields must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future procedure.\n"
                },
                "procedureName": {
                    "type": "string",
                    "description": "The name of the procedure on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the procedure (must be present if procedure_name is present)\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future procedures on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "schemaName"
            ],
            "inputProperties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ProcedureGrantArgument:ProcedureGrantArgument"
                    },
                    "description": "List of the arguments for the procedure (must be present if procedure has arguments and procedure_name is present)\n",
                    "willReplaceOnChanges": true
                },
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future procedures on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future procedures in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future procedures in the given database. The\nprocedure_name and shares fields must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future procedure.\n",
                    "willReplaceOnChanges": true
                },
                "procedureName": {
                    "type": "string",
                    "description": "The name of the procedure on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the procedure (must be present if procedure_name is present)\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future procedures on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProcedureGrant resources.\n",
                "properties": {
                    "arguments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ProcedureGrantArgument:ProcedureGrantArgument"
                        },
                        "description": "List of the arguments for the procedure (must be present if procedure has arguments and procedure_name is present)\n",
                        "willReplaceOnChanges": true
                    },
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future procedures on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future procedures in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future procedures in the given database. The\nprocedure_name and shares fields must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future procedure.\n",
                        "willReplaceOnChanges": true
                    },
                    "procedureName": {
                        "type": "string",
                        "description": "The name of the procedure on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "returnType": {
                        "type": "string",
                        "description": "The return type of the procedure (must be present if procedure_name is present)\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future procedures on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/resourceMonitor:ResourceMonitor": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst monitor = new snowflake.ResourceMonitor(\"monitor\", {\n    creditQuota: 100,\n    endTimestamp: \"2021-12-07 00:00\",\n    frequency: \"DAILY\",\n    notifyTriggers: [40],\n    startTimestamp: \"2020-12-07 00:00\",\n    suspendImmediateTriggers: [90],\n    suspendTriggers: [50],\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nmonitor = snowflake.ResourceMonitor(\"monitor\",\n    credit_quota=100,\n    end_timestamp=\"2021-12-07 00:00\",\n    frequency=\"DAILY\",\n    notify_triggers=[40],\n    start_timestamp=\"2020-12-07 00:00\",\n    suspend_immediate_triggers=[90],\n    suspend_triggers=[50])\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var monitor = new Snowflake.ResourceMonitor(\"monitor\", new Snowflake.ResourceMonitorArgs\n        {\n            CreditQuota = 100,\n            EndTimestamp = \"2021-12-07 00:00\",\n            Frequency = \"DAILY\",\n            NotifyTriggers = \n            {\n                40,\n            },\n            StartTimestamp = \"2020-12-07 00:00\",\n            SuspendImmediateTriggers = \n            {\n                90,\n            },\n            SuspendTriggers = \n            {\n                50,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewResourceMonitor(ctx, \"monitor\", \u0026snowflake.ResourceMonitorArgs{\n\t\t\tCreditQuota:  pulumi.Int(100),\n\t\t\tEndTimestamp: pulumi.String(\"2021-12-07 00:00\"),\n\t\t\tFrequency:    pulumi.String(\"DAILY\"),\n\t\t\tNotifyTriggers: pulumi.IntArray{\n\t\t\t\tpulumi.Int(40),\n\t\t\t},\n\t\t\tStartTimestamp: pulumi.String(\"2020-12-07 00:00\"),\n\t\t\tSuspendImmediateTriggers: pulumi.IntArray{\n\t\t\t\tpulumi.Int(90),\n\t\t\t},\n\t\t\tSuspendTriggers: pulumi.IntArray{\n\t\t\t\tpulumi.Int(50),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var monitor = new ResourceMonitor(\"monitor\", ResourceMonitorArgs.builder()        \n            .creditQuota(100)\n            .endTimestamp(\"2021-12-07 00:00\")\n            .frequency(\"DAILY\")\n            .notifyTriggers(40)\n            .startTimestamp(\"2020-12-07 00:00\")\n            .suspendImmediateTriggers(90)\n            .suspendTriggers(50)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  monitor:\n    type: snowflake:ResourceMonitor\n    properties:\n      creditQuota: 100\n      endTimestamp: 2021-12-07 00:00\n      frequency: DAILY\n      notifyTriggers:\n        - 40\n      startTimestamp: 2020-12-07 00:00\n      suspendImmediateTriggers:\n        - 90\n      suspendTriggers:\n        - 50\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/resourceMonitor:ResourceMonitor example\n```\n\n ",
            "properties": {
                "creditQuota": {
                    "type": "integer",
                    "description": "The number of credits allocated monthly to the resource monitor.\n"
                },
                "endTimestamp": {
                    "type": "string",
                    "description": "The date and time when the resource monitor suspends the assigned warehouses.\n"
                },
                "frequency": {
                    "type": "string",
                    "description": "The frequency interval at which the credit usage resets to 0. If you set a frequency for a resource monitor, you must\nalso set START_TIMESTAMP.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the resource monitor; must be unique for your account.\n"
                },
                "notifyTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to send an alert to subscribed users.\n"
                },
                "setForAccount": {
                    "type": "boolean",
                    "description": "Specifies whether the resource monitor should be applied globally to your Snowflake account.\n"
                },
                "startTimestamp": {
                    "type": "string",
                    "description": "The date and time when the resource monitor starts monitoring credit usage for the assigned warehouses.\n"
                },
                "suspendImmediateTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to immediately suspend all warehouses.\n"
                },
                "suspendTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to suspend all warehouses.\n"
                },
                "warehouses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of warehouses to apply the resource monitor to.\n"
                }
            },
            "required": [
                "creditQuota",
                "frequency",
                "name",
                "startTimestamp"
            ],
            "inputProperties": {
                "creditQuota": {
                    "type": "integer",
                    "description": "The number of credits allocated monthly to the resource monitor.\n",
                    "willReplaceOnChanges": true
                },
                "endTimestamp": {
                    "type": "string",
                    "description": "The date and time when the resource monitor suspends the assigned warehouses.\n",
                    "willReplaceOnChanges": true
                },
                "frequency": {
                    "type": "string",
                    "description": "The frequency interval at which the credit usage resets to 0. If you set a frequency for a resource monitor, you must\nalso set START_TIMESTAMP.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the resource monitor; must be unique for your account.\n",
                    "willReplaceOnChanges": true
                },
                "notifyTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to send an alert to subscribed users.\n",
                    "willReplaceOnChanges": true
                },
                "setForAccount": {
                    "type": "boolean",
                    "description": "Specifies whether the resource monitor should be applied globally to your Snowflake account.\n",
                    "willReplaceOnChanges": true
                },
                "startTimestamp": {
                    "type": "string",
                    "description": "The date and time when the resource monitor starts monitoring credit usage for the assigned warehouses.\n",
                    "willReplaceOnChanges": true
                },
                "suspendImmediateTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to immediately suspend all warehouses.\n",
                    "willReplaceOnChanges": true
                },
                "suspendTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to suspend all warehouses.\n",
                    "willReplaceOnChanges": true
                },
                "warehouses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of warehouses to apply the resource monitor to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourceMonitor resources.\n",
                "properties": {
                    "creditQuota": {
                        "type": "integer",
                        "description": "The number of credits allocated monthly to the resource monitor.\n",
                        "willReplaceOnChanges": true
                    },
                    "endTimestamp": {
                        "type": "string",
                        "description": "The date and time when the resource monitor suspends the assigned warehouses.\n",
                        "willReplaceOnChanges": true
                    },
                    "frequency": {
                        "type": "string",
                        "description": "The frequency interval at which the credit usage resets to 0. If you set a frequency for a resource monitor, you must\nalso set START_TIMESTAMP.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Identifier for the resource monitor; must be unique for your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "notifyTriggers": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of percentage thresholds at which to send an alert to subscribed users.\n",
                        "willReplaceOnChanges": true
                    },
                    "setForAccount": {
                        "type": "boolean",
                        "description": "Specifies whether the resource monitor should be applied globally to your Snowflake account.\n",
                        "willReplaceOnChanges": true
                    },
                    "startTimestamp": {
                        "type": "string",
                        "description": "The date and time when the resource monitor starts monitoring credit usage for the assigned warehouses.\n",
                        "willReplaceOnChanges": true
                    },
                    "suspendImmediateTriggers": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of percentage thresholds at which to immediately suspend all warehouses.\n",
                        "willReplaceOnChanges": true
                    },
                    "suspendTriggers": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of percentage thresholds at which to suspend all warehouses.\n",
                        "willReplaceOnChanges": true
                    },
                    "warehouses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of warehouses to apply the resource monitor to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/resourceMonitorGrant:ResourceMonitorGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.MonitorGrant(\"grant\", {\n    monitorName: \"monitor\",\n    privilege: \"MODIFY\",\n    roles: [\"role1\"],\n    withGrantOption: false,\n});\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/resourceMonitorGrant:ResourceMonitorGrant example name\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "monitorName": {
                    "type": "string",
                    "description": "Identifier for the resource monitor; must be unique for your account.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the resource monitor.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "monitorName"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "monitorName": {
                    "type": "string",
                    "description": "Identifier for the resource monitor; must be unique for your account.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the resource monitor.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "monitorName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourceMonitorGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "monitorName": {
                        "type": "string",
                        "description": "Identifier for the resource monitor; must be unique for your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the resource monitor.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/role:Role": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst role = new snowflake.Role(\"role\", {\n    comment: \"A role.\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nrole = snowflake.Role(\"role\", comment=\"A role.\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var role = new Snowflake.Role(\"role\", new Snowflake.RoleArgs\n        {\n            Comment = \"A role.\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewRole(ctx, \"role\", \u0026snowflake.RoleArgs{\n\t\t\tComment: pulumi.String(\"A role.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var role = new Role(\"role\", RoleArgs.builder()        \n            .comment(\"A role.\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  role:\n    type: snowflake:Role\n    properties:\n      comment: A role.\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/role:Role example roleName\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/RoleTag:RoleTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/RoleTag:RoleTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "comment": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/RoleTag:RoleTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/roleGrants:RoleGrants": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst role = new snowflake.Role(\"role\", {\n    comment: \"for testing\",\n});\nconst user = new snowflake.User(\"user\", {\n    comment: \"for testing\",\n});\nconst user2 = new snowflake.User(\"user2\", {\n    comment: \"for testing\",\n});\nconst otherRole = new snowflake.Role(\"other_role\", {});\nconst grants = new snowflake.RoleGrants(\"grants\", {\n    roleName: role.name,\n    roles: [otherRole.name],\n    users: [\n        user.name,\n        user2.name,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nrole = snowflake.Role(\"role\", comment=\"for testing\")\nuser = snowflake.User(\"user\", comment=\"for testing\")\nuser2 = snowflake.User(\"user2\", comment=\"for testing\")\nother_role = snowflake.Role(\"otherRole\")\ngrants = snowflake.RoleGrants(\"grants\",\n    role_name=role.name,\n    roles=[other_role.name],\n    users=[\n        user.name,\n        user2.name,\n    ])\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var role = new Snowflake.Role(\"role\", new Snowflake.RoleArgs\n        {\n            Comment = \"for testing\",\n        });\n        var user = new Snowflake.User(\"user\", new Snowflake.UserArgs\n        {\n            Comment = \"for testing\",\n        });\n        var user2 = new Snowflake.User(\"user2\", new Snowflake.UserArgs\n        {\n            Comment = \"for testing\",\n        });\n        var otherRole = new Snowflake.Role(\"otherRole\", new Snowflake.RoleArgs\n        {\n        });\n        var grants = new Snowflake.RoleGrants(\"grants\", new Snowflake.RoleGrantsArgs\n        {\n            RoleName = role.Name,\n            Roles = \n            {\n                otherRole.Name,\n            },\n            Users = \n            {\n                user.Name,\n                user2.Name,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trole, err := snowflake.NewRole(ctx, \"role\", \u0026snowflake.RoleArgs{\n\t\t\tComment: pulumi.String(\"for testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := snowflake.NewUser(ctx, \"user\", \u0026snowflake.UserArgs{\n\t\t\tComment: pulumi.String(\"for testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser2, err := snowflake.NewUser(ctx, \"user2\", \u0026snowflake.UserArgs{\n\t\t\tComment: pulumi.String(\"for testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\totherRole, err := snowflake.NewRole(ctx, \"otherRole\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewRoleGrants(ctx, \"grants\", \u0026snowflake.RoleGrantsArgs{\n\t\t\tRoleName: role.Name,\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\totherRole.Name,\n\t\t\t},\n\t\t\tUsers: pulumi.StringArray{\n\t\t\t\tuser.Name,\n\t\t\t\tuser2.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var role = new Role(\"role\", RoleArgs.builder()        \n            .comment(\"for testing\")\n            .build());\n\n        var user = new User(\"user\", UserArgs.builder()        \n            .comment(\"for testing\")\n            .build());\n\n        var user2 = new User(\"user2\", UserArgs.builder()        \n            .comment(\"for testing\")\n            .build());\n\n        var otherRole = new Role(\"otherRole\");\n\n        var grants = new RoleGrants(\"grants\", RoleGrantsArgs.builder()        \n            .roleName(role.name())\n            .roles(otherRole.name())\n            .users(            \n                user.name(),\n                user2.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  role:\n    type: snowflake:Role\n    properties:\n      comment: for testing\n  user:\n    type: snowflake:User\n    properties:\n      comment: for testing\n  user2:\n    type: snowflake:User\n    properties:\n      comment: for testing\n  otherRole:\n    type: snowflake:Role\n  grants:\n    type: snowflake:RoleGrants\n    properties:\n      roleName: ${role.name}\n      roles:\n        - ${otherRole.name}\n      users:\n        - ${user.name}\n        - ${user2.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/roleGrants:RoleGrants example rolename\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role we are granting.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants role to this specified role.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants role to this specified user.\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role we are granting.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants role to this specified role.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants role to this specified user.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RoleGrants resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role we are granting.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants role to this specified role.\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants role to this specified user.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/roleOwnershipGrant:RoleOwnershipGrant": {
            "properties": {
                "currentGrants": {
                    "type": "string",
                    "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to\na new role.\n"
                },
                "onRoleName": {
                    "type": "string",
                    "description": "The name of the role ownership is granted on.\n"
                },
                "toRoleName": {
                    "type": "string",
                    "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                }
            },
            "required": [
                "onRoleName",
                "toRoleName"
            ],
            "inputProperties": {
                "currentGrants": {
                    "type": "string",
                    "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to\na new role.\n"
                },
                "onRoleName": {
                    "type": "string",
                    "description": "The name of the role ownership is granted on.\n"
                },
                "toRoleName": {
                    "type": "string",
                    "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                }
            },
            "requiredInputs": [
                "onRoleName",
                "toRoleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RoleOwnershipGrant resources.\n",
                "properties": {
                    "currentGrants": {
                        "type": "string",
                        "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to\na new role.\n"
                    },
                    "onRoleName": {
                        "type": "string",
                        "description": "The name of the role ownership is granted on.\n"
                    },
                    "toRoleName": {
                        "type": "string",
                        "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/rowAccessPolicy:RowAccessPolicy": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst exampleRowAccessPolicy = new snowflake.RowAccessPolicy(\"example_row_access_policy\", {\n    database: \"EXAMPLE_DB\",\n    rowAccessExpression: \"case when current_role() in ('ANALYST') then true else false end\",\n    schema: \"EXAMPLE_SCHEMA\",\n    signature: {\n        A: \"VARCHAR\",\n        B: \"VARCHAR\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexample_row_access_policy = snowflake.RowAccessPolicy(\"exampleRowAccessPolicy\",\n    database=\"EXAMPLE_DB\",\n    row_access_expression=\"case when current_role() in ('ANALYST') then true else false end\",\n    schema=\"EXAMPLE_SCHEMA\",\n    signature={\n        \"A\": \"VARCHAR\",\n        \"B\": \"VARCHAR\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleRowAccessPolicy = new Snowflake.RowAccessPolicy(\"exampleRowAccessPolicy\", new Snowflake.RowAccessPolicyArgs\n        {\n            Database = \"EXAMPLE_DB\",\n            RowAccessExpression = \"case when current_role() in ('ANALYST') then true else false end\",\n            Schema = \"EXAMPLE_SCHEMA\",\n            Signature = \n            {\n                { \"A\", \"VARCHAR\" },\n                { \"B\", \"VARCHAR\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewRowAccessPolicy(ctx, \"exampleRowAccessPolicy\", \u0026snowflake.RowAccessPolicyArgs{\n\t\t\tDatabase:            pulumi.String(\"EXAMPLE_DB\"),\n\t\t\tRowAccessExpression: pulumi.String(\"case when current_role() in ('ANALYST') then true else false end\"),\n\t\t\tSchema:              pulumi.String(\"EXAMPLE_SCHEMA\"),\n\t\t\tSignature: pulumi.StringMap{\n\t\t\t\t\"A\": pulumi.String(\"VARCHAR\"),\n\t\t\t\t\"B\": pulumi.String(\"VARCHAR\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleRowAccessPolicy = new RowAccessPolicy(\"exampleRowAccessPolicy\", RowAccessPolicyArgs.builder()        \n            .database(\"EXAMPLE_DB\")\n            .rowAccessExpression(\"case when current_role() in ('ANALYST') then true else false end\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .signature(Map.ofEntries(\n                Map.entry(\"A\", \"VARCHAR\"),\n                Map.entry(\"B\", \"VARCHAR\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleRowAccessPolicy:\n    type: snowflake:RowAccessPolicy\n    properties:\n      database: EXAMPLE_DB\n      rowAccessExpression: case when current_role() in ('ANALYST') then true else false end\n      schema: EXAMPLE_SCHEMA\n      signature:\n        A: VARCHAR\n        B: VARCHAR\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | policy name\n\n```sh\n $ pulumi import snowflake:index/rowAccessPolicy:RowAccessPolicy example 'dbName|schemaName|policyName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the row access policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the row access policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the row access policy; must be unique for the database and schema in which the row access\npolicy is created.\n"
                },
                "rowAccessExpression": {
                    "type": "string",
                    "description": "Specifies the SQL expression. The expression can be any boolean-valued SQL expression.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the row access policy.\n"
                },
                "signature": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies signature (arguments) for the row access policy (uppercase and sorted to avoid recreation of resource). A\nsignature specifies a set of attributes that must be considered to determine whether the row is accessible. The\nattribute values come from the database object (e.g. table or view) to be protected by the row access policy.\n"
                }
            },
            "required": [
                "database",
                "name",
                "rowAccessExpression",
                "schema",
                "signature"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the row access policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the row access policy.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the row access policy; must be unique for the database and schema in which the row access\npolicy is created.\n",
                    "willReplaceOnChanges": true
                },
                "rowAccessExpression": {
                    "type": "string",
                    "description": "Specifies the SQL expression. The expression can be any boolean-valued SQL expression.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the row access policy.\n",
                    "willReplaceOnChanges": true
                },
                "signature": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies signature (arguments) for the row access policy (uppercase and sorted to avoid recreation of resource). A\nsignature specifies a set of attributes that must be considered to determine whether the row is accessible. The\nattribute values come from the database object (e.g. table or view) to be protected by the row access policy.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "rowAccessExpression",
                "schema",
                "signature"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RowAccessPolicy resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the row access policy.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the row access policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the row access policy; must be unique for the database and schema in which the row access\npolicy is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "rowAccessExpression": {
                        "type": "string",
                        "description": "Specifies the SQL expression. The expression can be any boolean-valued SQL expression.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the row access policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "signature": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies signature (arguments) for the row access policy (uppercase and sorted to avoid recreation of resource). A\nsignature specifies a set of attributes that must be considered to determine whether the row is accessible. The\nattribute values come from the database object (e.g. table or view) to be protected by the row access policy.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/rowAccessPolicyGrant:RowAccessPolicyGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.RowAccessPolicyGrant(\"grant\", {\n    databaseName: \"db\",\n    privilege: \"APPLY\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    rowAccessPolicyName: \"row_access_policy\",\n    schemaName: \"schema\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.RowAccessPolicyGrant(\"grant\",\n    database_name=\"db\",\n    privilege=\"APPLY\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    row_access_policy_name=\"row_access_policy\",\n    schema_name=\"schema\",\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.RowAccessPolicyGrant(\"grant\", new Snowflake.RowAccessPolicyGrantArgs\n        {\n            DatabaseName = \"db\",\n            Privilege = \"APPLY\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            RowAccessPolicyName = \"row_access_policy\",\n            SchemaName = \"schema\",\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewRowAccessPolicyGrant(ctx, \"grant\", \u0026snowflake.RowAccessPolicyGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"db\"),\n\t\t\tPrivilege:    pulumi.String(\"APPLY\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tRowAccessPolicyName: pulumi.String(\"row_access_policy\"),\n\t\t\tSchemaName:          pulumi.String(\"schema\"),\n\t\t\tWithGrantOption:     pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new RowAccessPolicyGrant(\"grant\", RowAccessPolicyGrantArgs.builder()        \n            .databaseName(\"db\")\n            .privilege(\"APPLY\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .rowAccessPolicyName(\"row_access_policy\")\n            .schemaName(\"schema\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:RowAccessPolicyGrant\n    properties:\n      databaseName: db\n      privilege: APPLY\n      roles:\n        - role1\n        - role2\n      rowAccessPolicyName: row_access_policy\n      schemaName: schema\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | row access policy name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/rowAccessPolicyGrant:RowAccessPolicyGrant example 'dbName|schemaName|rowAccessPolicyName|SELECT|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the row access policy on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the row access policy.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "rowAccessPolicyName": {
                    "type": "string",
                    "description": "The name of the row access policy on which to grant privileges immediately.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the row access policy on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "rowAccessPolicyName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the row access policy on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the row access policy.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "rowAccessPolicyName": {
                    "type": "string",
                    "description": "The name of the row access policy on which to grant privileges immediately.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the row access policy on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "rowAccessPolicyName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RowAccessPolicyGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the row access policy on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the row access policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "rowAccessPolicyName": {
                        "type": "string",
                        "description": "The name of the row access policy on which to grant privileges immediately.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the row access policy on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/samlIntegration:SamlIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst samlIntegration = new snowflake.SamlIntegration(\"saml_integration\", {\n    enabled: true,\n    saml2Issuer: \"test_issuer\",\n    saml2Provider: \"CUSTOM\",\n    saml2SsoUrl: \"https://testsamlissuer.com\",\n    saml2X509Cert: \"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nsaml_integration = snowflake.SamlIntegration(\"samlIntegration\",\n    enabled=True,\n    saml2_issuer=\"test_issuer\",\n    saml2_provider=\"CUSTOM\",\n    saml2_sso_url=\"https://testsamlissuer.com\",\n    saml2_x509_cert=\"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var samlIntegration = new Snowflake.SamlIntegration(\"samlIntegration\", new Snowflake.SamlIntegrationArgs\n        {\n            Enabled = true,\n            Saml2Issuer = \"test_issuer\",\n            Saml2Provider = \"CUSTOM\",\n            Saml2SsoUrl = \"https://testsamlissuer.com\",\n            Saml2X509Cert = \"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewSamlIntegration(ctx, \"samlIntegration\", \u0026snowflake.SamlIntegrationArgs{\n\t\t\tEnabled:       pulumi.Bool(true),\n\t\t\tSaml2Issuer:   pulumi.String(\"test_issuer\"),\n\t\t\tSaml2Provider: pulumi.String(\"CUSTOM\"),\n\t\t\tSaml2SsoUrl:   pulumi.String(\"https://testsamlissuer.com\"),\n\t\t\tSaml2X509Cert: pulumi.String(\"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var samlIntegration = new SamlIntegration(\"samlIntegration\", SamlIntegrationArgs.builder()        \n            .enabled(true)\n            .saml2Issuer(\"test_issuer\")\n            .saml2Provider(\"CUSTOM\")\n            .saml2SsoUrl(\"https://testsamlissuer.com\")\n            .saml2X509Cert(\"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  samlIntegration:\n    type: snowflake:SamlIntegration\n    properties:\n      enabled: true\n      saml2Issuer: test_issuer\n      saml2Provider: CUSTOM\n      saml2SsoUrl: https://testsamlissuer.com\n      saml2X509Cert: MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/samlIntegration:SamlIntegration example name\n```\n\n ",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the SAML integration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this security integration is enabled or disabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the SAML2 integration. This name follows the rules for Object Identifiers. The name should be\nunique among security integrations in your account.\n"
                },
                "saml2DigestMethodsUsed": {
                    "type": "string"
                },
                "saml2EnableSpInitiated": {
                    "type": "boolean",
                    "description": "The Boolean indicating if the Log In With button will be shown on the login page. TRUE: displays the Log in WIth button\non the login page. FALSE: does not display the Log in With button on the login page.\n"
                },
                "saml2ForceAuthn": {
                    "type": "boolean",
                    "description": "The Boolean indicating whether users, during the initial authentication flow, are forced to authenticate again to access\nSnowflake. When set to TRUE, Snowflake sets the ForceAuthn SAML parameter to TRUE in the outgoing request from Snowflake\nto the identity provider. TRUE: forces users to authenticate again to access Snowflake, even if a valid session with the\nidentity provider exists. FALSE: does not force users to authenticate again to access Snowflake.\n"
                },
                "saml2Issuer": {
                    "type": "string",
                    "description": "The string containing the IdP EntityID / Issuer.\n"
                },
                "saml2PostLogoutRedirectUrl": {
                    "type": "string",
                    "description": "The endpoint to which Snowflake redirects users after clicking the Log Out button in the classic Snowflake web\ninterface. Snowflake terminates the Snowflake session upon redirecting to the specified endpoint.\n"
                },
                "saml2Provider": {
                    "type": "string",
                    "description": "The string describing the IdP. One of the following: OKTA, ADFS, Custom.\n"
                },
                "saml2RequestedNameidFormat": {
                    "type": "string",
                    "description": "The SAML NameID format allows Snowflake to set an expectation of the identifying attribute of the user (i.e. SAML\nSubject) in the SAML assertion from the IdP to ensure a valid authentication to Snowflake. If a value is not specified,\nSnowflake sends the urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress value in the authentication request to the\nIdP. NameID must be one of the following values: urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified,\nurn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress, urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName,\nurn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName,\nurn:oasis:names:tc:SAML:2.0:nameid-format:kerberos, urn:oasis:names:tc:SAML:2.0:nameid-format:persistent,\nurn:oasis:names:tc:SAML:2.0:nameid-format:transient .\n"
                },
                "saml2SignRequest": {
                    "type": "boolean",
                    "description": "The Boolean indicating whether SAML requests are signed. TRUE: allows SAML requests to be signed. FALSE: does not allow\nSAML requests to be signed.\n"
                },
                "saml2SignatureMethodsUsed": {
                    "type": "string"
                },
                "saml2SnowflakeAcsUrl": {
                    "type": "string",
                    "description": "The string containing the Snowflake Assertion Consumer Service URL to which the IdP will send its SAML authentication\nresponse back to Snowflake. This property will be set in the SAML authentication request generated by Snowflake when\ninitiating a SAML SSO operation with the IdP. If an incorrect value is specified, Snowflake returns an error message\nindicating the acceptable values to use. Default: https://\u003caccount_locator\u003e.\u003cregion\u003e.snowflakecomputing.com/fed/login\n"
                },
                "saml2SnowflakeIssuerUrl": {
                    "type": "string",
                    "description": "The string containing the EntityID / Issuer for the Snowflake service provider. If an incorrect value is specified,\nSnowflake returns an error message indicating the acceptable values to use.\n"
                },
                "saml2SnowflakeMetadata": {
                    "type": "string",
                    "description": "Metadata created by Snowflake to provide to SAML2 provider.\n"
                },
                "saml2SnowflakeX509Cert": {
                    "type": "string",
                    "description": "The Base64 encoded self-signed certificate generated by Snowflake for use with Encrypting SAML Assertions and Signed\nSAML Requests. You must have at least one of these features (encrypted SAML assertions or signed SAML responses) enabled\nin your Snowflake account to access the certificate value.\n"
                },
                "saml2SpInitiatedLoginPageLabel": {
                    "type": "string",
                    "description": "The string containing the label to display after the Log In With button on the login page.\n"
                },
                "saml2SsoUrl": {
                    "type": "string",
                    "description": "The string containing the IdP SSO URL, where the user should be redirected by Snowflake (the Service Provider) with a\nSAML AuthnRequest message.\n"
                },
                "saml2X509Cert": {
                    "type": "string",
                    "description": "The Base64 encoded IdP signing certificate on a single line without the leading -----BEGIN CERTIFICATE----- and ending\n-----END CERTIFICATE----- markers.\n"
                }
            },
            "required": [
                "createdOn",
                "name",
                "saml2DigestMethodsUsed",
                "saml2Issuer",
                "saml2Provider",
                "saml2SignatureMethodsUsed",
                "saml2SnowflakeAcsUrl",
                "saml2SnowflakeIssuerUrl",
                "saml2SnowflakeMetadata",
                "saml2SnowflakeX509Cert",
                "saml2SsoUrl",
                "saml2X509Cert"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this security integration is enabled or disabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the SAML2 integration. This name follows the rules for Object Identifiers. The name should be\nunique among security integrations in your account.\n",
                    "willReplaceOnChanges": true
                },
                "saml2EnableSpInitiated": {
                    "type": "boolean",
                    "description": "The Boolean indicating if the Log In With button will be shown on the login page. TRUE: displays the Log in WIth button\non the login page. FALSE: does not display the Log in With button on the login page.\n"
                },
                "saml2ForceAuthn": {
                    "type": "boolean",
                    "description": "The Boolean indicating whether users, during the initial authentication flow, are forced to authenticate again to access\nSnowflake. When set to TRUE, Snowflake sets the ForceAuthn SAML parameter to TRUE in the outgoing request from Snowflake\nto the identity provider. TRUE: forces users to authenticate again to access Snowflake, even if a valid session with the\nidentity provider exists. FALSE: does not force users to authenticate again to access Snowflake.\n"
                },
                "saml2Issuer": {
                    "type": "string",
                    "description": "The string containing the IdP EntityID / Issuer.\n"
                },
                "saml2PostLogoutRedirectUrl": {
                    "type": "string",
                    "description": "The endpoint to which Snowflake redirects users after clicking the Log Out button in the classic Snowflake web\ninterface. Snowflake terminates the Snowflake session upon redirecting to the specified endpoint.\n"
                },
                "saml2Provider": {
                    "type": "string",
                    "description": "The string describing the IdP. One of the following: OKTA, ADFS, Custom.\n"
                },
                "saml2RequestedNameidFormat": {
                    "type": "string",
                    "description": "The SAML NameID format allows Snowflake to set an expectation of the identifying attribute of the user (i.e. SAML\nSubject) in the SAML assertion from the IdP to ensure a valid authentication to Snowflake. If a value is not specified,\nSnowflake sends the urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress value in the authentication request to the\nIdP. NameID must be one of the following values: urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified,\nurn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress, urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName,\nurn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName,\nurn:oasis:names:tc:SAML:2.0:nameid-format:kerberos, urn:oasis:names:tc:SAML:2.0:nameid-format:persistent,\nurn:oasis:names:tc:SAML:2.0:nameid-format:transient .\n"
                },
                "saml2SignRequest": {
                    "type": "boolean",
                    "description": "The Boolean indicating whether SAML requests are signed. TRUE: allows SAML requests to be signed. FALSE: does not allow\nSAML requests to be signed.\n"
                },
                "saml2SnowflakeAcsUrl": {
                    "type": "string",
                    "description": "The string containing the Snowflake Assertion Consumer Service URL to which the IdP will send its SAML authentication\nresponse back to Snowflake. This property will be set in the SAML authentication request generated by Snowflake when\ninitiating a SAML SSO operation with the IdP. If an incorrect value is specified, Snowflake returns an error message\nindicating the acceptable values to use. Default: https://\u003caccount_locator\u003e.\u003cregion\u003e.snowflakecomputing.com/fed/login\n"
                },
                "saml2SnowflakeIssuerUrl": {
                    "type": "string",
                    "description": "The string containing the EntityID / Issuer for the Snowflake service provider. If an incorrect value is specified,\nSnowflake returns an error message indicating the acceptable values to use.\n"
                },
                "saml2SnowflakeX509Cert": {
                    "type": "string",
                    "description": "The Base64 encoded self-signed certificate generated by Snowflake for use with Encrypting SAML Assertions and Signed\nSAML Requests. You must have at least one of these features (encrypted SAML assertions or signed SAML responses) enabled\nin your Snowflake account to access the certificate value.\n"
                },
                "saml2SpInitiatedLoginPageLabel": {
                    "type": "string",
                    "description": "The string containing the label to display after the Log In With button on the login page.\n"
                },
                "saml2SsoUrl": {
                    "type": "string",
                    "description": "The string containing the IdP SSO URL, where the user should be redirected by Snowflake (the Service Provider) with a\nSAML AuthnRequest message.\n"
                },
                "saml2X509Cert": {
                    "type": "string",
                    "description": "The Base64 encoded IdP signing certificate on a single line without the leading -----BEGIN CERTIFICATE----- and ending\n-----END CERTIFICATE----- markers.\n"
                }
            },
            "requiredInputs": [
                "saml2Issuer",
                "saml2Provider",
                "saml2SsoUrl",
                "saml2X509Cert"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SamlIntegration resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the SAML integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether this security integration is enabled or disabled.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the SAML2 integration. This name follows the rules for Object Identifiers. The name should be\nunique among security integrations in your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "saml2DigestMethodsUsed": {
                        "type": "string"
                    },
                    "saml2EnableSpInitiated": {
                        "type": "boolean",
                        "description": "The Boolean indicating if the Log In With button will be shown on the login page. TRUE: displays the Log in WIth button\non the login page. FALSE: does not display the Log in With button on the login page.\n"
                    },
                    "saml2ForceAuthn": {
                        "type": "boolean",
                        "description": "The Boolean indicating whether users, during the initial authentication flow, are forced to authenticate again to access\nSnowflake. When set to TRUE, Snowflake sets the ForceAuthn SAML parameter to TRUE in the outgoing request from Snowflake\nto the identity provider. TRUE: forces users to authenticate again to access Snowflake, even if a valid session with the\nidentity provider exists. FALSE: does not force users to authenticate again to access Snowflake.\n"
                    },
                    "saml2Issuer": {
                        "type": "string",
                        "description": "The string containing the IdP EntityID / Issuer.\n"
                    },
                    "saml2PostLogoutRedirectUrl": {
                        "type": "string",
                        "description": "The endpoint to which Snowflake redirects users after clicking the Log Out button in the classic Snowflake web\ninterface. Snowflake terminates the Snowflake session upon redirecting to the specified endpoint.\n"
                    },
                    "saml2Provider": {
                        "type": "string",
                        "description": "The string describing the IdP. One of the following: OKTA, ADFS, Custom.\n"
                    },
                    "saml2RequestedNameidFormat": {
                        "type": "string",
                        "description": "The SAML NameID format allows Snowflake to set an expectation of the identifying attribute of the user (i.e. SAML\nSubject) in the SAML assertion from the IdP to ensure a valid authentication to Snowflake. If a value is not specified,\nSnowflake sends the urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress value in the authentication request to the\nIdP. NameID must be one of the following values: urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified,\nurn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress, urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName,\nurn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName,\nurn:oasis:names:tc:SAML:2.0:nameid-format:kerberos, urn:oasis:names:tc:SAML:2.0:nameid-format:persistent,\nurn:oasis:names:tc:SAML:2.0:nameid-format:transient .\n"
                    },
                    "saml2SignRequest": {
                        "type": "boolean",
                        "description": "The Boolean indicating whether SAML requests are signed. TRUE: allows SAML requests to be signed. FALSE: does not allow\nSAML requests to be signed.\n"
                    },
                    "saml2SignatureMethodsUsed": {
                        "type": "string"
                    },
                    "saml2SnowflakeAcsUrl": {
                        "type": "string",
                        "description": "The string containing the Snowflake Assertion Consumer Service URL to which the IdP will send its SAML authentication\nresponse back to Snowflake. This property will be set in the SAML authentication request generated by Snowflake when\ninitiating a SAML SSO operation with the IdP. If an incorrect value is specified, Snowflake returns an error message\nindicating the acceptable values to use. Default: https://\u003caccount_locator\u003e.\u003cregion\u003e.snowflakecomputing.com/fed/login\n"
                    },
                    "saml2SnowflakeIssuerUrl": {
                        "type": "string",
                        "description": "The string containing the EntityID / Issuer for the Snowflake service provider. If an incorrect value is specified,\nSnowflake returns an error message indicating the acceptable values to use.\n"
                    },
                    "saml2SnowflakeMetadata": {
                        "type": "string",
                        "description": "Metadata created by Snowflake to provide to SAML2 provider.\n"
                    },
                    "saml2SnowflakeX509Cert": {
                        "type": "string",
                        "description": "The Base64 encoded self-signed certificate generated by Snowflake for use with Encrypting SAML Assertions and Signed\nSAML Requests. You must have at least one of these features (encrypted SAML assertions or signed SAML responses) enabled\nin your Snowflake account to access the certificate value.\n"
                    },
                    "saml2SpInitiatedLoginPageLabel": {
                        "type": "string",
                        "description": "The string containing the label to display after the Log In With button on the login page.\n"
                    },
                    "saml2SsoUrl": {
                        "type": "string",
                        "description": "The string containing the IdP SSO URL, where the user should be redirected by Snowflake (the Service Provider) with a\nSAML AuthnRequest message.\n"
                    },
                    "saml2X509Cert": {
                        "type": "string",
                        "description": "The Base64 encoded IdP signing certificate on a single line without the leading -----BEGIN CERTIFICATE----- and ending\n-----END CERTIFICATE----- markers.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/schema:Schema": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst schema = new snowflake.Schema(\"schema\", {\n    comment: \"A schema.\",\n    dataRetentionDays: 1,\n    database: \"db\",\n    isManaged: false,\n    isTransient: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nschema = snowflake.Schema(\"schema\",\n    comment=\"A schema.\",\n    data_retention_days=1,\n    database=\"db\",\n    is_managed=False,\n    is_transient=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var schema = new Snowflake.Schema(\"schema\", new Snowflake.SchemaArgs\n        {\n            Comment = \"A schema.\",\n            DataRetentionDays = 1,\n            Database = \"db\",\n            IsManaged = false,\n            IsTransient = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewSchema(ctx, \"schema\", \u0026snowflake.SchemaArgs{\n\t\t\tComment:           pulumi.String(\"A schema.\"),\n\t\t\tDataRetentionDays: pulumi.Int(1),\n\t\t\tDatabase:          pulumi.String(\"db\"),\n\t\t\tIsManaged:         pulumi.Bool(false),\n\t\t\tIsTransient:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .comment(\"A schema.\")\n            .dataRetentionDays(1)\n            .database(\"db\")\n            .isManaged(false)\n            .isTransient(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  schema:\n    type: snowflake:Schema\n    properties:\n      comment: A schema.\n      dataRetentionDays: 1\n      database: db\n      isManaged: false\n      isTransient: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is dbName | schemaName\n\n```sh\n $ pulumi import snowflake:index/schema:Schema example 'dbName|schemaName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the schema.\n"
                },
                "dataRetentionDays": {
                    "type": "integer",
                    "description": "Specifies the number of days for which Time Travel actions (CLONE and UNDROP) can be performed on the schema, as well as\nspecifying the default Time Travel retention time for all tables created in the schema.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the schema.\n"
                },
                "isManaged": {
                    "type": "boolean",
                    "description": "Specifies a managed schema. Managed access schemas centralize privilege management with the schema owner.\n"
                },
                "isTransient": {
                    "type": "boolean",
                    "description": "Specifies a schema as transient. Transient schemas do not have a Fail-safe period so they do not incur additional\nstorage costs once they leave Time Travel; however, this means they are also not protected by Fail-safe in the event of\na data loss.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the schema; must be unique for the database in which the schema is created.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/SchemaTag:SchemaTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "required": [
                "database",
                "name"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the schema.\n"
                },
                "dataRetentionDays": {
                    "type": "integer",
                    "description": "Specifies the number of days for which Time Travel actions (CLONE and UNDROP) can be performed on the schema, as well as\nspecifying the default Time Travel retention time for all tables created in the schema.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the schema.\n",
                    "willReplaceOnChanges": true
                },
                "isManaged": {
                    "type": "boolean",
                    "description": "Specifies a managed schema. Managed access schemas centralize privilege management with the schema owner.\n"
                },
                "isTransient": {
                    "type": "boolean",
                    "description": "Specifies a schema as transient. Transient schemas do not have a Fail-safe period so they do not incur additional\nstorage costs once they leave Time Travel; however, this means they are also not protected by Fail-safe in the event of\na data loss.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the schema; must be unique for the database in which the schema is created.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/SchemaTag:SchemaTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "requiredInputs": [
                "database"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Schema resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the schema.\n"
                    },
                    "dataRetentionDays": {
                        "type": "integer",
                        "description": "Specifies the number of days for which Time Travel actions (CLONE and UNDROP) can be performed on the schema, as well as\nspecifying the default Time Travel retention time for all tables created in the schema.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the schema.\n",
                        "willReplaceOnChanges": true
                    },
                    "isManaged": {
                        "type": "boolean",
                        "description": "Specifies a managed schema. Managed access schemas centralize privilege management with the schema owner.\n"
                    },
                    "isTransient": {
                        "type": "boolean",
                        "description": "Specifies a schema as transient. Transient schemas do not have a Fail-safe period so they do not incur additional\nstorage costs once they leave Time Travel; however, this means they are also not protected by Fail-safe in the event of\na data loss.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the schema; must be unique for the database in which the schema is created.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/SchemaTag:SchemaTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/schemaGrant:SchemaGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.SchemaGrant(\"grant\", {\n    databaseName: \"db\",\n    onFuture: false,\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.SchemaGrant(\"grant\",\n    database_name=\"db\",\n    on_future=False,\n    privilege=\"USAGE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.SchemaGrant(\"grant\", new Snowflake.SchemaGrantArgs\n        {\n            DatabaseName = \"db\",\n            OnFuture = false,\n            Privilege = \"USAGE\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            Shares = \n            {\n                \"share1\",\n                \"share2\",\n            },\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewSchemaGrant(ctx, \"grant\", \u0026snowflake.SchemaGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"db\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"USAGE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new SchemaGrant(\"grant\", SchemaGrantArgs.builder()        \n            .databaseName(\"db\")\n            .onFuture(false)\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:SchemaGrant\n    properties:\n      databaseName: db\n      onFuture: false\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/schemaGrant:SchemaGrant example 'databaseName|schemaName||MONITOR|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the schema on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true, apply this grant on all future schemas in the given database. The schema_name and shares\nfields must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future schema. Note that if \"OWNERSHIP\" is specified, ensure that the role that\nterraform is using is granted access.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is unset).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the schema on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true, apply this grant on all future schemas in the given database. The schema_name and shares\nfields must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future schema. Note that if \"OWNERSHIP\" is specified, ensure that the role that\nterraform is using is granted access.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is unset).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SchemaGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the schema on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true, apply this grant on all future schemas in the given database. The schema_name and shares\nfields must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future schema. Note that if \"OWNERSHIP\" is specified, ensure that the role that\nterraform is using is granted access.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is unset).\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/scimIntegration:ScimIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst aad = new snowflake.ScimIntegration(\"aad\", {\n    networkPolicy: \"AAD_NETWORK_POLICY\",\n    provisionerRole: \"AAD_PROVISIONER\",\n    scimClient: \"AZURE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\naad = snowflake.ScimIntegration(\"aad\",\n    network_policy=\"AAD_NETWORK_POLICY\",\n    provisioner_role=\"AAD_PROVISIONER\",\n    scim_client=\"AZURE\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var aad = new Snowflake.ScimIntegration(\"aad\", new Snowflake.ScimIntegrationArgs\n        {\n            NetworkPolicy = \"AAD_NETWORK_POLICY\",\n            ProvisionerRole = \"AAD_PROVISIONER\",\n            ScimClient = \"AZURE\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewScimIntegration(ctx, \"aad\", \u0026snowflake.ScimIntegrationArgs{\n\t\t\tNetworkPolicy:   pulumi.String(\"AAD_NETWORK_POLICY\"),\n\t\t\tProvisionerRole: pulumi.String(\"AAD_PROVISIONER\"),\n\t\t\tScimClient:      pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aad = new ScimIntegration(\"aad\", ScimIntegrationArgs.builder()        \n            .networkPolicy(\"AAD_NETWORK_POLICY\")\n            .provisionerRole(\"AAD_PROVISIONER\")\n            .scimClient(\"AZURE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aad:\n    type: snowflake:ScimIntegration\n    properties:\n      networkPolicy: AAD_NETWORK_POLICY\n      provisionerRole: AAD_PROVISIONER\n      scimClient: AZURE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/scimIntegration:ScimIntegration example name\n```\n\n ",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the SCIM integration was created.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the SCIM integration. This name follows the rules for Object Identifiers. The name should be\nunique among security integrations in your account.\n"
                },
                "networkPolicy": {
                    "type": "string",
                    "description": "Specifies an existing network policy active for your account. The network policy restricts the list of user IP addresses\nwhen exchanging an authorization code for an access or refresh token and when using a refresh token to obtain a new\naccess token. If this parameter is not set, the network policy for the account (if any) is used instead.\n"
                },
                "provisionerRole": {
                    "type": "string",
                    "description": "Specify the SCIM role in Snowflake that owns any users and roles that are imported from the identity provider into\nSnowflake using SCIM.\n"
                },
                "scimClient": {
                    "type": "string",
                    "description": "Specifies the client type for the scim integration\n"
                }
            },
            "required": [
                "createdOn",
                "name",
                "provisionerRole",
                "scimClient"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the SCIM integration. This name follows the rules for Object Identifiers. The name should be\nunique among security integrations in your account.\n",
                    "willReplaceOnChanges": true
                },
                "networkPolicy": {
                    "type": "string",
                    "description": "Specifies an existing network policy active for your account. The network policy restricts the list of user IP addresses\nwhen exchanging an authorization code for an access or refresh token and when using a refresh token to obtain a new\naccess token. If this parameter is not set, the network policy for the account (if any) is used instead.\n"
                },
                "provisionerRole": {
                    "type": "string",
                    "description": "Specify the SCIM role in Snowflake that owns any users and roles that are imported from the identity provider into\nSnowflake using SCIM.\n"
                },
                "scimClient": {
                    "type": "string",
                    "description": "Specifies the client type for the scim integration\n"
                }
            },
            "requiredInputs": [
                "provisionerRole",
                "scimClient"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ScimIntegration resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the SCIM integration was created.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the SCIM integration. This name follows the rules for Object Identifiers. The name should be\nunique among security integrations in your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkPolicy": {
                        "type": "string",
                        "description": "Specifies an existing network policy active for your account. The network policy restricts the list of user IP addresses\nwhen exchanging an authorization code for an access or refresh token and when using a refresh token to obtain a new\naccess token. If this parameter is not set, the network policy for the account (if any) is used instead.\n"
                    },
                    "provisionerRole": {
                        "type": "string",
                        "description": "Specify the SCIM role in Snowflake that owns any users and roles that are imported from the identity provider into\nSnowflake using SCIM.\n"
                    },
                    "scimClient": {
                        "type": "string",
                        "description": "Specifies the client type for the scim integration\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/sequence:Sequence": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst database = new snowflake.Database(\"database\", {});\nconst testSchema = new snowflake.Schema(\"testSchema\", {database: snowflake_database.test_database.name});\nconst testSequence = new snowflake.Sequence(\"testSequence\", {\n    database: snowflake_database.test_database.name,\n    schema: testSchema.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndatabase = snowflake.Database(\"database\")\ntest_schema = snowflake.Schema(\"testSchema\", database=snowflake_database[\"test_database\"][\"name\"])\ntest_sequence = snowflake.Sequence(\"testSequence\",\n    database=snowflake_database[\"test_database\"][\"name\"],\n    schema=test_schema.name)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var database = new Snowflake.Database(\"database\", new Snowflake.DatabaseArgs\n        {\n        });\n        var testSchema = new Snowflake.Schema(\"testSchema\", new Snowflake.SchemaArgs\n        {\n            Database = snowflake_database.Test_database.Name,\n        });\n        var testSequence = new Snowflake.Sequence(\"testSequence\", new Snowflake.SequenceArgs\n        {\n            Database = snowflake_database.Test_database.Name,\n            Schema = testSchema.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewDatabase(ctx, \"database\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestSchema, err := snowflake.NewSchema(ctx, \"testSchema\", \u0026snowflake.SchemaArgs{\n\t\t\tDatabase: pulumi.Any(snowflake_database.Test_database.Name),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewSequence(ctx, \"testSequence\", \u0026snowflake.SequenceArgs{\n\t\t\tDatabase: pulumi.Any(snowflake_database.Test_database.Name),\n\t\t\tSchema:   testSchema.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var database = new Database(\"database\");\n\n        var testSchema = new Schema(\"testSchema\", SchemaArgs.builder()        \n            .database(snowflake_database.test_database().name())\n            .build());\n\n        var testSequence = new Sequence(\"testSequence\", SequenceArgs.builder()        \n            .database(snowflake_database.test_database().name())\n            .schema(testSchema.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  database:\n    type: snowflake:Database\n  testSchema:\n    type: snowflake:Schema\n    properties:\n      database: ${snowflake_database.test_database.name}\n  testSequence:\n    type: snowflake:Sequence\n    properties:\n      database: ${snowflake_database.test_database.name}\n      schema: ${testSchema.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | sequence name\n\n```sh\n $ pulumi import snowflake:index/sequence:Sequence example 'dbName|schemaName|sequenceName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the sequence.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the sequence. Don't use the | character.\n"
                },
                "fullyQualifiedName": {
                    "type": "string",
                    "description": "The fully qualified name of the sequence.\n"
                },
                "increment": {
                    "type": "integer",
                    "description": "The amount the sequence will increase by each time it is used\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name for the sequence.\n"
                },
                "nextValue": {
                    "type": "integer",
                    "description": "The next value the sequence will provide.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the sequence. Don't use the | character.\n"
                }
            },
            "required": [
                "database",
                "fullyQualifiedName",
                "name",
                "nextValue",
                "schema"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the sequence.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the sequence. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "increment": {
                    "type": "integer",
                    "description": "The amount the sequence will increase by each time it is used\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name for the sequence.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the sequence. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Sequence resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the sequence.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the sequence. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "fullyQualifiedName": {
                        "type": "string",
                        "description": "The fully qualified name of the sequence.\n"
                    },
                    "increment": {
                        "type": "integer",
                        "description": "The amount the sequence will increase by each time it is used\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name for the sequence.\n",
                        "willReplaceOnChanges": true
                    },
                    "nextValue": {
                        "type": "integer",
                        "description": "The next value the sequence will provide.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the sequence. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/sequenceGrant:SequenceGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.SequenceGrant(\"grant\", {\n    databaseName: \"db\",\n    onFuture: false,\n    privilege: \"select\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    sequenceName: \"sequence\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.SequenceGrant(\"grant\",\n    database_name=\"db\",\n    on_future=False,\n    privilege=\"select\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    sequence_name=\"sequence\",\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.SequenceGrant(\"grant\", new Snowflake.SequenceGrantArgs\n        {\n            DatabaseName = \"db\",\n            OnFuture = false,\n            Privilege = \"select\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            SequenceName = \"sequence\",\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewSequenceGrant(ctx, \"grant\", \u0026snowflake.SequenceGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"db\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"select\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tSequenceName:    pulumi.String(\"sequence\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new SequenceGrant(\"grant\", SequenceGrantArgs.builder()        \n            .databaseName(\"db\")\n            .onFuture(false)\n            .privilege(\"select\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .sequenceName(\"sequence\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:SequenceGrant\n    properties:\n      databaseName: db\n      onFuture: false\n      privilege: select\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      sequenceName: sequence\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | sequence name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/sequenceGrant:SequenceGrant example 'dbName|schemaName|sequenceName|USAGE|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future sequences on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future sequences in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future sequences in the given database. The\nsequence_name field must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future sequence.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future sequences on which to grant privileges.\n"
                },
                "sequenceName": {
                    "type": "string",
                    "description": "The name of the sequence on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future sequences on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future sequences in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future sequences in the given database. The\nsequence_name field must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future sequence.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future sequences on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "sequenceName": {
                    "type": "string",
                    "description": "The name of the sequence on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SequenceGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future sequences on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future sequences in the given schema.\nWhen this is true and no schema_name is provided apply this grant on all future sequences in the given database. The\nsequence_name field must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future sequence.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future sequences on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "sequenceName": {
                        "type": "string",
                        "description": "The name of the sequence on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/share:Share": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst test = new snowflake.Share(\"test\", {\n    accounts: \"organizationName.accountName\",\n    comment: \"cool comment\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntest = snowflake.Share(\"test\",\n    accounts=\"organizationName.accountName\",\n    comment=\"cool comment\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var test = new Snowflake.Share(\"test\", new Snowflake.ShareArgs\n        {\n            Accounts = \"organizationName.accountName\",\n            Comment = \"cool comment\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewShare(ctx, \"test\", \u0026snowflake.ShareArgs{\n\t\t\tAccounts: pulumi.StringArray(\"organizationName.accountName\"),\n\t\t\tComment:  pulumi.String(\"cool comment\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Share(\"test\", ShareArgs.builder()        \n            .accounts(\"organizationName.accountName\")\n            .comment(\"cool comment\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: snowflake:Share\n    properties:\n      accounts: organizationName.accountName\n      comment: cool comment\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/share:Share example name\n```\n\n ",
            "properties": {
                "accounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of accounts to be added to the share. Values should not be the account locator, but in the form of\n'organization_name.account_name\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the managed account.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the share; must be unique for the account in which the share is created.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "accounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of accounts to be added to the share. Values should not be the account locator, but in the form of\n'organization_name.account_name\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the managed account.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the share; must be unique for the account in which the share is created.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Share resources.\n",
                "properties": {
                    "accounts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of accounts to be added to the share. Values should not be the account locator, but in the form of\n'organization_name.account_name\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the managed account.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the share; must be unique for the account in which the share is created.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/stage:Stage": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst exampleStage = new snowflake.Stage(\"exampleStage\", {\n    url: \"s3://com.example.bucket/prefix\",\n    database: \"EXAMPLE_DB\",\n    schema: \"EXAMPLE_SCHEMA\",\n    credentials: `AWS_KEY_ID='${_var.example_aws_key_id}' AWS_SECRET_KEY='${_var.example_aws_secret_key}'`,\n});\nconst grantExampleStage = new snowflake.StageGrant(\"grantExampleStage\", {\n    databaseName: exampleStage.database,\n    schemaName: exampleStage.schema,\n    roles: [\"LOADER\"],\n    privilege: \"OWNERSHIP\",\n    stageName: exampleStage.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexample_stage = snowflake.Stage(\"exampleStage\",\n    url=\"s3://com.example.bucket/prefix\",\n    database=\"EXAMPLE_DB\",\n    schema=\"EXAMPLE_SCHEMA\",\n    credentials=f\"AWS_KEY_ID='{var['example_aws_key_id']}' AWS_SECRET_KEY='{var['example_aws_secret_key']}'\")\ngrant_example_stage = snowflake.StageGrant(\"grantExampleStage\",\n    database_name=example_stage.database,\n    schema_name=example_stage.schema,\n    roles=[\"LOADER\"],\n    privilege=\"OWNERSHIP\",\n    stage_name=example_stage.name)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var exampleStage = new Snowflake.Stage(\"exampleStage\", new Snowflake.StageArgs\n        {\n            Url = \"s3://com.example.bucket/prefix\",\n            Database = \"EXAMPLE_DB\",\n            Schema = \"EXAMPLE_SCHEMA\",\n            Credentials = $\"AWS_KEY_ID='{@var.Example_aws_key_id}' AWS_SECRET_KEY='{@var.Example_aws_secret_key}'\",\n        });\n        var grantExampleStage = new Snowflake.StageGrant(\"grantExampleStage\", new Snowflake.StageGrantArgs\n        {\n            DatabaseName = exampleStage.Database,\n            SchemaName = exampleStage.Schema,\n            Roles = \n            {\n                \"LOADER\",\n            },\n            Privilege = \"OWNERSHIP\",\n            StageName = exampleStage.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleStage, err := snowflake.NewStage(ctx, \"exampleStage\", \u0026snowflake.StageArgs{\n\t\t\tUrl:         pulumi.String(\"s3://com.example.bucket/prefix\"),\n\t\t\tDatabase:    pulumi.String(\"EXAMPLE_DB\"),\n\t\t\tSchema:      pulumi.String(\"EXAMPLE_SCHEMA\"),\n\t\t\tCredentials: pulumi.String(fmt.Sprintf(\"%v%v%v%v%v\", \"AWS_KEY_ID='\", _var.Example_aws_key_id, \"' AWS_SECRET_KEY='\", _var.Example_aws_secret_key, \"'\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewStageGrant(ctx, \"grantExampleStage\", \u0026snowflake.StageGrantArgs{\n\t\t\tDatabaseName: exampleStage.Database,\n\t\t\tSchemaName:   exampleStage.Schema,\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"LOADER\"),\n\t\t\t},\n\t\t\tPrivilege: pulumi.String(\"OWNERSHIP\"),\n\t\t\tStageName: exampleStage.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleStage = new Stage(\"exampleStage\", StageArgs.builder()        \n            .url(\"s3://com.example.bucket/prefix\")\n            .database(\"EXAMPLE_DB\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .credentials(String.format(\"AWS_KEY_ID='%s' AWS_SECRET_KEY='%s'\", var_.example_aws_key_id(),var_.example_aws_secret_key()))\n            .build());\n\n        var grantExampleStage = new StageGrant(\"grantExampleStage\", StageGrantArgs.builder()        \n            .databaseName(exampleStage.database())\n            .schemaName(exampleStage.schema())\n            .roles(\"LOADER\")\n            .privilege(\"OWNERSHIP\")\n            .stageName(exampleStage.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleStage:\n    type: snowflake:Stage\n    properties:\n      url: s3://com.example.bucket/prefix\n      database: EXAMPLE_DB\n      schema: EXAMPLE_SCHEMA\n      credentials: AWS_KEY_ID='${var.example_aws_key_id}' AWS_SECRET_KEY='${var.example_aws_secret_key}'\n  grantExampleStage:\n    type: snowflake:StageGrant\n    properties:\n      databaseName: ${exampleStage.database}\n      schemaName: ${exampleStage.schema}\n      roles:\n        - LOADER\n      privilege: OWNERSHIP\n      stageName: ${exampleStage.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | stage name\n\n```sh\n $ pulumi import snowflake:index/stage:Stage example 'dbName|schemaName|stageName'\n```\n\n ",
            "properties": {
                "awsExternalId": {
                    "type": "string"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the stage.\n"
                },
                "copyOptions": {
                    "type": "string",
                    "description": "Specifies the copy options for the stage.\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "Specifies the credentials for the stage.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the stage.\n"
                },
                "directory": {
                    "type": "string",
                    "description": "Specifies the directory settings for the stage.\n"
                },
                "encryption": {
                    "type": "string",
                    "description": "Specifies the encryption settings for the stage.\n"
                },
                "fileFormat": {
                    "type": "string",
                    "description": "Specifies the file format for the stage.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the stage; must be unique for the database and schema in which the stage is created.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the stage.\n"
                },
                "snowflakeIamUser": {
                    "type": "string"
                },
                "storageIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the storage integration used to delegate authentication responsibility for external cloud storage\nto a Snowflake identity and access management (IAM) entity.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/StageTag:StageTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                },
                "url": {
                    "type": "string",
                    "description": "Specifies the URL for the stage.\n"
                }
            },
            "required": [
                "awsExternalId",
                "database",
                "name",
                "schema",
                "snowflakeIamUser"
            ],
            "inputProperties": {
                "awsExternalId": {
                    "type": "string"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the stage.\n"
                },
                "copyOptions": {
                    "type": "string",
                    "description": "Specifies the copy options for the stage.\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "Specifies the credentials for the stage.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the stage.\n",
                    "willReplaceOnChanges": true
                },
                "directory": {
                    "type": "string",
                    "description": "Specifies the directory settings for the stage.\n",
                    "willReplaceOnChanges": true
                },
                "encryption": {
                    "type": "string",
                    "description": "Specifies the encryption settings for the stage.\n"
                },
                "fileFormat": {
                    "type": "string",
                    "description": "Specifies the file format for the stage.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the stage; must be unique for the database and schema in which the stage is created.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the stage.\n",
                    "willReplaceOnChanges": true
                },
                "snowflakeIamUser": {
                    "type": "string"
                },
                "storageIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the storage integration used to delegate authentication responsibility for external cloud storage\nto a Snowflake identity and access management (IAM) entity.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/StageTag:StageTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                },
                "url": {
                    "type": "string",
                    "description": "Specifies the URL for the stage.\n"
                }
            },
            "requiredInputs": [
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Stage resources.\n",
                "properties": {
                    "awsExternalId": {
                        "type": "string"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the stage.\n"
                    },
                    "copyOptions": {
                        "type": "string",
                        "description": "Specifies the copy options for the stage.\n"
                    },
                    "credentials": {
                        "type": "string",
                        "description": "Specifies the credentials for the stage.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the stage.\n",
                        "willReplaceOnChanges": true
                    },
                    "directory": {
                        "type": "string",
                        "description": "Specifies the directory settings for the stage.\n",
                        "willReplaceOnChanges": true
                    },
                    "encryption": {
                        "type": "string",
                        "description": "Specifies the encryption settings for the stage.\n"
                    },
                    "fileFormat": {
                        "type": "string",
                        "description": "Specifies the file format for the stage.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the stage; must be unique for the database and schema in which the stage is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the stage.\n",
                        "willReplaceOnChanges": true
                    },
                    "snowflakeIamUser": {
                        "type": "string"
                    },
                    "storageIntegration": {
                        "type": "string",
                        "description": "Specifies the name of the storage integration used to delegate authentication responsibility for external cloud storage\nto a Snowflake identity and access management (IAM) entity.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/StageTag:StageTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "Specifies the URL for the stage.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/stageGrant:StageGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.StageGrant(\"grant\", {\n    databaseName: \"db\",\n    onFuture: false,\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    stageName: \"stage\",\n    withGrantOption: false,\n});\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new StageGrant(\"grant\", StageGrantArgs.builder()        \n            .databaseName(\"db\")\n            .onFuture(false)\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .stageName(\"stage\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:StageGrant\n    properties:\n      databaseName: db\n      onFuture: false\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      stageName: stage\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | stage name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/stageGrant:StageGrant example 'databaseName|schemaName|stageName|USAGE|true'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current stage on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future stages in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future stages in the given database. The stage_name\nfield must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the stage.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current stage on which to grant privileges.\n"
                },
                "stageName": {
                    "type": "string",
                    "description": "The name of the stage on which to grant privilege (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current stage on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future stages in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future stages in the given database. The stage_name\nfield must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the stage.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current stage on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "stageName": {
                    "type": "string",
                    "description": "The name of the stage on which to grant privilege (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StageGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current stage on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future stages in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future stages in the given database. The stage_name\nfield must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the stage.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current stage on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "stageName": {
                        "type": "string",
                        "description": "The name of the stage on which to grant privilege (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/storageIntegration:StorageIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst integration = new snowflake.StorageIntegration(\"integration\", {\n    comment: \"A storage integration.\",\n    enabled: true,\n    storageAwsExternalId: \"...\",\n    storageAwsIamUserArn: \"...\",\n    storageAwsRoleArn: \"...\",\n    storageProvider: \"S3\",\n    type: \"EXTERNAL_STAGE\",\n});\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var integration = new StorageIntegration(\"integration\", StorageIntegrationArgs.builder()        \n            .comment(\"A storage integration.\")\n            .enabled(true)\n            .storageAwsExternalId(\"...\")\n            .storageAwsIamUserArn(\"...\")\n            .storageAwsRoleArn(\"...\")\n            .storageProvider(\"S3\")\n            .type(\"EXTERNAL_STAGE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  integration:\n    type: snowflake:StorageIntegration\n    properties:\n      comment: A storage integration.\n      enabled: true\n      storageAwsExternalId: '...'\n      storageAwsIamUserArn: '...'\n      storageAwsRoleArn: '...'\n      storageProvider: S3\n      type: EXTERNAL_STAGE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/storageIntegration:StorageIntegration example name\n```\n\n ",
            "properties": {
                "azureConsentUrl": {
                    "type": "string",
                    "description": "The consent URL that is used to create an Azure Snowflake service principle inside your tenant.\n"
                },
                "azureMultiTenantAppName": {
                    "type": "string",
                    "description": "This is the name of the Snowflake client application created for your account.\n"
                },
                "azureTenantId": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the storage integration was created.\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "storageAllowedLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly limits external stages that use the integration to reference one or more storage locations.\n"
                },
                "storageAwsExternalId": {
                    "type": "string",
                    "description": "The external ID that Snowflake will use when assuming the AWS role.\n"
                },
                "storageAwsIamUserArn": {
                    "type": "string",
                    "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                },
                "storageAwsObjectAcl": {
                    "type": "string",
                    "description": "\"bucket-owner-full-control\" Enables support for AWS access control lists (ACLs) to grant the bucket owner full control.\n"
                },
                "storageAwsRoleArn": {
                    "type": "string"
                },
                "storageBlockedLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly prohibits external stages that use the integration from referencing one or more storage locations.\n"
                },
                "storageGcpServiceAccount": {
                    "type": "string",
                    "description": "This is the name of the Snowflake Google Service Account created for your account.\n"
                },
                "storageProvider": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "azureConsentUrl",
                "azureMultiTenantAppName",
                "createdOn",
                "name",
                "storageAllowedLocations",
                "storageAwsExternalId",
                "storageAwsIamUserArn",
                "storageGcpServiceAccount",
                "storageProvider"
            ],
            "inputProperties": {
                "azureTenantId": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "storageAllowedLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly limits external stages that use the integration to reference one or more storage locations.\n"
                },
                "storageAwsObjectAcl": {
                    "type": "string",
                    "description": "\"bucket-owner-full-control\" Enables support for AWS access control lists (ACLs) to grant the bucket owner full control.\n"
                },
                "storageAwsRoleArn": {
                    "type": "string"
                },
                "storageBlockedLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly prohibits external stages that use the integration from referencing one or more storage locations.\n"
                },
                "storageProvider": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "storageAllowedLocations",
                "storageProvider"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageIntegration resources.\n",
                "properties": {
                    "azureConsentUrl": {
                        "type": "string",
                        "description": "The consent URL that is used to create an Azure Snowflake service principle inside your tenant.\n"
                    },
                    "azureMultiTenantAppName": {
                        "type": "string",
                        "description": "This is the name of the Snowflake client application created for your account.\n"
                    },
                    "azureTenantId": {
                        "type": "string"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the storage integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "storageAllowedLocations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Explicitly limits external stages that use the integration to reference one or more storage locations.\n"
                    },
                    "storageAwsExternalId": {
                        "type": "string",
                        "description": "The external ID that Snowflake will use when assuming the AWS role.\n"
                    },
                    "storageAwsIamUserArn": {
                        "type": "string",
                        "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                    },
                    "storageAwsObjectAcl": {
                        "type": "string",
                        "description": "\"bucket-owner-full-control\" Enables support for AWS access control lists (ACLs) to grant the bucket owner full control.\n"
                    },
                    "storageAwsRoleArn": {
                        "type": "string"
                    },
                    "storageBlockedLocations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Explicitly prohibits external stages that use the integration from referencing one or more storage locations.\n"
                    },
                    "storageGcpServiceAccount": {
                        "type": "string",
                        "description": "This is the name of the Snowflake Google Service Account created for your account.\n"
                    },
                    "storageProvider": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/stream:Stream": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst stream = new snowflake.Stream(\"stream\", {\n    appendOnly: false,\n    comment: \"A stream.\",\n    database: \"db\",\n    insertOnly: false,\n    onTable: \"table\",\n    owner: \"role1\",\n    schema: \"schema\",\n});\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var stream = new Stream(\"stream\", StreamArgs.builder()        \n            .appendOnly(false)\n            .comment(\"A stream.\")\n            .database(\"db\")\n            .insertOnly(false)\n            .onTable(\"table\")\n            .owner(\"role1\")\n            .schema(\"schema\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  stream:\n    type: snowflake:Stream\n    properties:\n      appendOnly: false\n      comment: A stream.\n      database: db\n      insertOnly: false\n      onTable: table\n      owner: role1\n      schema: schema\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | stream name\n\n```sh\n $ pulumi import snowflake:index/stream:Stream example 'dbName|schemaName|streamName'\n```\n\n ",
            "properties": {
                "appendOnly": {
                    "type": "boolean",
                    "description": "Type of the stream that will be created.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the stream.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the stream.\n"
                },
                "insertOnly": {
                    "type": "boolean",
                    "description": "Create an insert only stream type.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the stream; must be unique for the database and schema in which the stream is created.\n"
                },
                "onTable": {
                    "type": "string",
                    "description": "Name of the table the stream will monitor.\n"
                },
                "onView": {
                    "type": "string",
                    "description": "Name of the view the stream will monitor.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Name of the role that owns the stream.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the stream.\n"
                },
                "showInitialRows": {
                    "type": "boolean",
                    "description": "Specifies whether to return all existing rows in the source table as row inserts the first time the stream is consumed.\n"
                }
            },
            "required": [
                "database",
                "name",
                "owner",
                "schema"
            ],
            "inputProperties": {
                "appendOnly": {
                    "type": "boolean",
                    "description": "Type of the stream that will be created.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the stream.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the stream.\n",
                    "willReplaceOnChanges": true
                },
                "insertOnly": {
                    "type": "boolean",
                    "description": "Create an insert only stream type.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the stream; must be unique for the database and schema in which the stream is created.\n",
                    "willReplaceOnChanges": true
                },
                "onTable": {
                    "type": "string",
                    "description": "Name of the table the stream will monitor.\n",
                    "willReplaceOnChanges": true
                },
                "onView": {
                    "type": "string",
                    "description": "Name of the view the stream will monitor.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the stream.\n",
                    "willReplaceOnChanges": true
                },
                "showInitialRows": {
                    "type": "boolean",
                    "description": "Specifies whether to return all existing rows in the source table as row inserts the first time the stream is consumed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Stream resources.\n",
                "properties": {
                    "appendOnly": {
                        "type": "boolean",
                        "description": "Type of the stream that will be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the stream.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the stream.\n",
                        "willReplaceOnChanges": true
                    },
                    "insertOnly": {
                        "type": "boolean",
                        "description": "Create an insert only stream type.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the stream; must be unique for the database and schema in which the stream is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "onTable": {
                        "type": "string",
                        "description": "Name of the table the stream will monitor.\n",
                        "willReplaceOnChanges": true
                    },
                    "onView": {
                        "type": "string",
                        "description": "Name of the view the stream will monitor.\n",
                        "willReplaceOnChanges": true
                    },
                    "owner": {
                        "type": "string",
                        "description": "Name of the role that owns the stream.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the stream.\n",
                        "willReplaceOnChanges": true
                    },
                    "showInitialRows": {
                        "type": "boolean",
                        "description": "Specifies whether to return all existing rows in the source table as row inserts the first time the stream is consumed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/streamGrant:StreamGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.StreamGrant(\"grant\", {\n    databaseName: \"db\",\n    onFuture: false,\n    privilege: \"select\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    streamName: \"view\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.StreamGrant(\"grant\",\n    database_name=\"db\",\n    on_future=False,\n    privilege=\"select\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    stream_name=\"view\",\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.StreamGrant(\"grant\", new Snowflake.StreamGrantArgs\n        {\n            DatabaseName = \"db\",\n            OnFuture = false,\n            Privilege = \"select\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            StreamName = \"view\",\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewStreamGrant(ctx, \"grant\", \u0026snowflake.StreamGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"db\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"select\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tStreamName:      pulumi.String(\"view\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new StreamGrant(\"grant\", StreamGrantArgs.builder()        \n            .databaseName(\"db\")\n            .onFuture(false)\n            .privilege(\"select\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .streamName(\"view\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:StreamGrant\n    properties:\n      databaseName: db\n      onFuture: false\n      privilege: select\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      streamName: view\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | stream name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/streamGrant:StreamGrant example 'dbName|schemaName|streamName|SELECT|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future streams on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future streams in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future streams in the given database. The\nstream_name field must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future stream.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future streams on which to grant privileges.\n"
                },
                "streamName": {
                    "type": "string",
                    "description": "The name of the stream on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future streams on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future streams in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future streams in the given database. The\nstream_name field must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future stream.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future streams on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "streamName": {
                    "type": "string",
                    "description": "The name of the stream on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StreamGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future streams on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future streams in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future streams in the given database. The\nstream_name field must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future stream.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future streams on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "streamName": {
                        "type": "string",
                        "description": "The name of the stream on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/table:Table": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst schema = new snowflake.Schema(\"schema\", {\n    database: \"database\",\n    dataRetentionDays: 1,\n});\nconst sequence = new snowflake.Sequence(\"sequence\", {\n    database: schema.database,\n    schema: schema.name,\n});\nconst table = new snowflake.Table(\"table\", {\n    database: schema.database,\n    schema: schema.name,\n    comment: \"A table.\",\n    clusterBies: [\"to_date(DATE)\"],\n    dataRetentionDays: schema.dataRetentionDays,\n    changeTracking: false,\n    columns: [\n        {\n            name: \"id\",\n            type: \"int\",\n            nullable: true,\n            \"default\": {\n                sequence: sequence.fullyQualifiedName,\n            },\n        },\n        {\n            name: \"identity\",\n            type: \"NUMBER(38,0)\",\n            nullable: true,\n            identity: {\n                startNum: 1,\n                stepNum: 3,\n            },\n        },\n        {\n            name: \"data\",\n            type: \"text\",\n            nullable: false,\n        },\n        {\n            name: \"DATE\",\n            type: \"TIMESTAMP_NTZ(9)\",\n        },\n        {\n            name: \"extra\",\n            type: \"VARIANT\",\n            comment: \"extra data\",\n        },\n    ],\n    primaryKey: {\n        name: \"my_key\",\n        keys: [\"data\"],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nschema = snowflake.Schema(\"schema\",\n    database=\"database\",\n    data_retention_days=1)\nsequence = snowflake.Sequence(\"sequence\",\n    database=schema.database,\n    schema=schema.name)\ntable = snowflake.Table(\"table\",\n    database=schema.database,\n    schema=schema.name,\n    comment=\"A table.\",\n    cluster_bies=[\"to_date(DATE)\"],\n    data_retention_days=schema.data_retention_days,\n    change_tracking=False,\n    columns=[\n        snowflake.TableColumnArgs(\n            name=\"id\",\n            type=\"int\",\n            nullable=True,\n            default=snowflake.TableColumnDefaultArgs(\n                sequence=sequence.fully_qualified_name,\n            ),\n        ),\n        snowflake.TableColumnArgs(\n            name=\"identity\",\n            type=\"NUMBER(38,0)\",\n            nullable=True,\n            identity=snowflake.TableColumnIdentityArgs(\n                start_num=1,\n                step_num=3,\n            ),\n        ),\n        snowflake.TableColumnArgs(\n            name=\"data\",\n            type=\"text\",\n            nullable=False,\n        ),\n        snowflake.TableColumnArgs(\n            name=\"DATE\",\n            type=\"TIMESTAMP_NTZ(9)\",\n        ),\n        snowflake.TableColumnArgs(\n            name=\"extra\",\n            type=\"VARIANT\",\n            comment=\"extra data\",\n        ),\n    ],\n    primary_key=snowflake.TablePrimaryKeyArgs(\n        name=\"my_key\",\n        keys=[\"data\"],\n    ))\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var schema = new Snowflake.Schema(\"schema\", new Snowflake.SchemaArgs\n        {\n            Database = \"database\",\n            DataRetentionDays = 1,\n        });\n        var sequence = new Snowflake.Sequence(\"sequence\", new Snowflake.SequenceArgs\n        {\n            Database = schema.Database,\n            Schema = schema.Name,\n        });\n        var table = new Snowflake.Table(\"table\", new Snowflake.TableArgs\n        {\n            Database = schema.Database,\n            Schema = schema.Name,\n            Comment = \"A table.\",\n            ClusterBies = \n            {\n                \"to_date(DATE)\",\n            },\n            DataRetentionDays = schema.DataRetentionDays,\n            ChangeTracking = false,\n            Columns = \n            {\n                new Snowflake.Inputs.TableColumnArgs\n                {\n                    Name = \"id\",\n                    Type = \"int\",\n                    Nullable = true,\n                    Default = new Snowflake.Inputs.TableColumnDefaultArgs\n                    {\n                        Sequence = sequence.FullyQualifiedName,\n                    },\n                },\n                new Snowflake.Inputs.TableColumnArgs\n                {\n                    Name = \"identity\",\n                    Type = \"NUMBER(38,0)\",\n                    Nullable = true,\n                    Identity = new Snowflake.Inputs.TableColumnIdentityArgs\n                    {\n                        StartNum = 1,\n                        StepNum = 3,\n                    },\n                },\n                new Snowflake.Inputs.TableColumnArgs\n                {\n                    Name = \"data\",\n                    Type = \"text\",\n                    Nullable = false,\n                },\n                new Snowflake.Inputs.TableColumnArgs\n                {\n                    Name = \"DATE\",\n                    Type = \"TIMESTAMP_NTZ(9)\",\n                },\n                new Snowflake.Inputs.TableColumnArgs\n                {\n                    Name = \"extra\",\n                    Type = \"VARIANT\",\n                    Comment = \"extra data\",\n                },\n            },\n            PrimaryKey = new Snowflake.Inputs.TablePrimaryKeyArgs\n            {\n                Name = \"my_key\",\n                Keys = \n                {\n                    \"data\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tschema, err := snowflake.NewSchema(ctx, \"schema\", \u0026snowflake.SchemaArgs{\n\t\t\tDatabase:          pulumi.String(\"database\"),\n\t\t\tDataRetentionDays: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsequence, err := snowflake.NewSequence(ctx, \"sequence\", \u0026snowflake.SequenceArgs{\n\t\t\tDatabase: schema.Database,\n\t\t\tSchema:   schema.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTable(ctx, \"table\", \u0026snowflake.TableArgs{\n\t\t\tDatabase: schema.Database,\n\t\t\tSchema:   schema.Name,\n\t\t\tComment:  pulumi.String(\"A table.\"),\n\t\t\tClusterBies: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"to_date(DATE)\"),\n\t\t\t},\n\t\t\tDataRetentionDays: schema.DataRetentionDays,\n\t\t\tChangeTracking:    pulumi.Bool(false),\n\t\t\tColumns: TableColumnArray{\n\t\t\t\t\u0026TableColumnArgs{\n\t\t\t\t\tName:     pulumi.String(\"id\"),\n\t\t\t\t\tType:     pulumi.String(\"int\"),\n\t\t\t\t\tNullable: pulumi.Bool(true),\n\t\t\t\t\tDefault: \u0026TableColumnDefaultArgs{\n\t\t\t\t\t\tSequence: sequence.FullyQualifiedName,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026TableColumnArgs{\n\t\t\t\t\tName:     pulumi.String(\"identity\"),\n\t\t\t\t\tType:     pulumi.String(\"NUMBER(38,0)\"),\n\t\t\t\t\tNullable: pulumi.Bool(true),\n\t\t\t\t\tIdentity: \u0026TableColumnIdentityArgs{\n\t\t\t\t\t\tStartNum: pulumi.Int(1),\n\t\t\t\t\t\tStepNum:  pulumi.Int(3),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026TableColumnArgs{\n\t\t\t\t\tName:     pulumi.String(\"data\"),\n\t\t\t\t\tType:     pulumi.String(\"text\"),\n\t\t\t\t\tNullable: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t\t\u0026TableColumnArgs{\n\t\t\t\t\tName: pulumi.String(\"DATE\"),\n\t\t\t\t\tType: pulumi.String(\"TIMESTAMP_NTZ(9)\"),\n\t\t\t\t},\n\t\t\t\t\u0026TableColumnArgs{\n\t\t\t\t\tName:    pulumi.String(\"extra\"),\n\t\t\t\t\tType:    pulumi.String(\"VARIANT\"),\n\t\t\t\t\tComment: pulumi.String(\"extra data\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPrimaryKey: \u0026TablePrimaryKeyArgs{\n\t\t\t\tName: pulumi.String(\"my_key\"),\n\t\t\t\tKeys: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"data\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .database(\"database\")\n            .dataRetentionDays(1)\n            .build());\n\n        var sequence = new Sequence(\"sequence\", SequenceArgs.builder()        \n            .database(schema.database())\n            .schema(schema.name())\n            .build());\n\n        var table = new Table(\"table\", TableArgs.builder()        \n            .database(schema.database())\n            .schema(schema.name())\n            .comment(\"A table.\")\n            .clusterBies(\"to_date(DATE)\")\n            .dataRetentionDays(schema.dataRetentionDays())\n            .changeTracking(false)\n            .columns(            \n                TableColumnArgs.builder()\n                    .name(\"id\")\n                    .type(\"int\")\n                    .nullable(true)\n                    .default_(TableColumnDefaultArgs.builder()\n                        .sequence(sequence.fullyQualifiedName())\n                        .build())\n                    .build(),\n                TableColumnArgs.builder()\n                    .name(\"identity\")\n                    .type(\"NUMBER(38,0)\")\n                    .nullable(true)\n                    .identity(TableColumnIdentityArgs.builder()\n                        .startNum(1)\n                        .stepNum(3)\n                        .build())\n                    .build(),\n                TableColumnArgs.builder()\n                    .name(\"data\")\n                    .type(\"text\")\n                    .nullable(false)\n                    .build(),\n                TableColumnArgs.builder()\n                    .name(\"DATE\")\n                    .type(\"TIMESTAMP_NTZ(9)\")\n                    .build(),\n                TableColumnArgs.builder()\n                    .name(\"extra\")\n                    .type(\"VARIANT\")\n                    .comment(\"extra data\")\n                    .build())\n            .primaryKey(TablePrimaryKeyArgs.builder()\n                .name(\"my_key\")\n                .keys(\"data\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  schema:\n    type: snowflake:Schema\n    properties:\n      database: database\n      dataRetentionDays: 1\n  sequence:\n    type: snowflake:Sequence\n    properties:\n      database: ${schema.database}\n      schema: ${schema.name}\n  table:\n    type: snowflake:Table\n    properties:\n      database: ${schema.database}\n      schema: ${schema.name}\n      comment: A table.\n      clusterBies:\n        - to_date(DATE)\n      dataRetentionDays: ${schema.dataRetentionDays}\n      changeTracking: false\n      columns:\n        - name: id\n          type: int\n          nullable: true\n          default:\n            sequence: ${sequence.fullyQualifiedName}\n        - name: identity\n          type: NUMBER(38,0)\n          nullable: true\n          identity:\n            startNum: 1\n            stepNum: 3\n        - name: data\n          type: text\n          nullable: false\n        - name: DATE\n          type: TIMESTAMP_NTZ(9)\n        - name: extra\n          type: VARIANT\n          comment: extra data\n      primaryKey:\n        name: my_key\n        keys:\n          - data\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | table name\n\n```sh\n $ pulumi import snowflake:index/table:Table example 'databaseName|schemaName|tableName'\n```\n\n ",
            "properties": {
                "changeTracking": {
                    "type": "boolean",
                    "description": "Specifies whether to enable change tracking on the table. Default false.\n"
                },
                "clusterBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of one or more table columns/expressions to be used as clustering key(s) for the table\n"
                },
                "columns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TableColumn:TableColumn"
                    },
                    "description": "Definitions of a column to create in the table. Minimum one required.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the table.\n"
                },
                "dataRetentionDays": {
                    "type": "integer",
                    "description": "Specifies the retention period for the table so that Time Travel actions (SELECT, CLONE, UNDROP) can be performed on\nhistorical data in the table. Default value is 1, if you wish to inherit the parent schema setting then pass in the\nschema attribute to this argument.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the table.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the table; must be unique for the database and schema in which the table is created.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Name of the role that owns the table.\n"
                },
                "primaryKey": {
                    "$ref": "#/types/snowflake:index/TablePrimaryKey:TablePrimaryKey",
                    "description": "Definitions of primary key constraint to create on table\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the table.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TableTag:TableTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "required": [
                "columns",
                "database",
                "name",
                "owner",
                "schema"
            ],
            "inputProperties": {
                "changeTracking": {
                    "type": "boolean",
                    "description": "Specifies whether to enable change tracking on the table. Default false.\n"
                },
                "clusterBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of one or more table columns/expressions to be used as clustering key(s) for the table\n"
                },
                "columns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TableColumn:TableColumn"
                    },
                    "description": "Definitions of a column to create in the table. Minimum one required.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the table.\n"
                },
                "dataRetentionDays": {
                    "type": "integer",
                    "description": "Specifies the retention period for the table so that Time Travel actions (SELECT, CLONE, UNDROP) can be performed on\nhistorical data in the table. Default value is 1, if you wish to inherit the parent schema setting then pass in the\nschema attribute to this argument.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the table.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the table; must be unique for the database and schema in which the table is created.\n"
                },
                "primaryKey": {
                    "$ref": "#/types/snowflake:index/TablePrimaryKey:TablePrimaryKey",
                    "description": "Definitions of primary key constraint to create on table\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the table.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TableTag:TableTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "requiredInputs": [
                "columns",
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Table resources.\n",
                "properties": {
                    "changeTracking": {
                        "type": "boolean",
                        "description": "Specifies whether to enable change tracking on the table. Default false.\n"
                    },
                    "clusterBies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of one or more table columns/expressions to be used as clustering key(s) for the table\n"
                    },
                    "columns": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/TableColumn:TableColumn"
                        },
                        "description": "Definitions of a column to create in the table. Minimum one required.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the table.\n"
                    },
                    "dataRetentionDays": {
                        "type": "integer",
                        "description": "Specifies the retention period for the table so that Time Travel actions (SELECT, CLONE, UNDROP) can be performed on\nhistorical data in the table. Default value is 1, if you wish to inherit the parent schema setting then pass in the\nschema attribute to this argument.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the table.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the table; must be unique for the database and schema in which the table is created.\n"
                    },
                    "owner": {
                        "type": "string",
                        "description": "Name of the role that owns the table.\n"
                    },
                    "primaryKey": {
                        "$ref": "#/types/snowflake:index/TablePrimaryKey:TablePrimaryKey",
                        "description": "Definitions of primary key constraint to create on table\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the table.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/TableTag:TableTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/tableGrant:TableGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.TableGrant(\"grant\", {\n    databaseName: \"database\",\n    onFuture: false,\n    privilege: \"SELECT\",\n    roles: [\"role1\"],\n    schemaName: \"schema\",\n    shares: [\"share1\"],\n    tableName: \"table\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.TableGrant(\"grant\",\n    database_name=\"database\",\n    on_future=False,\n    privilege=\"SELECT\",\n    roles=[\"role1\"],\n    schema_name=\"schema\",\n    shares=[\"share1\"],\n    table_name=\"table\",\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.TableGrant(\"grant\", new Snowflake.TableGrantArgs\n        {\n            DatabaseName = \"database\",\n            OnFuture = false,\n            Privilege = \"SELECT\",\n            Roles = \n            {\n                \"role1\",\n            },\n            SchemaName = \"schema\",\n            Shares = \n            {\n                \"share1\",\n            },\n            TableName = \"table\",\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewTableGrant(ctx, \"grant\", \u0026snowflake.TableGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"SELECT\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t},\n\t\t\tTableName:       pulumi.String(\"table\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new TableGrant(\"grant\", TableGrantArgs.builder()        \n            .databaseName(\"database\")\n            .onFuture(false)\n            .privilege(\"SELECT\")\n            .roles(\"role1\")\n            .schemaName(\"schema\")\n            .shares(\"share1\")\n            .tableName(\"table\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:TableGrant\n    properties:\n      databaseName: database\n      onFuture: false\n      privilege: SELECT\n      roles:\n        - role1\n      schemaName: schema\n      shares:\n        - share1\n      tableName: table\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | table name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/tableGrant:TableGrant example 'databaseName|schemaName|tableName|MODIFY|true'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future tables on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future tables in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future tables in the given database. The table_name\nand shares fields must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future table.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future tables on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is unset).\n"
                },
                "tableName": {
                    "type": "string",
                    "description": "The name of the table on which to grant privileges immediately (only valid if on_future is unset).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future tables on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future tables in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future tables in the given database. The table_name\nand shares fields must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future table.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future tables on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is unset).\n"
                },
                "tableName": {
                    "type": "string",
                    "description": "The name of the table on which to grant privileges immediately (only valid if on_future is unset).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TableGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future tables on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future tables in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future tables in the given database. The table_name\nand shares fields must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future table.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future tables on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is unset).\n"
                    },
                    "tableName": {
                        "type": "string",
                        "description": "The name of the table on which to grant privileges immediately (only valid if on_future is unset).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/tag:Tag": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst testTag = new snowflake.Tag(\"test_tag\", {\n    allowedValues: [\n        \"foo\",\n        \"bar\",\n    ],\n    // Optionals\n    comment: \"test comment\",\n    database: \"test_db\",\n    schema: \"test_schema\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntest_tag = snowflake.Tag(\"testTag\",\n    allowed_values=[\n        \"foo\",\n        \"bar\",\n    ],\n    comment=\"test comment\",\n    database=\"test_db\",\n    schema=\"test_schema\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var testTag = new Snowflake.Tag(\"testTag\", new Snowflake.TagArgs\n        {\n            AllowedValues = \n            {\n                \"foo\",\n                \"bar\",\n            },\n            Comment = \"test comment\",\n            Database = \"test_db\",\n            Schema = \"test_schema\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewTag(ctx, \"testTag\", \u0026snowflake.TagArgs{\n\t\t\tAllowedValues: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"foo\"),\n\t\t\t\tpulumi.String(\"bar\"),\n\t\t\t},\n\t\t\tComment:  pulumi.String(\"test comment\"),\n\t\t\tDatabase: pulumi.String(\"test_db\"),\n\t\t\tSchema:   pulumi.String(\"test_schema\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testTag = new Tag(\"testTag\", TagArgs.builder()        \n            .allowedValues(            \n                \"foo\",\n                \"bar\")\n            .comment(\"test comment\")\n            .database(\"test_db\")\n            .schema(\"test_schema\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testTag:\n    type: snowflake:Tag\n    properties:\n      allowedValues:\n        - foo\n        - bar\n      comment: test comment\n      database: test_db\n      schema: test_schema\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | tag name\n\n```sh\n $ pulumi import snowflake:index/tag:Tag example 'dbName|schemaName|tagName'\n```\n\n ",
            "properties": {
                "allowedValues": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed values for the tag.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the tag.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the tag; must be unique for the database in which the tag is created.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the tag.\n"
                }
            },
            "required": [
                "database",
                "name",
                "schema"
            ],
            "inputProperties": {
                "allowedValues": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed values for the tag.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the tag.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the tag.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the tag; must be unique for the database in which the tag is created.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the tag.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tag resources.\n",
                "properties": {
                    "allowedValues": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed values for the tag.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the tag.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the tag.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the tag; must be unique for the database in which the tag is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the tag.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/task:Task": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst task = new snowflake.Task(\"task\", {\n    comment: \"my task\",\n    database: \"db\",\n    schema: \"schema\",\n    warehouse: \"warehouse\",\n    schedule: \"10 MINUTE\",\n    sqlStatement: \"select * from foo;\",\n    sessionParameters: {\n        foo: \"bar\",\n    },\n    userTaskTimeoutMs: 10000,\n    after: \"preceding_task\",\n    when: \"foo AND bar\",\n    enabled: true,\n});\nconst serverlessTask = new snowflake.Task(\"serverlessTask\", {\n    comment: \"my serverless task\",\n    database: \"db\",\n    schema: \"schema\",\n    schedule: \"10 MINUTE\",\n    sqlStatement: \"select * from foo;\",\n    sessionParameters: {\n        foo: \"bar\",\n    },\n    userTaskTimeoutMs: 10000,\n    userTaskManagedInitialWarehouseSize: \"XSMALL\",\n    after: \"preceding_task\",\n    when: \"foo AND bar\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntask = snowflake.Task(\"task\",\n    comment=\"my task\",\n    database=\"db\",\n    schema=\"schema\",\n    warehouse=\"warehouse\",\n    schedule=\"10 MINUTE\",\n    sql_statement=\"select * from foo;\",\n    session_parameters={\n        \"foo\": \"bar\",\n    },\n    user_task_timeout_ms=10000,\n    after=\"preceding_task\",\n    when=\"foo AND bar\",\n    enabled=True)\nserverless_task = snowflake.Task(\"serverlessTask\",\n    comment=\"my serverless task\",\n    database=\"db\",\n    schema=\"schema\",\n    schedule=\"10 MINUTE\",\n    sql_statement=\"select * from foo;\",\n    session_parameters={\n        \"foo\": \"bar\",\n    },\n    user_task_timeout_ms=10000,\n    user_task_managed_initial_warehouse_size=\"XSMALL\",\n    after=\"preceding_task\",\n    when=\"foo AND bar\",\n    enabled=True)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var task = new Snowflake.Task(\"task\", new Snowflake.TaskArgs\n        {\n            Comment = \"my task\",\n            Database = \"db\",\n            Schema = \"schema\",\n            Warehouse = \"warehouse\",\n            Schedule = \"10 MINUTE\",\n            SqlStatement = \"select * from foo;\",\n            SessionParameters = \n            {\n                { \"foo\", \"bar\" },\n            },\n            UserTaskTimeoutMs = 10000,\n            After = \"preceding_task\",\n            When = \"foo AND bar\",\n            Enabled = true,\n        });\n        var serverlessTask = new Snowflake.Task(\"serverlessTask\", new Snowflake.TaskArgs\n        {\n            Comment = \"my serverless task\",\n            Database = \"db\",\n            Schema = \"schema\",\n            Schedule = \"10 MINUTE\",\n            SqlStatement = \"select * from foo;\",\n            SessionParameters = \n            {\n                { \"foo\", \"bar\" },\n            },\n            UserTaskTimeoutMs = 10000,\n            UserTaskManagedInitialWarehouseSize = \"XSMALL\",\n            After = \"preceding_task\",\n            When = \"foo AND bar\",\n            Enabled = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewTask(ctx, \"task\", \u0026snowflake.TaskArgs{\n\t\t\tComment:      pulumi.String(\"my task\"),\n\t\t\tDatabase:     pulumi.String(\"db\"),\n\t\t\tSchema:       pulumi.String(\"schema\"),\n\t\t\tWarehouse:    pulumi.String(\"warehouse\"),\n\t\t\tSchedule:     pulumi.String(\"10 MINUTE\"),\n\t\t\tSqlStatement: pulumi.String(\"select * from foo;\"),\n\t\t\tSessionParameters: pulumi.StringMap{\n\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t},\n\t\t\tUserTaskTimeoutMs: pulumi.Int(10000),\n\t\t\tAfter:             pulumi.String(\"preceding_task\"),\n\t\t\tWhen:              pulumi.String(\"foo AND bar\"),\n\t\t\tEnabled:           pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTask(ctx, \"serverlessTask\", \u0026snowflake.TaskArgs{\n\t\t\tComment:      pulumi.String(\"my serverless task\"),\n\t\t\tDatabase:     pulumi.String(\"db\"),\n\t\t\tSchema:       pulumi.String(\"schema\"),\n\t\t\tSchedule:     pulumi.String(\"10 MINUTE\"),\n\t\t\tSqlStatement: pulumi.String(\"select * from foo;\"),\n\t\t\tSessionParameters: pulumi.StringMap{\n\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t},\n\t\t\tUserTaskTimeoutMs:                   pulumi.Int(10000),\n\t\t\tUserTaskManagedInitialWarehouseSize: pulumi.String(\"XSMALL\"),\n\t\t\tAfter:                               pulumi.String(\"preceding_task\"),\n\t\t\tWhen:                                pulumi.String(\"foo AND bar\"),\n\t\t\tEnabled:                             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var task = new Task(\"task\", TaskArgs.builder()        \n            .comment(\"my task\")\n            .database(\"db\")\n            .schema(\"schema\")\n            .warehouse(\"warehouse\")\n            .schedule(\"10 MINUTE\")\n            .sqlStatement(\"select * from foo;\")\n            .sessionParameters(Map.of(\"foo\", \"bar\"))\n            .userTaskTimeoutMs(10000)\n            .after(\"preceding_task\")\n            .when(\"foo AND bar\")\n            .enabled(true)\n            .build());\n\n        var serverlessTask = new Task(\"serverlessTask\", TaskArgs.builder()        \n            .comment(\"my serverless task\")\n            .database(\"db\")\n            .schema(\"schema\")\n            .schedule(\"10 MINUTE\")\n            .sqlStatement(\"select * from foo;\")\n            .sessionParameters(Map.of(\"foo\", \"bar\"))\n            .userTaskTimeoutMs(10000)\n            .userTaskManagedInitialWarehouseSize(\"XSMALL\")\n            .after(\"preceding_task\")\n            .when(\"foo AND bar\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  task:\n    type: snowflake:Task\n    properties:\n      comment: my task\n      database: db\n      schema: schema\n      warehouse: warehouse\n      schedule: 10 MINUTE\n      sqlStatement: select * from foo;\n      sessionParameters:\n        foo: bar\n      userTaskTimeoutMs: 10000\n      after: preceding_task\n      when: foo AND bar\n      enabled: true\n  serverlessTask:\n    type: snowflake:Task\n    properties:\n      comment: my serverless task\n      database: db\n      schema: schema\n      schedule: 10 MINUTE\n      sqlStatement: select * from foo;\n      sessionParameters:\n        foo: bar\n      userTaskTimeoutMs: 10000\n      userTaskManagedInitialWarehouseSize: XSMALL\n      after: preceding_task\n      when: foo AND bar\n      enabled: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | task name\n\n```sh\n $ pulumi import snowflake:index/task:Task example 'dbName|schemaName|taskName'\n```\n\n ",
            "properties": {
                "after": {
                    "type": "string",
                    "description": "Specifies the predecessor task in the same database and schema of the current task. When a run of the predecessor task\nfinishes successfully, it triggers this task (after a brief lag). (Conflict with schedule)\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the task.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the task.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies if the task should be started (enabled) after creation or should remain suspended (default).\n"
                },
                "errorIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the notification integration used for error notifications.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the task; must be unique for the database and schema in which the task is created.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "The schedule for periodically running the task. This can be a cron or interval in minutes. (Conflict with after)\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the task.\n"
                },
                "sessionParameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies session parameters to set for the session when the task runs. A task supports all session parameters.\n"
                },
                "sqlStatement": {
                    "type": "string",
                    "description": "Any single SQL statement, or a call to a stored procedure, executed when the task runs.\n"
                },
                "userTaskManagedInitialWarehouseSize": {
                    "type": "string",
                    "description": "Specifies the size of the compute resources to provision for the first run of the task, before a task history is\navailable for Snowflake to determine an ideal size. Once a task has successfully completed a few runs, Snowflake ignores\nthis parameter setting. (Conflicts with warehouse)\n"
                },
                "userTaskTimeoutMs": {
                    "type": "integer",
                    "description": "Specifies the time limit on a single run of the task before it times out (in milliseconds).\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse the task will use. Omit this parameter to use Snowflake-managed compute resources for runs of this task.\n(Conflicts with user_task_managed_initial_warehouse_size)\n"
                },
                "when": {
                    "type": "string",
                    "description": "Specifies a Boolean SQL expression; multiple conditions joined with AND/OR are supported.\n"
                }
            },
            "required": [
                "database",
                "name",
                "schema",
                "sqlStatement"
            ],
            "inputProperties": {
                "after": {
                    "type": "string",
                    "description": "Specifies the predecessor task in the same database and schema of the current task. When a run of the predecessor task\nfinishes successfully, it triggers this task (after a brief lag). (Conflict with schedule)\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the task.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the task.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies if the task should be started (enabled) after creation or should remain suspended (default).\n"
                },
                "errorIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the notification integration used for error notifications.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the task; must be unique for the database and schema in which the task is created.\n",
                    "willReplaceOnChanges": true
                },
                "schedule": {
                    "type": "string",
                    "description": "The schedule for periodically running the task. This can be a cron or interval in minutes. (Conflict with after)\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the task.\n",
                    "willReplaceOnChanges": true
                },
                "sessionParameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies session parameters to set for the session when the task runs. A task supports all session parameters.\n"
                },
                "sqlStatement": {
                    "type": "string",
                    "description": "Any single SQL statement, or a call to a stored procedure, executed when the task runs.\n"
                },
                "userTaskManagedInitialWarehouseSize": {
                    "type": "string",
                    "description": "Specifies the size of the compute resources to provision for the first run of the task, before a task history is\navailable for Snowflake to determine an ideal size. Once a task has successfully completed a few runs, Snowflake ignores\nthis parameter setting. (Conflicts with warehouse)\n"
                },
                "userTaskTimeoutMs": {
                    "type": "integer",
                    "description": "Specifies the time limit on a single run of the task before it times out (in milliseconds).\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse the task will use. Omit this parameter to use Snowflake-managed compute resources for runs of this task.\n(Conflicts with user_task_managed_initial_warehouse_size)\n"
                },
                "when": {
                    "type": "string",
                    "description": "Specifies a Boolean SQL expression; multiple conditions joined with AND/OR are supported.\n"
                }
            },
            "requiredInputs": [
                "database",
                "schema",
                "sqlStatement"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Task resources.\n",
                "properties": {
                    "after": {
                        "type": "string",
                        "description": "Specifies the predecessor task in the same database and schema of the current task. When a run of the predecessor task\nfinishes successfully, it triggers this task (after a brief lag). (Conflict with schedule)\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the task.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the task.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies if the task should be started (enabled) after creation or should remain suspended (default).\n"
                    },
                    "errorIntegration": {
                        "type": "string",
                        "description": "Specifies the name of the notification integration used for error notifications.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the task; must be unique for the database and schema in which the task is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "schedule": {
                        "type": "string",
                        "description": "The schedule for periodically running the task. This can be a cron or interval in minutes. (Conflict with after)\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the task.\n",
                        "willReplaceOnChanges": true
                    },
                    "sessionParameters": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies session parameters to set for the session when the task runs. A task supports all session parameters.\n"
                    },
                    "sqlStatement": {
                        "type": "string",
                        "description": "Any single SQL statement, or a call to a stored procedure, executed when the task runs.\n"
                    },
                    "userTaskManagedInitialWarehouseSize": {
                        "type": "string",
                        "description": "Specifies the size of the compute resources to provision for the first run of the task, before a task history is\navailable for Snowflake to determine an ideal size. Once a task has successfully completed a few runs, Snowflake ignores\nthis parameter setting. (Conflicts with warehouse)\n"
                    },
                    "userTaskTimeoutMs": {
                        "type": "integer",
                        "description": "Specifies the time limit on a single run of the task before it times out (in milliseconds).\n"
                    },
                    "warehouse": {
                        "type": "string",
                        "description": "The warehouse the task will use. Omit this parameter to use Snowflake-managed compute resources for runs of this task.\n(Conflicts with user_task_managed_initial_warehouse_size)\n"
                    },
                    "when": {
                        "type": "string",
                        "description": "Specifies a Boolean SQL expression; multiple conditions joined with AND/OR are supported.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/taskGrant:TaskGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.TaskGrant(\"grant\", {\n    databaseName: \"db\",\n    onFuture: false,\n    privilege: \"operate\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    taskName: \"task\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.TaskGrant(\"grant\",\n    database_name=\"db\",\n    on_future=False,\n    privilege=\"operate\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    task_name=\"task\",\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.TaskGrant(\"grant\", new Snowflake.TaskGrantArgs\n        {\n            DatabaseName = \"db\",\n            OnFuture = false,\n            Privilege = \"operate\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            TaskName = \"task\",\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewTaskGrant(ctx, \"grant\", \u0026snowflake.TaskGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"db\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"operate\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tTaskName:        pulumi.String(\"task\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new TaskGrant(\"grant\", TaskGrantArgs.builder()        \n            .databaseName(\"db\")\n            .onFuture(false)\n            .privilege(\"operate\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .taskName(\"task\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:TaskGrant\n    properties:\n      databaseName: db\n      onFuture: false\n      privilege: operate\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      taskName: task\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | task name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/taskGrant:TaskGrant example 'dbName|schemaName|taskName|OPERATE|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future tasks on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future tasks in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future tasks in the given database. The task_name\nfield must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future task.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future tasks on which to grant privileges.\n"
                },
                "taskName": {
                    "type": "string",
                    "description": "The name of the task on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future tasks on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future tasks in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future tasks in the given database. The task_name\nfield must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future task.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future tasks on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "taskName": {
                    "type": "string",
                    "description": "The name of the task on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TaskGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future tasks on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future tasks in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future tasks in the given database. The task_name\nfield must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future task.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future tasks on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "taskName": {
                        "type": "string",
                        "description": "The name of the task on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/user:User": {
            "description": "\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/user:User example userName\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string"
                },
                "defaultNamespace": {
                    "type": "string",
                    "description": "Specifies the namespace (database only or database and schema) that is active by default for the users session upon\nlogin.\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "Specifies the role that is active by default for the users session upon login.\n"
                },
                "defaultSecondaryRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the set of secondary roles that are active for the users session upon login.\n"
                },
                "defaultWarehouse": {
                    "type": "string",
                    "description": "Specifies the virtual warehouse that is active by default for the users session upon login.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "displayName": {
                    "type": "string",
                    "description": "Name displayed for the user in the Snowflake web interface.\n"
                },
                "email": {
                    "type": "string",
                    "description": "Email address for the user.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the user.\n"
                },
                "hasRsaPublicKey": {
                    "type": "boolean",
                    "description": "Will be true if user as an RSA key set.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the user.\n"
                },
                "loginName": {
                    "type": "string",
                    "description": "The name users use to log in. If not supplied, snowflake will use name instead.\n"
                },
                "mustChangePassword": {
                    "type": "boolean",
                    "description": "Specifies whether the user is forced to change their password on next login (including their first/initial login) into\nthe system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the user. Note that if you do not supply login_name this will be used as login_name.\n[doc](https://docs.snowflake.net/manuals/sql-reference/sql/create-user.html#required-parameters)\n"
                },
                "password": {
                    "type": "string",
                    "description": "**WARNING:** this will put the password in the terraform state file. Use carefully.\n"
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies the users RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies the users second RSA public key; used to rotate the public and private keys for key-pair authentication\nbased on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/UserTag:UserTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "required": [
                "defaultRole",
                "disabled",
                "displayName",
                "hasRsaPublicKey",
                "loginName",
                "name"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string"
                },
                "defaultNamespace": {
                    "type": "string",
                    "description": "Specifies the namespace (database only or database and schema) that is active by default for the users session upon\nlogin.\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "Specifies the role that is active by default for the users session upon login.\n"
                },
                "defaultSecondaryRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the set of secondary roles that are active for the users session upon login.\n"
                },
                "defaultWarehouse": {
                    "type": "string",
                    "description": "Specifies the virtual warehouse that is active by default for the users session upon login.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "displayName": {
                    "type": "string",
                    "description": "Name displayed for the user in the Snowflake web interface.\n"
                },
                "email": {
                    "type": "string",
                    "description": "Email address for the user.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the user.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the user.\n"
                },
                "loginName": {
                    "type": "string",
                    "description": "The name users use to log in. If not supplied, snowflake will use name instead.\n"
                },
                "mustChangePassword": {
                    "type": "boolean",
                    "description": "Specifies whether the user is forced to change their password on next login (including their first/initial login) into\nthe system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the user. Note that if you do not supply login_name this will be used as login_name.\n[doc](https://docs.snowflake.net/manuals/sql-reference/sql/create-user.html#required-parameters)\n"
                },
                "password": {
                    "type": "string",
                    "description": "**WARNING:** this will put the password in the terraform state file. Use carefully.\n"
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies the users RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies the users second RSA public key; used to rotate the public and private keys for key-pair authentication\nbased on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/UserTag:UserTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "comment": {
                        "type": "string"
                    },
                    "defaultNamespace": {
                        "type": "string",
                        "description": "Specifies the namespace (database only or database and schema) that is active by default for the users session upon\nlogin.\n"
                    },
                    "defaultRole": {
                        "type": "string",
                        "description": "Specifies the role that is active by default for the users session upon login.\n"
                    },
                    "defaultSecondaryRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the set of secondary roles that are active for the users session upon login.\n"
                    },
                    "defaultWarehouse": {
                        "type": "string",
                        "description": "Specifies the virtual warehouse that is active by default for the users session upon login.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Name displayed for the user in the Snowflake web interface.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "Email address for the user.\n"
                    },
                    "firstName": {
                        "type": "string",
                        "description": "First name of the user.\n"
                    },
                    "hasRsaPublicKey": {
                        "type": "boolean",
                        "description": "Will be true if user as an RSA key set.\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "Last name of the user.\n"
                    },
                    "loginName": {
                        "type": "string",
                        "description": "The name users use to log in. If not supplied, snowflake will use name instead.\n"
                    },
                    "mustChangePassword": {
                        "type": "boolean",
                        "description": "Specifies whether the user is forced to change their password on next login (including their first/initial login) into\nthe system.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the user. Note that if you do not supply login_name this will be used as login_name.\n[doc](https://docs.snowflake.net/manuals/sql-reference/sql/create-user.html#required-parameters)\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "**WARNING:** this will put the password in the terraform state file. Use carefully.\n"
                    },
                    "rsaPublicKey": {
                        "type": "string",
                        "description": "Specifies the users RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                    },
                    "rsaPublicKey2": {
                        "type": "string",
                        "description": "Specifies the users second RSA public key; used to rotate the public and private keys for key-pair authentication\nbased on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/UserTag:UserTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/userOwnershipGrant:UserOwnershipGrant": {
            "properties": {
                "currentGrants": {
                    "type": "string",
                    "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to\na new role.\n"
                },
                "onUserName": {
                    "type": "string",
                    "description": "The name of the user ownership is granted on.\n"
                },
                "toRoleName": {
                    "type": "string",
                    "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                }
            },
            "required": [
                "onUserName",
                "toRoleName"
            ],
            "inputProperties": {
                "currentGrants": {
                    "type": "string",
                    "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to\na new role.\n"
                },
                "onUserName": {
                    "type": "string",
                    "description": "The name of the user ownership is granted on.\n"
                },
                "toRoleName": {
                    "type": "string",
                    "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                }
            },
            "requiredInputs": [
                "onUserName",
                "toRoleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserOwnershipGrant resources.\n",
                "properties": {
                    "currentGrants": {
                        "type": "string",
                        "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to\na new role.\n"
                    },
                    "onUserName": {
                        "type": "string",
                        "description": "The name of the user ownership is granted on.\n"
                    },
                    "toRoleName": {
                        "type": "string",
                        "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/userPublicKeys:UserPublicKeys": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the user.\n"
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies the users RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies the users second RSA public key; used to rotate the public and Public keys for key-pair authentication\nbased on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Name of the user.\n",
                    "willReplaceOnChanges": true
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies the users RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies the users second RSA public key; used to rotate the public and Public keys for key-pair authentication\nbased on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPublicKeys resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the user.\n",
                        "willReplaceOnChanges": true
                    },
                    "rsaPublicKey": {
                        "type": "string",
                        "description": "Specifies the users RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                    },
                    "rsaPublicKey2": {
                        "type": "string",
                        "description": "Specifies the users second RSA public key; used to rotate the public and Public keys for key-pair authentication\nbased on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/view:View": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst view = new snowflake.View(\"view\", {\n    database: \"db\",\n    schema: \"schema\",\n    comment: \"comment\",\n    statement: \"select * from foo;\\n\",\n    orReplace: false,\n    isSecure: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nview = snowflake.View(\"view\",\n    database=\"db\",\n    schema=\"schema\",\n    comment=\"comment\",\n    statement=\"select * from foo;\\n\",\n    or_replace=False,\n    is_secure=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var view = new Snowflake.View(\"view\", new Snowflake.ViewArgs\n        {\n            Database = \"db\",\n            Schema = \"schema\",\n            Comment = \"comment\",\n            Statement = @\"select * from foo;\n\",\n            OrReplace = false,\n            IsSecure = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewView(ctx, \"view\", \u0026snowflake.ViewArgs{\n\t\t\tDatabase:  pulumi.String(\"db\"),\n\t\t\tSchema:    pulumi.String(\"schema\"),\n\t\t\tComment:   pulumi.String(\"comment\"),\n\t\t\tStatement: pulumi.String(\"select * from foo;\\n\"),\n\t\t\tOrReplace: pulumi.Bool(false),\n\t\t\tIsSecure:  pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var view = new View(\"view\", ViewArgs.builder()        \n            .database(\"db\")\n            .schema(\"schema\")\n            .comment(\"comment\")\n            .statement(\"\"\"\nselect * from foo;\n            \"\"\")\n            .orReplace(false)\n            .isSecure(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  view:\n    type: snowflake:View\n    properties:\n      database: db\n      schema: schema\n      comment: comment\n      statement: |\n        select * from foo;\n      orReplace: false\n      isSecure: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | view name\n\n```sh\n $ pulumi import snowflake:index/view:View example 'dbName|schemaName|viewName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the view.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the view. Don't use the | character.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the view is secure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the view; must be unique for the schema in which the view is created. Don't use the |\ncharacter.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Overwrites the View if it exists.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the view. Don't use the | character.\n"
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the query used to create the view.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ViewTag:ViewTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "required": [
                "database",
                "name",
                "schema",
                "statement"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the view.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the view. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the view is secure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the view; must be unique for the schema in which the view is created. Don't use the |\ncharacter.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Overwrites the View if it exists.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the view. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the query used to create the view.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ViewTag:ViewTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                }
            },
            "requiredInputs": [
                "database",
                "schema",
                "statement"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering View resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the view.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the view. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "isSecure": {
                        "type": "boolean",
                        "description": "Specifies that the view is secure.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the view; must be unique for the schema in which the view is created. Don't use the |\ncharacter.\n"
                    },
                    "orReplace": {
                        "type": "boolean",
                        "description": "Overwrites the View if it exists.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the view. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "statement": {
                        "type": "string",
                        "description": "Specifies the query used to create the view.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ViewTag:ViewTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/viewGrant:ViewGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.ViewGrant(\"grant\", {\n    databaseName: \"db\",\n    onFuture: false,\n    privilege: \"select\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    viewName: \"view\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.ViewGrant(\"grant\",\n    database_name=\"db\",\n    on_future=False,\n    privilege=\"select\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    view_name=\"view\",\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.ViewGrant(\"grant\", new Snowflake.ViewGrantArgs\n        {\n            DatabaseName = \"db\",\n            OnFuture = false,\n            Privilege = \"select\",\n            Roles = \n            {\n                \"role1\",\n                \"role2\",\n            },\n            SchemaName = \"schema\",\n            Shares = \n            {\n                \"share1\",\n                \"share2\",\n            },\n            ViewName = \"view\",\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewViewGrant(ctx, \"grant\", \u0026snowflake.ViewGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"db\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"select\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tViewName:        pulumi.String(\"view\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new ViewGrant(\"grant\", ViewGrantArgs.builder()        \n            .databaseName(\"db\")\n            .onFuture(false)\n            .privilege(\"select\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .viewName(\"view\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:ViewGrant\n    properties:\n      databaseName: db\n      onFuture: false\n      privilege: select\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      viewName: view\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is database name | schema name | view name | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/viewGrant:ViewGrant example 'dbName|schemaName|viewName|USAGE|false'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future views on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future views in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future views in the given database. The view_name\nand shares fields must be unset in order to use on_future.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future view.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future views on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is unset).\n"
                },
                "viewName": {
                    "type": "string",
                    "description": "The name of the view on which to grant privileges immediately (only valid if on_future is unset).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future views on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema_name is provided, apply this grant on all future views in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future views in the given database. The view_name\nand shares fields must be unset in order to use on_future.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future view.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future views on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is unset).\n"
                },
                "viewName": {
                    "type": "string",
                    "description": "The name of the view on which to grant privileges immediately (only valid if on_future is unset).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ViewGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future views on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema_name is provided, apply this grant on all future views in the given schema. When\nthis is true and no schema_name is provided apply this grant on all future views in the given database. The view_name\nand shares fields must be unset in order to use on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future view.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future views on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is unset).\n"
                    },
                    "viewName": {
                        "type": "string",
                        "description": "The name of the view on which to grant privileges immediately (only valid if on_future is unset).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/warehouse:Warehouse": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst warehouse = new snowflake.Warehouse(\"w\", {\n    comment: \"foo\",\n    warehouseSize: \"small\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nwarehouse = snowflake.Warehouse(\"warehouse\",\n    comment=\"foo\",\n    warehouse_size=\"small\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var warehouse = new Snowflake.Warehouse(\"warehouse\", new Snowflake.WarehouseArgs\n        {\n            Comment = \"foo\",\n            WarehouseSize = \"small\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewWarehouse(ctx, \"warehouse\", \u0026snowflake.WarehouseArgs{\n\t\t\tComment:       pulumi.String(\"foo\"),\n\t\t\tWarehouseSize: pulumi.String(\"small\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var warehouse = new Warehouse(\"warehouse\", WarehouseArgs.builder()        \n            .comment(\"foo\")\n            .warehouseSize(\"small\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  warehouse:\n    type: snowflake:Warehouse\n    properties:\n      comment: foo\n      warehouseSize: small\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/warehouse:Warehouse example warehouseName\n```\n\n ",
            "properties": {
                "autoResume": {
                    "type": "boolean",
                    "description": "Specifies whether to automatically resume a warehouse when a SQL statement (e.g. query) is submitted to it.\n"
                },
                "autoSuspend": {
                    "type": "integer",
                    "description": "Specifies the number of seconds of inactivity after which a warehouse is automatically suspended.\n"
                },
                "comment": {
                    "type": "string"
                },
                "initiallySuspended": {
                    "type": "boolean",
                    "description": "Specifies whether the warehouse is created initially in the Suspended state.\n"
                },
                "maxClusterCount": {
                    "type": "integer",
                    "description": "Specifies the maximum number of server clusters for the warehouse.\n"
                },
                "maxConcurrencyLevel": {
                    "type": "integer",
                    "description": "Object parameter that specifies the concurrency level for SQL statements (i.e. queries and DML) executed by a warehouse.\n"
                },
                "minClusterCount": {
                    "type": "integer",
                    "description": "Specifies the minimum number of server clusters for the warehouse (only applies to multi-cluster warehouses).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the virtual warehouse; must be unique for your account.\n"
                },
                "resourceMonitor": {
                    "type": "string",
                    "description": "Specifies the name of a resource monitor that is explicitly assigned to the warehouse.\n"
                },
                "scalingPolicy": {
                    "type": "string",
                    "description": "Specifies the policy for automatically starting and shutting down clusters in a multi-cluster warehouse running in\nAuto-scale mode.\n"
                },
                "statementQueuedTimeoutInSeconds": {
                    "type": "integer",
                    "description": "Object parameter that specifies the time, in seconds, a SQL statement (query, DDL, DML, etc.) can be queued on a\nwarehouse before it is canceled by the system.\n"
                },
                "statementTimeoutInSeconds": {
                    "type": "integer",
                    "description": "Specifies the time, in seconds, after which a running SQL statement (query, DDL, DML, etc.) is canceled by the system\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/WarehouseTag:WarehouseTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                },
                "waitForProvisioning": {
                    "type": "boolean",
                    "description": "Specifies whether the warehouse, after being resized, waits for all the servers to provision before executing any queued\nor new queries.\n"
                },
                "warehouseSize": {
                    "type": "string",
                    "description": "Specifies the size of the virtual warehouse. Larger warehouse sizes 5X-Large and 6X-Large are currently in preview and\nonly available on Amazon Web Services (AWS).\n"
                }
            },
            "required": [
                "autoResume",
                "autoSuspend",
                "maxClusterCount",
                "minClusterCount",
                "name",
                "resourceMonitor",
                "scalingPolicy",
                "warehouseSize"
            ],
            "inputProperties": {
                "autoResume": {
                    "type": "boolean",
                    "description": "Specifies whether to automatically resume a warehouse when a SQL statement (e.g. query) is submitted to it.\n"
                },
                "autoSuspend": {
                    "type": "integer",
                    "description": "Specifies the number of seconds of inactivity after which a warehouse is automatically suspended.\n"
                },
                "comment": {
                    "type": "string"
                },
                "initiallySuspended": {
                    "type": "boolean",
                    "description": "Specifies whether the warehouse is created initially in the Suspended state.\n",
                    "willReplaceOnChanges": true
                },
                "maxClusterCount": {
                    "type": "integer",
                    "description": "Specifies the maximum number of server clusters for the warehouse.\n"
                },
                "maxConcurrencyLevel": {
                    "type": "integer",
                    "description": "Object parameter that specifies the concurrency level for SQL statements (i.e. queries and DML) executed by a warehouse.\n"
                },
                "minClusterCount": {
                    "type": "integer",
                    "description": "Specifies the minimum number of server clusters for the warehouse (only applies to multi-cluster warehouses).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the virtual warehouse; must be unique for your account.\n"
                },
                "resourceMonitor": {
                    "type": "string",
                    "description": "Specifies the name of a resource monitor that is explicitly assigned to the warehouse.\n"
                },
                "scalingPolicy": {
                    "type": "string",
                    "description": "Specifies the policy for automatically starting and shutting down clusters in a multi-cluster warehouse running in\nAuto-scale mode.\n"
                },
                "statementQueuedTimeoutInSeconds": {
                    "type": "integer",
                    "description": "Object parameter that specifies the time, in seconds, a SQL statement (query, DDL, DML, etc.) can be queued on a\nwarehouse before it is canceled by the system.\n"
                },
                "statementTimeoutInSeconds": {
                    "type": "integer",
                    "description": "Specifies the time, in seconds, after which a running SQL statement (query, DDL, DML, etc.) is canceled by the system\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/WarehouseTag:WarehouseTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n"
                },
                "waitForProvisioning": {
                    "type": "boolean",
                    "description": "Specifies whether the warehouse, after being resized, waits for all the servers to provision before executing any queued\nor new queries.\n",
                    "willReplaceOnChanges": true
                },
                "warehouseSize": {
                    "type": "string",
                    "description": "Specifies the size of the virtual warehouse. Larger warehouse sizes 5X-Large and 6X-Large are currently in preview and\nonly available on Amazon Web Services (AWS).\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Warehouse resources.\n",
                "properties": {
                    "autoResume": {
                        "type": "boolean",
                        "description": "Specifies whether to automatically resume a warehouse when a SQL statement (e.g. query) is submitted to it.\n"
                    },
                    "autoSuspend": {
                        "type": "integer",
                        "description": "Specifies the number of seconds of inactivity after which a warehouse is automatically suspended.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "initiallySuspended": {
                        "type": "boolean",
                        "description": "Specifies whether the warehouse is created initially in the Suspended state.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxClusterCount": {
                        "type": "integer",
                        "description": "Specifies the maximum number of server clusters for the warehouse.\n"
                    },
                    "maxConcurrencyLevel": {
                        "type": "integer",
                        "description": "Object parameter that specifies the concurrency level for SQL statements (i.e. queries and DML) executed by a warehouse.\n"
                    },
                    "minClusterCount": {
                        "type": "integer",
                        "description": "Specifies the minimum number of server clusters for the warehouse (only applies to multi-cluster warehouses).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Identifier for the virtual warehouse; must be unique for your account.\n"
                    },
                    "resourceMonitor": {
                        "type": "string",
                        "description": "Specifies the name of a resource monitor that is explicitly assigned to the warehouse.\n"
                    },
                    "scalingPolicy": {
                        "type": "string",
                        "description": "Specifies the policy for automatically starting and shutting down clusters in a multi-cluster warehouse running in\nAuto-scale mode.\n"
                    },
                    "statementQueuedTimeoutInSeconds": {
                        "type": "integer",
                        "description": "Object parameter that specifies the time, in seconds, a SQL statement (query, DDL, DML, etc.) can be queued on a\nwarehouse before it is canceled by the system.\n"
                    },
                    "statementTimeoutInSeconds": {
                        "type": "integer",
                        "description": "Specifies the time, in seconds, after which a running SQL statement (query, DDL, DML, etc.) is canceled by the system\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/WarehouseTag:WarehouseTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n"
                    },
                    "waitForProvisioning": {
                        "type": "boolean",
                        "description": "Specifies whether the warehouse, after being resized, waits for all the servers to provision before executing any queued\nor new queries.\n",
                        "willReplaceOnChanges": true
                    },
                    "warehouseSize": {
                        "type": "string",
                        "description": "Specifies the size of the virtual warehouse. Larger warehouse sizes 5X-Large and 6X-Large are currently in preview and\nonly available on Amazon Web Services (AWS).\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/warehouseGrant:WarehouseGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.WarehouseGrant(\"grant\", {\n    privilege: \"MODIFY\",\n    roles: [\"role1\"],\n    warehouseName: \"wh\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.WarehouseGrant(\"grant\",\n    privilege=\"MODIFY\",\n    roles=[\"role1\"],\n    warehouse_name=\"wh\",\n    with_grant_option=False)\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var grant = new Snowflake.WarehouseGrant(\"grant\", new Snowflake.WarehouseGrantArgs\n        {\n            Privilege = \"MODIFY\",\n            Roles = \n            {\n                \"role1\",\n            },\n            WarehouseName = \"wh\",\n            WithGrantOption = false,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewWarehouseGrant(ctx, \"grant\", \u0026snowflake.WarehouseGrantArgs{\n\t\t\tPrivilege: pulumi.String(\"MODIFY\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t},\n\t\t\tWarehouseName:   pulumi.String(\"wh\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new WarehouseGrant(\"grant\", WarehouseGrantArgs.builder()        \n            .privilege(\"MODIFY\")\n            .roles(\"role1\")\n            .warehouseName(\"wh\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:WarehouseGrant\n    properties:\n      privilege: MODIFY\n      roles:\n        - role1\n      warehouseName: wh\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n# format is warehouse name | | | privilege | true/false for with_grant_option\n\n```sh\n $ pulumi import snowflake:index/warehouseGrant:WarehouseGrant example 'warehouseName|||MODIFY|true'\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the warehouse.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "warehouseName": {
                    "type": "string",
                    "description": "The name of the warehouse on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "warehouseName"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the warehouse.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "warehouseName": {
                    "type": "string",
                    "description": "The name of the warehouse on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "warehouseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WarehouseGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the warehouse.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "warehouseName": {
                        "type": "string",
                        "description": "The name of the warehouse on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "snowflake:index/getCurrentAccount:getCurrentAccount": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst this = snowflake.getCurrentAccount({});\nconst snowflakeAccountUrl = new aws.ssm.Parameter(\"snowflakeAccountUrl\", {\n    type: \"String\",\n    value: _this.then(_this =\u003e _this.url),\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_current_account()\nsnowflake_account_url = aws.ssm.Parameter(\"snowflakeAccountUrl\",\n    type=\"String\",\n    value=this.url)\n```\n```csharp\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @this = Output.Create(Snowflake.GetCurrentAccount.InvokeAsync());\n        var snowflakeAccountUrl = new Aws.Ssm.Parameter(\"snowflakeAccountUrl\", new Aws.Ssm.ParameterArgs\n        {\n            Type = \"String\",\n            Value = @this.Apply(@this =\u003e @this.Url),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ssm\"\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := snowflake.GetCurrentAccount(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssm.NewParameter(ctx, \"snowflakeAccountUrl\", \u0026ssm.ParameterArgs{\n\t\t\tType:  pulumi.String(\"String\"),\n\t\t\tValue: pulumi.String(this.Url),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = Output.of(SnowflakeFunctions.getCurrentAccount());\n\n        var snowflakeAccountUrl = new Parameter(\"snowflakeAccountUrl\", ParameterArgs.builder()        \n            .type(\"String\")\n            .value(this_.url())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  snowflakeAccountUrl:\n    type: aws:ssm:Parameter\n    properties:\n      type: String\n      value: ${this.url}\nvariables:\n  this:\n    Fn::Invoke:\n      Function: snowflake:getCurrentAccount\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getCurrentAccount.\n",
                "properties": {
                    "account": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "region": {
                        "type": "string"
                    },
                    "url": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "account",
                    "region",
                    "url",
                    "id"
                ]
            }
        },
        "snowflake:index/getDatabase:getDatabase": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst thisDatabase = pulumi.output(snowflake.getDatabase({\n    name: \"DEMO_DB\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_database(name=\"DEMO_DB\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @this = Output.Create(Snowflake.GetDatabase.InvokeAsync(new Snowflake.GetDatabaseArgs\n        {\n            Name = \"DEMO_DB\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.LookupDatabase(ctx, \u0026GetDatabaseArgs{\n\t\t\tName: \"DEMO_DB\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = Output.of(SnowflakeFunctions.getDatabase(GetDatabaseArgs.builder()\n            .name(\"DEMO_DB\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    Fn::Invoke:\n      Function: snowflake:getDatabase\n      Arguments:\n        name: DEMO_DB\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatabase.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatabase.\n",
                "properties": {
                    "comment": {
                        "type": "string"
                    },
                    "createdOn": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "isCurrent": {
                        "type": "boolean"
                    },
                    "isDefault": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "options": {
                        "type": "string"
                    },
                    "origin": {
                        "type": "string"
                    },
                    "owner": {
                        "type": "string"
                    },
                    "retentionTime": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "comment",
                    "createdOn",
                    "isCurrent",
                    "isDefault",
                    "name",
                    "options",
                    "origin",
                    "owner",
                    "retentionTime",
                    "id"
                ]
            }
        },
        "snowflake:index/getDatabases:getDatabases": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst thisDatabases = pulumi.output(snowflake.getDatabases());\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_databases()\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @this = Output.Create(Snowflake.GetDatabases.InvokeAsync());\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetDatabases(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = Output.of(SnowflakeFunctions.getDatabases());\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    Fn::Invoke:\n      Function: snowflake:getDatabases\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getDatabases.\n",
                "properties": {
                    "databases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getDatabasesDatabase:getDatabasesDatabase"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "databases",
                    "id"
                ]
            }
        },
        "snowflake:index/getExternalFunctions:getExternalFunctions": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getExternalFunctions({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_external_functions(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetExternalFunctions.InvokeAsync(new Snowflake.GetExternalFunctionsArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetExternalFunctions(ctx, \u0026GetExternalFunctionsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getExternalFunctions(GetExternalFunctionsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getExternalFunctions\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getExternalFunctions.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getExternalFunctions.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "externalFunctions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getExternalFunctionsExternalFunction:getExternalFunctionsExternalFunction"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "externalFunctions",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getExternalTables:getExternalTables": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getExternalTables({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_external_tables(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetExternalTables.InvokeAsync(new Snowflake.GetExternalTablesArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetExternalTables(ctx, \u0026GetExternalTablesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getExternalTables(GetExternalTablesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getExternalTables\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getExternalTables.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getExternalTables.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "externalTables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getExternalTablesExternalTable:getExternalTablesExternalTable"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "externalTables",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getFileFormats:getFileFormats": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getFileFormats({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_file_formats(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetFileFormats.InvokeAsync(new Snowflake.GetFileFormatsArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetFileFormats(ctx, \u0026GetFileFormatsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getFileFormats(GetFileFormatsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getFileFormats\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFileFormats.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFileFormats.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "fileFormats": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getFileFormatsFileFormat:getFileFormatsFileFormat"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "fileFormats",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getFunctions:getFunctions": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getFunctions({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_functions(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetFunctions.InvokeAsync(new Snowflake.GetFunctionsArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetFunctions(ctx, \u0026GetFunctionsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getFunctions(GetFunctionsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getFunctions\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFunctions.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFunctions.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "functions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getFunctionsFunction:getFunctionsFunction"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "functions",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getMaskingPolicies:getMaskingPolicies": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getMaskingPolicies({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_masking_policies(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetMaskingPolicies.InvokeAsync(new Snowflake.GetMaskingPoliciesArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetMaskingPolicies(ctx, \u0026GetMaskingPoliciesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getMaskingPolicies(GetMaskingPoliciesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getMaskingPolicies\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getMaskingPolicies.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getMaskingPolicies.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "maskingPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getMaskingPoliciesMaskingPolicy:getMaskingPoliciesMaskingPolicy"
                        }
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "maskingPolicies",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getMaterializedViews:getMaterializedViews": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getMaterializedViews({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_materialized_views(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetMaterializedViews.InvokeAsync(new Snowflake.GetMaterializedViewsArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetMaterializedViews(ctx, \u0026GetMaterializedViewsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getMaterializedViews(GetMaterializedViewsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getMaterializedViews\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getMaterializedViews.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getMaterializedViews.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "materializedViews": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getMaterializedViewsMaterializedView:getMaterializedViewsMaterializedView"
                        }
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "materializedViews",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getPipes:getPipes": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getPipes({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_pipes(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetPipes.InvokeAsync(new Snowflake.GetPipesArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetPipes(ctx, \u0026GetPipesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getPipes(GetPipesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getPipes\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPipes.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPipes.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pipes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getPipesPipe:getPipesPipe"
                        }
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "pipes",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getProcedures:getProcedures": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getProcedures({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_procedures(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetProcedures.InvokeAsync(new Snowflake.GetProceduresArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetProcedures(ctx, \u0026GetProceduresArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getProcedures(GetProceduresArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getProcedures\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProcedures.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProcedures.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "procedures": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getProceduresProcedure:getProceduresProcedure"
                        }
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "procedures",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getResourceMonitors:getResourceMonitors": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getResourceMonitors());\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_resource_monitors()\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetResourceMonitors.InvokeAsync());\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetResourceMonitors(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getResourceMonitors());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getResourceMonitors\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getResourceMonitors.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "resourceMonitors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getResourceMonitorsResourceMonitor:getResourceMonitorsResourceMonitor"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "resourceMonitors",
                    "id"
                ]
            }
        },
        "snowflake:index/getRole:getRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst thisRole = pulumi.output(snowflake.getRole({\n    name: \"role1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_role(name=\"role1\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var @this = Output.Create(Snowflake.GetRole.InvokeAsync(new Snowflake.GetRoleArgs\n        {\n            Name = \"role1\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.LookupRole(ctx, \u0026GetRoleArgs{\n\t\t\tName: \"role1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = Output.of(SnowflakeFunctions.getRole(GetRoleArgs.builder()\n            .name(\"role1\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    Fn::Invoke:\n      Function: snowflake:getRole\n      Arguments:\n        name: role1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "comment": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "comment",
                    "name",
                    "id"
                ]
            }
        },
        "snowflake:index/getRowAccessPolicies:getRowAccessPolicies": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getRowAccessPolicies({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_row_access_policies(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetRowAccessPolicies.InvokeAsync(new Snowflake.GetRowAccessPoliciesArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetRowAccessPolicies(ctx, \u0026GetRowAccessPoliciesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getRowAccessPolicies(GetRowAccessPoliciesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getRowAccessPolicies\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRowAccessPolicies.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRowAccessPolicies.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rowAccessPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getRowAccessPoliciesRowAccessPolicy:getRowAccessPoliciesRowAccessPolicy"
                        }
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "rowAccessPolicies",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getSchemas:getSchemas": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getSchemas({\n    database: \"MYDB\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_schemas(database=\"MYDB\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetSchemas.InvokeAsync(new Snowflake.GetSchemasArgs\n        {\n            Database = \"MYDB\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetSchemas(ctx, \u0026GetSchemasArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getSchemas(GetSchemasArgs.builder()\n            .database(\"MYDB\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getSchemas\n      Arguments:\n        database: MYDB\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSchemas.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSchemas.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schemas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getSchemasSchema:getSchemasSchema"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schemas",
                    "id"
                ]
            }
        },
        "snowflake:index/getSequences:getSequences": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getSequences({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_sequences(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetSequences.InvokeAsync(new Snowflake.GetSequencesArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetSequences(ctx, \u0026GetSequencesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getSequences(GetSequencesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getSequences\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSequences.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSequences.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    },
                    "sequences": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getSequencesSequence:getSequencesSequence"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "sequences",
                    "id"
                ]
            }
        },
        "snowflake:index/getStages:getStages": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getStages({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_stages(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetStages.InvokeAsync(new Snowflake.GetStagesArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetStages(ctx, \u0026GetStagesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getStages(GetStagesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getStages\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getStages.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getStages.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    },
                    "stages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getStagesStage:getStagesStage"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "stages",
                    "id"
                ]
            }
        },
        "snowflake:index/getStorageIntegrations:getStorageIntegrations": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getStorageIntegrations());\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_storage_integrations()\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetStorageIntegrations.InvokeAsync());\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetStorageIntegrations(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getStorageIntegrations());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getStorageIntegrations\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getStorageIntegrations.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "storageIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getStorageIntegrationsStorageIntegration:getStorageIntegrationsStorageIntegration"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "storageIntegrations",
                    "id"
                ]
            }
        },
        "snowflake:index/getStreams:getStreams": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getStreams({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_streams(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetStreams.InvokeAsync(new Snowflake.GetStreamsArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetStreams(ctx, \u0026GetStreamsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getStreams(GetStreamsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getStreams\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getStreams.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getStreams.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    },
                    "streams": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getStreamsStream:getStreamsStream"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "streams",
                    "id"
                ]
            }
        },
        "snowflake:index/getSystemGenerateScimAccessToken:getSystemGenerateScimAccessToken": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst scim = pulumi.output(snowflake.getSystemGenerateScimAccessToken({\n    integrationName: \"AAD_PROVISIONING\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nscim = snowflake.get_system_generate_scim_access_token(integration_name=\"AAD_PROVISIONING\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var scim = Output.Create(Snowflake.GetSystemGenerateScimAccessToken.InvokeAsync(new Snowflake.GetSystemGenerateScimAccessTokenArgs\n        {\n            IntegrationName = \"AAD_PROVISIONING\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetSystemGenerateScimAccessToken(ctx, \u0026GetSystemGenerateScimAccessTokenArgs{\n\t\t\tIntegrationName: \"AAD_PROVISIONING\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var scim = Output.of(SnowflakeFunctions.getSystemGenerateScimAccessToken(GetSystemGenerateScimAccessTokenArgs.builder()\n            .integrationName(\"AAD_PROVISIONING\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  scim:\n    Fn::Invoke:\n      Function: snowflake:getSystemGenerateScimAccessToken\n      Arguments:\n        integrationName: AAD_PROVISIONING\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSystemGenerateScimAccessToken.\n",
                "properties": {
                    "integrationName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "integrationName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSystemGenerateScimAccessToken.\n",
                "properties": {
                    "accessToken": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "integrationName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accessToken",
                    "integrationName",
                    "id"
                ]
            }
        },
        "snowflake:index/getSystemGetAwsSnsIamPolicy:getSystemGetAwsSnsIamPolicy": {
            "inputs": {
                "description": "A collection of arguments for invoking getSystemGetAwsSnsIamPolicy.\n",
                "properties": {
                    "awsSnsTopicArn": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "awsSnsTopicArn"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSystemGetAwsSnsIamPolicy.\n",
                "properties": {
                    "awsSnsTopicArn": {
                        "type": "string"
                    },
                    "awsSnsTopicPolicyJson": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "awsSnsTopicArn",
                    "awsSnsTopicPolicyJson",
                    "id"
                ]
            }
        },
        "snowflake:index/getSystemGetPrivateLinkConfig:getSystemGetPrivateLinkConfig": {
            "outputs": {
                "description": "A collection of values returned by getSystemGetPrivateLinkConfig.\n",
                "properties": {
                    "accountName": {
                        "type": "string"
                    },
                    "accountUrl": {
                        "type": "string"
                    },
                    "awsVpceId": {
                        "type": "string"
                    },
                    "azurePlsId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ocspUrl": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accountName",
                    "accountUrl",
                    "awsVpceId",
                    "azurePlsId",
                    "ocspUrl",
                    "id"
                ]
            }
        },
        "snowflake:index/getSystemGetSnowflakePlatformInfo:getSystemGetSnowflakePlatformInfo": {
            "outputs": {
                "description": "A collection of values returned by getSystemGetSnowflakePlatformInfo.\n",
                "properties": {
                    "awsVpcIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "azureVnetSubnetIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "awsVpcIds",
                    "azureVnetSubnetIds",
                    "id"
                ]
            }
        },
        "snowflake:index/getTables:getTables": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getTables({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_tables(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetTables.InvokeAsync(new Snowflake.GetTablesArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetTables(ctx, \u0026GetTablesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getTables(GetTablesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getTables\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getTables.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTables.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    },
                    "tables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getTablesTable:getTablesTable"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "tables",
                    "id"
                ]
            }
        },
        "snowflake:index/getTasks:getTasks": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getTasks({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_tasks(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetTasks.InvokeAsync(new Snowflake.GetTasksArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetTasks(ctx, \u0026GetTasksArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getTasks(GetTasksArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getTasks\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getTasks.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTasks.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    },
                    "tasks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getTasksTask:getTasksTask"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "tasks",
                    "id"
                ]
            }
        },
        "snowflake:index/getUsers:getUsers": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getUsers({\n    pattern: \"user1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_users(pattern=\"user1\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetUsers.InvokeAsync(new Snowflake.GetUsersArgs\n        {\n            Pattern = \"user1\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetUsers(ctx, \u0026GetUsersArgs{\n\t\t\tPattern: \"user1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getUsers(GetUsersArgs.builder()\n            .pattern(\"user1\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getUsers\n      Arguments:\n        pattern: user1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getUsers.\n",
                "properties": {
                    "pattern": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "pattern"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getUsers.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pattern": {
                        "type": "string"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getUsersUser:getUsersUser"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "pattern",
                    "users",
                    "id"
                ]
            }
        },
        "snowflake:index/getViews:getViews": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getViews({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_views(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetViews.InvokeAsync(new Snowflake.GetViewsArgs\n        {\n            Database = \"MYDB\",\n            Schema = \"MYSCHEMA\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetViews(ctx, \u0026GetViewsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getViews(GetViewsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build()));\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getViews\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getViews.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getViews.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string"
                    },
                    "views": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getViewsView:getViewsView"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "views",
                    "id"
                ]
            }
        },
        "snowflake:index/getWarehouses:getWarehouses": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = pulumi.output(snowflake.getWarehouses());\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_warehouses()\n```\n```csharp\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var current = Output.Create(Snowflake.GetWarehouses.InvokeAsync());\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetWarehouses(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport java.util.*;\nimport java.io.*;\nimport java.nio.*;\nimport com.pulumi.*;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = Output.of(SnowflakeFunctions.getWarehouses());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    Fn::Invoke:\n      Function: snowflake:getWarehouses\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getWarehouses.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "warehouses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getWarehousesWarehouse:getWarehousesWarehouse"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "warehouses",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": null,
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-snowflake/sdk/go/snowflake"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing snowflake cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/Snowflake-Labs/terraform-provider-snowflake)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-snowflake` repo](https://github.com/pulumi/pulumi-snowflake/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`Snowflake-Labs/terraform-provider-snowflake` repo](https://github.com/Snowflake-Labs/terraform-provider-snowflake/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/Snowflake-Labs/terraform-provider-snowflake)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-snowflake` repo](https://github.com/pulumi/pulumi-snowflake/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`Snowflake-Labs/terraform-provider-snowflake` repo](https://github.com/Snowflake-Labs/terraform-provider-snowflake/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    }
}