{
    "name": "snowflake",
    "description": "A Pulumi package for creating and managing snowflake cloud resources.",
    "keywords": [
        "pulumi",
        "snowflake"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`snowflake` Terraform Provider](https://github.com/Snowflake-Labs/terraform-provider-snowflake).",
    "repository": "https://github.com/pulumi/pulumi-snowflake",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20"
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-snowflake/sdk/go/snowflake",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing snowflake cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/Snowflake-Labs/terraform-provider-snowflake)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-snowflake` repo](https://github.com/pulumi/pulumi-snowflake/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-snowflake` repo](https://github.com/Snowflake-Labs/terraform-provider-snowflake/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/Snowflake-Labs/terraform-provider-snowflake)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-snowflake` repo](https://github.com/pulumi/pulumi-snowflake/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-snowflake` repo](https://github.com/Snowflake-Labs/terraform-provider-snowflake/issues).",
            "compatibility": "tfbridge20",
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "account": {
                "type": "string",
                "description": "Specifies your Snowflake account identifier assigned, by Snowflake. For information about account identifiers, see the\n[Snowflake documentation](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html). Can also be sourced\nfrom the `SNOWFLAKE_ACCOUNT` environment variable. Required unless using `profile`.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_ACCOUNT"
                    ]
                }
            },
            "authenticator": {
                "type": "string",
                "description": "Specifies the [authentication type](https://pkg.go.dev/github.com/snowflakedb/gosnowflake#AuthType) to use when\nconnecting to Snowflake. Valid values include: Snowflake, OAuth, ExternalBrowser, Okta, JWT, TokenAccessor,\nUsernamePasswordMFA. Can also be sourced from the `SNOWFLAKE_AUTHENTICATOR` environment variable.\n"
            },
            "browserAuth": {
                "type": "boolean",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_USE_BROWSER_AUTH` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_USE_BROWSER_AUTH"
                    ]
                },
                "deprecationMessage": "Use `authenticator` instead"
            },
            "clientIp": {
                "type": "string",
                "description": "IP address for network checks. Can also be sourced from the `SNOWFLAKE_CLIENT_IP` environment variable.\n"
            },
            "clientRequestMfaToken": {
                "type": "boolean",
                "description": "When true the MFA token is cached in the credential manager. True by default in Windows/OSX. False for Linux. Can also\nbe sourced from the `SNOWFLAKE_CLIENT_REQUEST_MFA_TOKEN` environment variable.\n"
            },
            "clientStoreTemporaryCredential": {
                "type": "boolean",
                "description": "When true the ID token is cached in the credential manager. True by default in Windows/OSX. False for Linux. Can also be\nsourced from the `SNOWFLAKE_CLIENT_STORE_TEMPORARY_CREDENTIAL` environment variable.\n"
            },
            "clientTimeout": {
                "type": "integer",
                "description": "The timeout in seconds for the client to complete the authentication. Default is 900 seconds. Can also be sourced from\nthe `SNOWFLAKE_CLIENT_TIMEOUT` environment variable.\n"
            },
            "disableQueryContextCache": {
                "type": "boolean",
                "description": "Should HTAP query context cache be disabled. Can also be sourced from the `SNOWFLAKE_DISABLE_QUERY_CONTEXT_CACHE`\nenvironment variable.\n"
            },
            "disableTelemetry": {
                "type": "boolean",
                "description": "Indicates whether to disable telemetry. Can also be sourced from the `SNOWFLAKE_DISABLE_TELEMETRY` environment variable.\n"
            },
            "externalBrowserTimeout": {
                "type": "integer",
                "description": "The timeout in seconds for the external browser to complete the authentication. Default is 120 seconds. Can also be\nsourced from the `SNOWFLAKE_EXTERNAL_BROWSER_TIMEOUT` environment variable.\n"
            },
            "host": {
                "type": "string",
                "description": "Supports passing in a custom host value to the snowflake go driver for use with privatelink. Can also be sourced from\nthe `SNOWFLAKE_HOST` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_HOST"
                    ]
                }
            },
            "insecureMode": {
                "type": "boolean",
                "description": "If true, bypass the Online Certificate Status Protocol (OCSP) certificate revocation check. IMPORTANT: Change the\ndefault value for testing or emergency situations only. Can also be sourced from the `SNOWFLAKE_INSECURE_MODE`\nenvironment variable.\n"
            },
            "jwtClientTimeout": {
                "type": "integer",
                "description": "The timeout in seconds for the JWT client to complete the authentication. Default is 10 seconds. Can also be sourced\nfrom the `SNOWFLAKE_JWT_CLIENT_TIMEOUT` environment variable.\n"
            },
            "jwtExpireTimeout": {
                "type": "integer",
                "description": "JWT expire after timeout in seconds. Can also be sourced from the `SNOWFLAKE_JWT_EXPIRE_TIMEOUT` environment variable.\n"
            },
            "keepSessionAlive": {
                "type": "boolean",
                "description": "Enables the session to persist even after the connection is closed. Can also be sourced from the\n`SNOWFLAKE_KEEP_SESSION_ALIVE` environment variable.\n"
            },
            "loginTimeout": {
                "type": "integer",
                "description": "Login retry timeout EXCLUDING network roundtrip and read out http response. Can also be sourced from the\n`SNOWFLAKE_LOGIN_TIMEOUT` environment variable.\n"
            },
            "oauthAccessToken": {
                "type": "string",
                "description": "Token for use with OAuth. Generating the token is left to other tools. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_refresh_token` or `password`. Can also be sourced from `SNOWFLAKE_OAUTH_ACCESS_TOKEN`\nenvironment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_ACCESS_TOKEN"
                    ]
                },
                "deprecationMessage": "Use `token` instead",
                "secret": true
            },
            "oauthClientId": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_CLIENT_ID` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_CLIENT_ID"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.client_id` instead",
                "secret": true
            },
            "oauthClientSecret": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_CLIENT_SECRET` environment\nvariable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_CLIENT_SECRET"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.client_secret` instead",
                "secret": true
            },
            "oauthEndpoint": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_ENDPOINT` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_ENDPOINT"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.token_endpoint` instead",
                "secret": true
            },
            "oauthRedirectUrl": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_REDIRECT_URL` environment\nvariable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_REDIRECT_URL"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.redirect_uri` instead",
                "secret": true
            },
            "oauthRefreshToken": {
                "type": "string",
                "description": "Token for use with OAuth. Setup and generation of the token is left to other tools. Should be used in conjunction with\n`oauth_client_id`, `oauth_client_secret`, `oauth_endpoint`, `oauth_redirect_url`. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_access_token` or `password`. Can also be sourced from `SNOWFLAKE_OAUTH_REFRESH_TOKEN`\nenvironment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_REFRESH_TOKEN"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.refresh_token` instead",
                "secret": true
            },
            "ocspFailOpen": {
                "type": "boolean",
                "description": "True represents OCSP fail open mode. False represents OCSP fail closed mode. Fail open true by default. Can also be\nsourced from the `SNOWFLAKE_OCSP_FAIL_OPEN` environment variable.\n"
            },
            "oktaUrl": {
                "type": "string",
                "description": "The URL of the Okta server. e.g. https://example.okta.com. Can also be sourced from the `SNOWFLAKE_OKTA_URL` environment\nvariable.\n"
            },
            "params": {
                "type": "object",
                "additionalProperties": {
                    "$ref": "pulumi.json#/Any"
                },
                "description": "Sets other connection (i.e. session) parameters. [Parameters](https://docs.snowflake.com/en/sql-reference/parameters)\n"
            },
            "passcode": {
                "type": "string",
                "description": "Specifies the passcode provided by Duo when using multi-factor authentication (MFA) for login. Can also be sourced from\nthe `SNOWFLAKE_PASSCODE` environment variable.\n"
            },
            "passcodeInPassword": {
                "type": "boolean",
                "description": "False by default. Set to true if the MFA passcode is embedded in the login password. Appends the MFA passcode to the end\nof the password. Can also be sourced from the `SNOWFLAKE_PASSCODE_IN_PASSWORD` environment variable.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for username+password auth. Cannot be used with `browser_auth` or `private_key_path`. Can also be sourced from\nthe `SNOWFLAKE_PASSWORD` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PASSWORD"
                    ]
                },
                "secret": true
            },
            "port": {
                "type": "integer",
                "description": "Support custom port values to snowflake go driver for use with privatelink. Can also be sourced from the\n`SNOWFLAKE_PORT` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PORT"
                    ]
                }
            },
            "privateKey": {
                "type": "string",
                "description": "Private Key for username+private-key auth. Cannot be used with `browser_auth` or `password`. Can also be sourced from\n`SNOWFLAKE_PRIVATE_KEY` environment variable.\n",
                "secret": true
            },
            "privateKeyPassphrase": {
                "type": "string",
                "description": "Supports the encryption ciphers aes-128-cbc, aes-128-gcm, aes-192-cbc, aes-192-gcm, aes-256-cbc, aes-256-gcm, and\ndes-ede3-cbc. Can also be sourced from `SNOWFLAKE_PRIVATE_KEY_PASSPHRASE` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PRIVATE_KEY_PASSPHRASE"
                    ]
                },
                "secret": true
            },
            "privateKeyPath": {
                "type": "string",
                "description": "Path to a private key for using keypair authentication. Cannot be used with `browser_auth`, `oauth_access_token` or\n`password`. Can also be sourced from `SNOWFLAKE_PRIVATE_KEY_PATH` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PRIVATE_KEY_PATH"
                    ]
                },
                "deprecationMessage": "use the [file Function](https://developer.hashicorp.com/terraform/language/functions/file) instead",
                "secret": true
            },
            "profile": {
                "type": "string",
                "description": "Sets the profile to read from ~/.snowflake/config file. Can also be sourced from the `SNOWFLAKE_PROFILE` environment\nvariable.\n"
            },
            "protocol": {
                "type": "string",
                "description": "Either http or https, defaults to https. Can also be sourced from the `SNOWFLAKE_PROTOCOL` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PROTOCOL"
                    ]
                }
            },
            "region": {
                "type": "string",
                "description": "Snowflake region, such as \"eu-central-1\", with this parameter. However, since this parameter is deprecated, it is best\nto specify the region as part of the account parameter. For details, see the description of the account parameter.\n[Snowflake region](https://docs.snowflake.com/en/user-guide/intro-regions.html) to use. Required if using the [legacy\nformat for the `account`\nidentifier](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#format-2-legacy-account-locator-in-a-region)\nin the form of `\u003ccloud_region_id\u003e.\u003ccloud\u003e`. Can also be sourced from the `SNOWFLAKE_REGION` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_REGION"
                    ]
                },
                "deprecationMessage": "Specify the region as part of the account parameter"
            },
            "requestTimeout": {
                "type": "integer",
                "description": "request retry timeout EXCLUDING network roundtrip and read out http response. Can also be sourced from the\n`SNOWFLAKE_REQUEST_TIMEOUT` environment variable.\n"
            },
            "role": {
                "type": "string",
                "description": "Specifies the role to use by default for accessing Snowflake objects in the client session. Can also be sourced from the\n`SNOWFLAKE_ROLE` environment variable. .\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_ROLE"
                    ]
                }
            },
            "sessionParams": {
                "type": "object",
                "additionalProperties": {
                    "$ref": "pulumi.json#/Any"
                },
                "description": "Sets session parameters. [Parameters](https://docs.snowflake.com/en/sql-reference/parameters)\n",
                "deprecationMessage": "Use `params` instead"
            },
            "token": {
                "type": "string",
                "description": "Token to use for OAuth and other forms of token based auth. Can also be sourced from the `SNOWFLAKE_TOKEN` environment\nvariable.\n",
                "secret": true
            },
            "tokenAccessor": {
                "$ref": "#/types/snowflake:config/tokenAccessor:tokenAccessor"
            },
            "user": {
                "type": "string",
                "description": "Username. Can also be sourced from the `SNOWFLAKE_USER` environment variable. Required unless using `profile`.\n"
            },
            "username": {
                "type": "string",
                "description": "Username for username+password authentication. Can also be sourced from the `SNOWFLAKE_USERNAME` environment variable.\nRequired unless using `profile`.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_USER"
                    ]
                },
                "deprecationMessage": "Use `user` instead of `username`"
            },
            "validateDefaultParameters": {
                "type": "boolean",
                "description": "True by default. If false, disables the validation checks for Database, Schema, Warehouse and Role at the time a\nconnection is established. Can also be sourced from the `SNOWFLAKE_VALIDATE_DEFAULT_PARAMETERS` environment variable.\n"
            },
            "warehouse": {
                "type": "string",
                "description": "Specifies the virtual warehouse to use by default for queries, loading, etc. in the client session. Can also be sourced\nfrom the `SNOWFLAKE_WAREHOUSE` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_WAREHOUSE"
                    ]
                }
            }
        }
    },
    "types": {
        "snowflake:config/tokenAccessor:tokenAccessor": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "secret": true
                },
                "clientSecret": {
                    "type": "string",
                    "secret": true
                },
                "redirectUri": {
                    "type": "string",
                    "secret": true
                },
                "refreshToken": {
                    "type": "string",
                    "secret": true
                },
                "tokenEndpoint": {
                    "type": "string",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "clientId",
                "clientSecret",
                "redirectUri",
                "refreshToken",
                "tokenEndpoint"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/AlertAlertSchedule:AlertAlertSchedule": {
            "properties": {
                "cron": {
                    "$ref": "#/types/snowflake:index/AlertAlertScheduleCron:AlertAlertScheduleCron",
                    "description": "Specifies the cron expression for the alert. The cron expression must be in the following format: \"minute hour day-of-month month day-of-week\". The following values are supported: minute: 0-59 hour: 0-23 day-of-month: 1-31 month: 1-12 day-of-week: 0-6 (0 is Sunday)\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "Specifies the interval in minutes for the alert schedule. The interval must be greater than 0 and less than 1440 (24 hours).\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/AlertAlertScheduleCron:AlertAlertScheduleCron": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Specifies the cron expression for the alert. The cron expression must be in the following format: \"minute hour day-of-month month day-of-week\". The following values are supported: minute: 0-59 hour: 0-23 day-of-month: 1-31 month: 1-12 day-of-week: 0-6 (0 is Sunday)\n"
                },
                "timeZone": {
                    "type": "string",
                    "description": "Specifies the time zone for alert refresh.\n"
                }
            },
            "type": "object",
            "required": [
                "expression",
                "timeZone"
            ]
        },
        "snowflake:index/DatabaseReplicationConfiguration:DatabaseReplicationConfiguration": {
            "properties": {
                "accounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ignoreEditionCheck": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "accounts"
            ]
        },
        "snowflake:index/DynamicTableTargetLag:DynamicTableTargetLag": {
            "properties": {
                "downstream": {
                    "type": "boolean",
                    "description": "Specifies whether the target lag time is downstream.\n"
                },
                "maximumDuration": {
                    "type": "string",
                    "description": "Specifies the maximum target lag time for the dynamic table.\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/ExternalFunctionArg:ExternalFunctionArg": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Argument name\n"
                },
                "type": {
                    "type": "string",
                    "description": "Argument type, e.g. VARCHAR\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/ExternalFunctionHeader:ExternalFunctionHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Header name\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Header value\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/ExternalTableColumn:ExternalTableColumn": {
            "properties": {
                "as": {
                    "type": "string",
                    "description": "String that specifies the expression for the column. When queried, the column returns results derived from this expression.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Column name\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Column type, e.g. VARIANT\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "as",
                "name",
                "type"
            ]
        },
        "snowflake:index/ExternalTableTag:ExternalTableTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Tag value, e.g. marketing_info.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/FailoverGroupFromReplica:FailoverGroupFromReplica": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Identifier for the primary failover group in the source account.\n"
                },
                "organizationName": {
                    "type": "string",
                    "description": "Name of your Snowflake organization.\n"
                },
                "sourceAccountName": {
                    "type": "string",
                    "description": "Source account from which you are enabling replication and failover of the specified objects.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "organizationName",
                "sourceAccountName"
            ]
        },
        "snowflake:index/FailoverGroupReplicationSchedule:FailoverGroupReplicationSchedule": {
            "properties": {
                "cron": {
                    "$ref": "#/types/snowflake:index/FailoverGroupReplicationScheduleCron:FailoverGroupReplicationScheduleCron",
                    "description": "Specifies the cron expression for the replication schedule. The cron expression must be in the following format: \"minute hour day-of-month month day-of-week\". The following values are supported: minute: 0-59 hour: 0-23 day-of-month: 1-31 month: 1-12 day-of-week: 0-6 (0 is Sunday)\n"
                },
                "interval": {
                    "type": "integer",
                    "description": "Specifies the interval in minutes for the replication schedule. The interval must be greater than 0 and less than 1440 (24 hours).\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/FailoverGroupReplicationScheduleCron:FailoverGroupReplicationScheduleCron": {
            "properties": {
                "expression": {
                    "type": "string",
                    "description": "Specifies the cron expression for the replication schedule. The cron expression must be in the following format: \"minute hour day-of-month month day-of-week\". The following values are supported: minute: 0-59 hour: 0-23 day-of-month: 1-31 month: 1-12 day-of-week: 0-6 (0 is Sunday)\n"
                },
                "timeZone": {
                    "type": "string",
                    "description": "Specifies the time zone for secondary group refresh.\n"
                }
            },
            "type": "object",
            "required": [
                "expression",
                "timeZone"
            ]
        },
        "snowflake:index/FunctionArgument:FunctionArgument": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The argument name\n"
                },
                "type": {
                    "type": "string",
                    "description": "The argument type\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/GrantPrivilegesToDatabaseRoleOnSchema:GrantPrivilegesToDatabaseRoleOnSchema": {
            "properties": {
                "allSchemasInDatabase": {
                    "type": "string",
                    "description": "The fully qualified name of the database.\n",
                    "willReplaceOnChanges": true
                },
                "futureSchemasInDatabase": {
                    "type": "string",
                    "description": "The fully qualified name of the database.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The fully qualified name of the schema.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "snowflake:index/GrantPrivilegesToDatabaseRoleOnSchemaObject:GrantPrivilegesToDatabaseRoleOnSchemaObject": {
            "properties": {
                "all": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToDatabaseRoleOnSchemaObjectAll:GrantPrivilegesToDatabaseRoleOnSchemaObjectAll",
                    "description": "Configures the privilege to be granted on all objects in either a database or schema.\n",
                    "willReplaceOnChanges": true
                },
                "future": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToDatabaseRoleOnSchemaObjectFuture:GrantPrivilegesToDatabaseRoleOnSchemaObjectFuture",
                    "description": "Configures the privilege to be granted on future objects in either a database or schema.\n",
                    "willReplaceOnChanges": true
                },
                "objectName": {
                    "type": "string",
                    "description": "The fully qualified name of the object on which privileges will be granted.\n",
                    "willReplaceOnChanges": true
                },
                "objectType": {
                    "type": "string",
                    "description": "The object type of the schema object on which privileges will be granted. Valid values are: ALERT | DYNAMIC TABLE | EVENT TABLE | FILE FORMAT | FUNCTION | PROCEDURE | SECRET | SEQUENCE | PIPE | MASKING POLICY | PASSWORD POLICY | ROW ACCESS POLICY | SESSION POLICY | TAG | STAGE | STREAM | TABLE | EXTERNAL TABLE | TASK | VIEW | MATERIALIZED VIEW | NETWORK RULE | PACKAGES POLICY | ICEBERG TABLE\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "snowflake:index/GrantPrivilegesToDatabaseRoleOnSchemaObjectAll:GrantPrivilegesToDatabaseRoleOnSchemaObjectAll": {
            "properties": {
                "inDatabase": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "inSchema": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "objectTypePlural": {
                    "type": "string",
                    "description": "The plural object type of the schema object on which privileges will be granted. Valid values are: ALERTS | DYNAMIC TABLES | EVENT TABLES | FILE FORMATS | FUNCTIONS | PROCEDURES | SECRETS | SEQUENCES | PIPES | MASKING POLICIES | PASSWORD POLICIES | ROW ACCESS POLICIES | SESSION POLICIES | TAGS | STAGES | STREAMS | TABLES | EXTERNAL TABLES | TASKS | VIEWS | MATERIALIZED VIEWS | NETWORK RULES | PACKAGES POLICIES | ICEBERG TABLES\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "objectTypePlural"
            ]
        },
        "snowflake:index/GrantPrivilegesToDatabaseRoleOnSchemaObjectFuture:GrantPrivilegesToDatabaseRoleOnSchemaObjectFuture": {
            "properties": {
                "inDatabase": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "inSchema": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "objectTypePlural": {
                    "type": "string",
                    "description": "The plural object type of the schema object on which privileges will be granted. Valid values are: ALERTS | DYNAMIC TABLES | EVENT TABLES | FILE FORMATS | FUNCTIONS | PROCEDURES | SECRETS | SEQUENCES | PIPES | MASKING POLICIES | PASSWORD POLICIES | ROW ACCESS POLICIES | SESSION POLICIES | TAGS | STAGES | STREAMS | TABLES | EXTERNAL TABLES | TASKS | VIEWS | MATERIALIZED VIEWS | NETWORK RULES | PACKAGES POLICIES | ICEBERG TABLES\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "objectTypePlural"
            ]
        },
        "snowflake:index/GrantPrivilegesToRoleOnAccountObject:GrantPrivilegesToRoleOnAccountObject": {
            "properties": {
                "objectName": {
                    "type": "string",
                    "description": "The fully qualified name of the object on which privileges will be granted.\n"
                },
                "objectType": {
                    "type": "string",
                    "description": "The object type of the account object on which privileges will be granted. Valid values are: USER | RESOURCE MONITOR | WAREHOUSE | DATABASE | INTEGRATION | FAILOVER GROUP | REPLICATION GROUP | EXTERNAL VOLUME\n"
                }
            },
            "type": "object",
            "required": [
                "objectName",
                "objectType"
            ]
        },
        "snowflake:index/GrantPrivilegesToRoleOnSchema:GrantPrivilegesToRoleOnSchema": {
            "properties": {
                "allSchemasInDatabase": {
                    "type": "string",
                    "description": "The fully qualified name of the database.\n",
                    "willReplaceOnChanges": true
                },
                "futureSchemasInDatabase": {
                    "type": "string",
                    "description": "The fully qualified name of the database.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The fully qualified name of the schema.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "snowflake:index/GrantPrivilegesToRoleOnSchemaObject:GrantPrivilegesToRoleOnSchemaObject": {
            "properties": {
                "all": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnSchemaObjectAll:GrantPrivilegesToRoleOnSchemaObjectAll",
                    "description": "Configures the privilege to be granted on all objects in eihter a database or schema.\n",
                    "willReplaceOnChanges": true
                },
                "future": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnSchemaObjectFuture:GrantPrivilegesToRoleOnSchemaObjectFuture",
                    "description": "Configures the privilege to be granted on future objects in eihter a database or schema.\n",
                    "willReplaceOnChanges": true
                },
                "objectName": {
                    "type": "string",
                    "description": "The fully qualified name of the object on which privileges will be granted.\n",
                    "willReplaceOnChanges": true
                },
                "objectType": {
                    "type": "string",
                    "description": "The object type of the schema object on which privileges will be granted. Valid values are: ALERT | DYNAMIC TABLE | EVENT TABLE | FILE FORMAT | FUNCTION | ICEBERG TABLE | PROCEDURE | SECRET | SEQUENCE | PIPE | MASKING POLICY | PASSWORD POLICY | ROW ACCESS POLICY | SESSION POLICY | TAG | STAGE | STREAM | TABLE | EXTERNAL TABLE | TASK | VIEW | MATERIALIZED VIEW\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "snowflake:index/GrantPrivilegesToRoleOnSchemaObjectAll:GrantPrivilegesToRoleOnSchemaObjectAll": {
            "properties": {
                "inDatabase": {
                    "type": "string",
                    "description": "The fully qualified name of the database.\n",
                    "willReplaceOnChanges": true
                },
                "inSchema": {
                    "type": "string",
                    "description": "The fully qualified name of the schema.\n",
                    "willReplaceOnChanges": true
                },
                "objectTypePlural": {
                    "type": "string",
                    "description": "The plural object type of the schema object on which privileges will be granted. Valid values are: ALERTS | DYNAMIC TABLES | EVENT TABLES | FILE FORMATS | FUNCTIONS | ICEBERG TABLES | PROCEDURES | SECRETS | SEQUENCES | PIPES | MASKING POLICIES | PASSWORD POLICIES | ROW ACCESS POLICIES | SESSION POLICIES | TAGS | STAGES | STREAMS | TABLES | EXTERNAL TABLES | TASKS | VIEWS | MATERIALIZED VIEWS\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "objectTypePlural"
            ]
        },
        "snowflake:index/GrantPrivilegesToRoleOnSchemaObjectFuture:GrantPrivilegesToRoleOnSchemaObjectFuture": {
            "properties": {
                "inDatabase": {
                    "type": "string",
                    "description": "The fully qualified name of the database.\n",
                    "willReplaceOnChanges": true
                },
                "inSchema": {
                    "type": "string",
                    "description": "The fully qualified name of the schema.\n",
                    "willReplaceOnChanges": true
                },
                "objectTypePlural": {
                    "type": "string",
                    "description": "The plural object type of the schema object on which privileges will be granted. Valid values are: ALERTS | DYNAMIC TABLES | EVENT TABLES | FILE FORMATS | FUNCTIONS | ICEBERG TABLES | PROCEDURES | SECRETS | SEQUENCES | PIPES | MASKING POLICIES | PASSWORD POLICIES | ROW ACCESS POLICIES | SESSION POLICIES | TAGS | STAGES | STREAMS | TABLES | EXTERNAL TABLES | TASKS | VIEWS | MATERIALIZED VIEWS\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "objectTypePlural"
            ]
        },
        "snowflake:index/MaskingPolicySignature:MaskingPolicySignature": {
            "properties": {
                "columns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/MaskingPolicySignatureColumn:MaskingPolicySignatureColumn"
                    }
                }
            },
            "type": "object",
            "required": [
                "columns"
            ]
        },
        "snowflake:index/MaskingPolicySignatureColumn:MaskingPolicySignatureColumn": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Specifies the column name to mask.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the column type to mask.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/MaterializedViewTag:MaterializedViewTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Tag value, e.g. marketing_info.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/ObjectParameterObjectIdentifier:ObjectParameterObjectIdentifier": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Name of the database that the object was created in.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of the object to set the parameter for.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the object was created in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "snowflake:index/ProcedureArgument:ProcedureArgument": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The argument name\n"
                },
                "type": {
                    "type": "string",
                    "description": "The argument type\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/ProviderTokenAccessor:ProviderTokenAccessor": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "secret": true
                },
                "clientSecret": {
                    "type": "string",
                    "secret": true
                },
                "redirectUri": {
                    "type": "string",
                    "secret": true
                },
                "refreshToken": {
                    "type": "string",
                    "secret": true
                },
                "tokenEndpoint": {
                    "type": "string",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "clientId",
                "clientSecret",
                "redirectUri",
                "refreshToken",
                "tokenEndpoint"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "snowflake:index/RoleTag:RoleTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Tag value, e.g. marketing_info.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/SchemaTag:SchemaTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Tag value, e.g. marketing_info.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/StageTag:StageTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Tag value, e.g. marketing_info.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/TableColumn:TableColumn": {
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Column comment\n"
                },
                "default": {
                    "$ref": "#/types/snowflake:index/TableColumnDefault:TableColumnDefault",
                    "description": "Defines the column default value; note due to limitations of Snowflake's ALTER TABLE ADD/MODIFY COLUMN updates to default will not be applied\n"
                },
                "identity": {
                    "$ref": "#/types/snowflake:index/TableColumnIdentity:TableColumnIdentity",
                    "description": "Defines the identity start/step values for a column. **Note** Identity/default are mutually exclusive.\n"
                },
                "maskingPolicy": {
                    "type": "string",
                    "description": "Masking policy to apply on column\n"
                },
                "name": {
                    "type": "string",
                    "description": "Column name\n"
                },
                "nullable": {
                    "type": "boolean",
                    "description": "Whether this column can contain null values. **Note**: Depending on your Snowflake version, the default value will not suffice if this column is used in a primary key constraint.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Column type, e.g. VARIANT\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ]
        },
        "snowflake:index/TableColumnDefault:TableColumnDefault": {
            "properties": {
                "constant": {
                    "type": "string",
                    "description": "The default constant value for the column\n"
                },
                "expression": {
                    "type": "string",
                    "description": "The default expression value for the column\n"
                },
                "sequence": {
                    "type": "string",
                    "description": "The default sequence to use for the column\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/TableColumnIdentity:TableColumnIdentity": {
            "properties": {
                "startNum": {
                    "type": "integer",
                    "description": "The number to start incrementing at.\n"
                },
                "stepNum": {
                    "type": "integer",
                    "description": "Step size to increment by.\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/TableConstraintForeignKeyProperties:TableConstraintForeignKeyProperties": {
            "properties": {
                "match": {
                    "type": "string",
                    "description": "The match type for the foreign key. Not applicable for primary/unique keys\n",
                    "willReplaceOnChanges": true
                },
                "onDelete": {
                    "type": "string",
                    "description": "Specifies the action performed when the primary/unique key for the foreign key is deleted. Not applicable for primary/unique keys\n",
                    "willReplaceOnChanges": true
                },
                "onUpdate": {
                    "type": "string",
                    "description": "Specifies the action performed when the primary/unique key for the foreign key is updated. Not applicable for primary/unique keys\n",
                    "willReplaceOnChanges": true
                },
                "references": {
                    "$ref": "#/types/snowflake:index/TableConstraintForeignKeyPropertiesReferences:TableConstraintForeignKeyPropertiesReferences",
                    "description": "The table and columns that the foreign key references. Not applicable for primary/unique keys\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "snowflake:index/TableConstraintForeignKeyPropertiesReferences:TableConstraintForeignKeyPropertiesReferences": {
            "properties": {
                "columns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Columns to use in foreign key reference\n"
                },
                "tableId": {
                    "type": "string",
                    "description": "Name of constraint\n"
                }
            },
            "type": "object",
            "required": [
                "columns",
                "tableId"
            ]
        },
        "snowflake:index/TablePrimaryKey:TablePrimaryKey": {
            "properties": {
                "keys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Columns to use in primary key\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of constraint\n"
                }
            },
            "type": "object",
            "required": [
                "keys"
            ]
        },
        "snowflake:index/TableTag:TableTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Tag value, e.g. marketing_info.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/TagAssociationObjectIdentifier:TagAssociationObjectIdentifier": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Name of the database that the object was created in.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of the object to associate the tag with.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the object was created in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "snowflake:index/ViewTag:ViewTag": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Tag value, e.g. marketing_info.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "snowflake:index/getAccountsAccount:getAccountsAccount": {
            "properties": {
                "accountLocator": {
                    "type": "string"
                },
                "accountLocatorUrl": {
                    "type": "string"
                },
                "accountName": {
                    "type": "string"
                },
                "accountUrl": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "consumptionBillingEntityName": {
                    "type": "string"
                },
                "createdOn": {
                    "type": "string"
                },
                "edition": {
                    "type": "string"
                },
                "isOrgAdmin": {
                    "type": "boolean"
                },
                "managedAccounts": {
                    "type": "integer"
                },
                "marketplaceConsumerBillingEntityName": {
                    "type": "string"
                },
                "marketplaceProviderBillingEntityName": {
                    "type": "string"
                },
                "oldAccountUrl": {
                    "type": "string"
                },
                "organizationName": {
                    "type": "string"
                },
                "regionGroup": {
                    "type": "string"
                },
                "snowflakeRegion": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "accountLocator",
                "accountLocatorUrl",
                "accountName",
                "accountUrl",
                "comment",
                "consumptionBillingEntityName",
                "createdOn",
                "edition",
                "isOrgAdmin",
                "managedAccounts",
                "marketplaceConsumerBillingEntityName",
                "marketplaceProviderBillingEntityName",
                "oldAccountUrl",
                "organizationName",
                "regionGroup",
                "snowflakeRegion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getAlertsAlert:getAlertsAlert": {
            "properties": {
                "action": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "condition": {
                    "type": "string"
                },
                "databaseName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "owner": {
                    "type": "string"
                },
                "schemaName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "action",
                "comment",
                "condition",
                "databaseName",
                "name",
                "owner",
                "schemaName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getDatabaseRolesDatabaseRole:getDatabaseRolesDatabaseRole": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "owner": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "name",
                "owner"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getDatabasesDatabase:getDatabasesDatabase": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "createdOn": {
                    "type": "string"
                },
                "isCurrent": {
                    "type": "boolean"
                },
                "isDefault": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "options": {
                    "type": "string"
                },
                "origin": {
                    "type": "string"
                },
                "owner": {
                    "type": "string"
                },
                "replicationConfigurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/getDatabasesDatabaseReplicationConfiguration:getDatabasesDatabaseReplicationConfiguration"
                    }
                },
                "retentionTime": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "createdOn",
                "isCurrent",
                "isDefault",
                "name",
                "options",
                "origin",
                "owner",
                "replicationConfigurations",
                "retentionTime"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getDatabasesDatabaseReplicationConfiguration:getDatabasesDatabaseReplicationConfiguration": {
            "properties": {
                "accounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ignoreEditionCheck": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "accounts",
                "ignoreEditionCheck"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getDynamicTablesIn:getDynamicTablesIn": {
            "properties": {
                "account": {
                    "type": "boolean",
                    "description": "Returns records for the entire account.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Returns records for the current database in use or for a specified database (db_name).\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Returns records for the current schema in use or a specified schema (schema_name).\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/getDynamicTablesLike:getDynamicTablesLike": {
            "properties": {
                "pattern": {
                    "type": "string",
                    "description": "Filters the command output by object name. The filter uses case-insensitive pattern matching with support for SQL wildcard characters (% and _).\n"
                }
            },
            "type": "object",
            "required": [
                "pattern"
            ]
        },
        "snowflake:index/getDynamicTablesLimit:getDynamicTablesLimit": {
            "properties": {
                "from": {
                    "type": "string",
                    "description": "The optional FROM 'name_string' subclause effectively serves as a “cursor” for the results. This enables fetching the specified number of rows following the first row whose object name matches the specified string\n"
                },
                "rows": {
                    "type": "integer",
                    "description": "Specifies the maximum number of rows to return.\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/getDynamicTablesRecord:getDynamicTablesRecord": {
            "properties": {
                "automaticClustering": {
                    "type": "boolean"
                },
                "bytes": {
                    "type": "integer"
                },
                "clusterBy": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "createdOn": {
                    "type": "string"
                },
                "dataTimestamp": {
                    "type": "string"
                },
                "databaseName": {
                    "type": "string"
                },
                "isClone": {
                    "type": "boolean"
                },
                "isReplica": {
                    "type": "boolean"
                },
                "lastSuspendedOn": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "owner": {
                    "type": "string"
                },
                "refreshMode": {
                    "type": "string"
                },
                "refreshModeReason": {
                    "type": "string"
                },
                "rows": {
                    "type": "integer"
                },
                "schedulingState": {
                    "type": "string"
                },
                "schemaName": {
                    "type": "string"
                },
                "targetLag": {
                    "type": "string"
                },
                "text": {
                    "type": "string"
                },
                "warehouse": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "automaticClustering",
                "bytes",
                "clusterBy",
                "comment",
                "createdOn",
                "dataTimestamp",
                "databaseName",
                "isClone",
                "isReplica",
                "lastSuspendedOn",
                "name",
                "owner",
                "refreshMode",
                "refreshModeReason",
                "rows",
                "schedulingState",
                "schemaName",
                "targetLag",
                "text",
                "warehouse"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getExternalFunctionsExternalFunction:getExternalFunctionsExternalFunction": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "language": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "language",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getExternalTablesExternalTable:getExternalTablesExternalTable": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getFailoverGroupsFailoverGroup:getFailoverGroupsFailoverGroup": {
            "properties": {
                "accountLocator": {
                    "type": "string"
                },
                "accountName": {
                    "type": "string"
                },
                "allowedAccounts": {
                    "type": "array",
                    "items": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "allowedIntegrationTypes": {
                    "type": "array",
                    "items": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "comment": {
                    "type": "string"
                },
                "createdOn": {
                    "type": "string"
                },
                "isPrimary": {
                    "type": "boolean"
                },
                "nextScheduledRefresh": {
                    "type": "string"
                },
                "objectTypes": {
                    "type": "array",
                    "items": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "organizationName": {
                    "type": "string"
                },
                "owner": {
                    "type": "string"
                },
                "primary": {
                    "type": "string"
                },
                "regionGroup": {
                    "type": "string"
                },
                "replicationSchedule": {
                    "type": "string"
                },
                "secondaryState": {
                    "type": "string"
                },
                "snowflakeRegion": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "accountLocator",
                "accountName",
                "allowedAccounts",
                "allowedIntegrationTypes",
                "comment",
                "createdOn",
                "isPrimary",
                "nextScheduledRefresh",
                "objectTypes",
                "organizationName",
                "owner",
                "primary",
                "regionGroup",
                "replicationSchedule",
                "secondaryState",
                "snowflakeRegion",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getFileFormatsFileFormat:getFileFormatsFileFormat": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "formatType": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "formatType",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getFunctionsFunction:getFunctionsFunction": {
            "properties": {
                "argumentTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "returnType": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "argumentTypes",
                "comment",
                "database",
                "name",
                "returnType",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getGrantsFutureGrantsIn:getGrantsFutureGrantsIn": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "Lists all privileges on new (i.e. future) objects of a specified type in the database granted to a role.\n"
                },
                "schema": {
                    "$ref": "#/types/snowflake:index/getGrantsFutureGrantsInSchema:getGrantsFutureGrantsInSchema",
                    "description": "Lists all privileges on new (i.e. future) objects of a specified type in the schema granted to a role.\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/getGrantsFutureGrantsInSchema:getGrantsFutureGrantsInSchema": {
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The database in which the scehma resides. Optional when querying a schema in the current database.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema to list all privileges of new (ie. future) objects granted to\n"
                }
            },
            "type": "object",
            "required": [
                "schemaName"
            ]
        },
        "snowflake:index/getGrantsFutureGrantsTo:getGrantsFutureGrantsTo": {
            "properties": {
                "role": {
                    "type": "string",
                    "description": "Lists all privileges on new (i.e. future) objects of a specified type in a database or schema granted to the role.\n"
                }
            },
            "type": "object",
            "required": [
                "role"
            ]
        },
        "snowflake:index/getGrantsGrant:getGrantsGrant": {
            "properties": {
                "createdOn": {
                    "type": "string"
                },
                "grantOption": {
                    "type": "boolean"
                },
                "grantedBy": {
                    "type": "string"
                },
                "grantedOn": {
                    "type": "string"
                },
                "grantedTo": {
                    "type": "string"
                },
                "granteeName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "privilege": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "createdOn",
                "grantOption",
                "grantedBy",
                "grantedOn",
                "grantedTo",
                "granteeName",
                "name",
                "privilege"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getGrantsGrantsOf:getGrantsGrantsOf": {
            "properties": {
                "role": {
                    "type": "string",
                    "description": "Lists all users and roles to which the role has been granted\n"
                },
                "share": {
                    "type": "string",
                    "description": "Lists all the accounts for the share and indicates the accounts that are using the share.\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/getGrantsGrantsOn:getGrantsGrantsOn": {
            "properties": {
                "account": {
                    "type": "boolean",
                    "description": "Object hierarchy to list privileges on. The only valid value is: ACCOUNT. Setting this attribute lists all the account-level (i.e. global) privileges that have been granted to roles.\n"
                },
                "objectName": {
                    "type": "string",
                    "description": "Name of object to list privileges on\n"
                },
                "objectType": {
                    "type": "string",
                    "description": "Type of object to list privileges on.\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/getGrantsGrantsTo:getGrantsGrantsTo": {
            "properties": {
                "role": {
                    "type": "string",
                    "description": "Lists all privileges and roles granted to the role\n"
                },
                "share": {
                    "type": "string",
                    "description": "Lists all the privileges granted to the share\n"
                },
                "user": {
                    "type": "string",
                    "description": "Lists all the roles granted to the user. Note that the PUBLIC role, which is automatically available to every user, is not listed\n"
                }
            },
            "type": "object"
        },
        "snowflake:index/getMaskingPoliciesMaskingPolicy:getMaskingPoliciesMaskingPolicy": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "kind": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "kind",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getMaterializedViewsMaterializedView:getMaterializedViewsMaterializedView": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getParametersParameter:getParametersParameter": {
            "properties": {
                "default": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "key": {
                    "type": "string"
                },
                "level": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "default",
                "description",
                "key",
                "level",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getPipesPipe:getPipesPipe": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "integration": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "integration",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getProceduresProcedure:getProceduresProcedure": {
            "properties": {
                "argumentTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "returnType": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "argumentTypes",
                "comment",
                "database",
                "name",
                "returnType",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getResourceMonitorsResourceMonitor:getResourceMonitorsResourceMonitor": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "creditQuota": {
                    "type": "string"
                },
                "frequency": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "creditQuota",
                "frequency",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getRolesRole:getRolesRole": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "owner": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "name",
                "owner"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getRowAccessPoliciesRowAccessPolicy:getRowAccessPoliciesRowAccessPolicy": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getSchemasSchema:getSchemasSchema": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getSequencesSequence:getSequencesSequence": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getSharesShare:getSharesShare": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "kind": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "owner": {
                    "type": "string"
                },
                "tos": {
                    "type": "array",
                    "items": {
                        "$ref": "pulumi.json#/Any"
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "kind",
                "name",
                "owner",
                "tos"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getStagesStage:getStagesStage": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                },
                "storageIntegration": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema",
                "storageIntegration"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getStorageIntegrationsStorageIntegration:getStorageIntegrationsStorageIntegration": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "enabled",
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getStreamsStream:getStreamsStream": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                },
                "table": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema",
                "table"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getTablesTable:getTablesTable": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getTasksTask:getTasksTask": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                },
                "warehouse": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema",
                "warehouse"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getUsersUser:getUsersUser": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "defaultNamespace": {
                    "type": "string"
                },
                "defaultRole": {
                    "type": "string"
                },
                "defaultSecondaryRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "defaultWarehouse": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "displayName": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "hasRsaPublicKey": {
                    "type": "boolean"
                },
                "lastName": {
                    "type": "string"
                },
                "loginName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "defaultNamespace",
                "defaultRole",
                "defaultSecondaryRoles",
                "defaultWarehouse",
                "disabled",
                "displayName",
                "email",
                "firstName",
                "hasRsaPublicKey",
                "lastName",
                "loginName",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getViewsView:getViewsView": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "schema": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "database",
                "name",
                "schema"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "snowflake:index/getWarehousesWarehouse:getWarehousesWarehouse": {
            "properties": {
                "comment": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "scalingPolicy": {
                    "type": "string"
                },
                "size": {
                    "type": "string"
                },
                "state": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "name",
                "scalingPolicy",
                "size",
                "state",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the snowflake package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "account": {
                "type": "string",
                "description": "Specifies your Snowflake account identifier assigned, by Snowflake. For information about account identifiers, see the\n[Snowflake documentation](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html). Can also be sourced\nfrom the `SNOWFLAKE_ACCOUNT` environment variable. Required unless using `profile`.\n"
            },
            "authenticator": {
                "type": "string",
                "description": "Specifies the [authentication type](https://pkg.go.dev/github.com/snowflakedb/gosnowflake#AuthType) to use when\nconnecting to Snowflake. Valid values include: Snowflake, OAuth, ExternalBrowser, Okta, JWT, TokenAccessor,\nUsernamePasswordMFA. Can also be sourced from the `SNOWFLAKE_AUTHENTICATOR` environment variable.\n"
            },
            "browserAuth": {
                "type": "boolean",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_USE_BROWSER_AUTH` environment variable.\n",
                "deprecationMessage": "Use `authenticator` instead"
            },
            "clientIp": {
                "type": "string",
                "description": "IP address for network checks. Can also be sourced from the `SNOWFLAKE_CLIENT_IP` environment variable.\n"
            },
            "clientRequestMfaToken": {
                "type": "boolean",
                "description": "When true the MFA token is cached in the credential manager. True by default in Windows/OSX. False for Linux. Can also\nbe sourced from the `SNOWFLAKE_CLIENT_REQUEST_MFA_TOKEN` environment variable.\n"
            },
            "clientStoreTemporaryCredential": {
                "type": "boolean",
                "description": "When true the ID token is cached in the credential manager. True by default in Windows/OSX. False for Linux. Can also be\nsourced from the `SNOWFLAKE_CLIENT_STORE_TEMPORARY_CREDENTIAL` environment variable.\n"
            },
            "clientTimeout": {
                "type": "integer",
                "description": "The timeout in seconds for the client to complete the authentication. Default is 900 seconds. Can also be sourced from\nthe `SNOWFLAKE_CLIENT_TIMEOUT` environment variable.\n"
            },
            "disableQueryContextCache": {
                "type": "boolean",
                "description": "Should HTAP query context cache be disabled. Can also be sourced from the `SNOWFLAKE_DISABLE_QUERY_CONTEXT_CACHE`\nenvironment variable.\n"
            },
            "disableTelemetry": {
                "type": "boolean",
                "description": "Indicates whether to disable telemetry. Can also be sourced from the `SNOWFLAKE_DISABLE_TELEMETRY` environment variable.\n"
            },
            "externalBrowserTimeout": {
                "type": "integer",
                "description": "The timeout in seconds for the external browser to complete the authentication. Default is 120 seconds. Can also be\nsourced from the `SNOWFLAKE_EXTERNAL_BROWSER_TIMEOUT` environment variable.\n"
            },
            "host": {
                "type": "string",
                "description": "Supports passing in a custom host value to the snowflake go driver for use with privatelink. Can also be sourced from\nthe `SNOWFLAKE_HOST` environment variable.\n"
            },
            "insecureMode": {
                "type": "boolean",
                "description": "If true, bypass the Online Certificate Status Protocol (OCSP) certificate revocation check. IMPORTANT: Change the\ndefault value for testing or emergency situations only. Can also be sourced from the `SNOWFLAKE_INSECURE_MODE`\nenvironment variable.\n"
            },
            "jwtClientTimeout": {
                "type": "integer",
                "description": "The timeout in seconds for the JWT client to complete the authentication. Default is 10 seconds. Can also be sourced\nfrom the `SNOWFLAKE_JWT_CLIENT_TIMEOUT` environment variable.\n"
            },
            "jwtExpireTimeout": {
                "type": "integer",
                "description": "JWT expire after timeout in seconds. Can also be sourced from the `SNOWFLAKE_JWT_EXPIRE_TIMEOUT` environment variable.\n"
            },
            "keepSessionAlive": {
                "type": "boolean",
                "description": "Enables the session to persist even after the connection is closed. Can also be sourced from the\n`SNOWFLAKE_KEEP_SESSION_ALIVE` environment variable.\n"
            },
            "loginTimeout": {
                "type": "integer",
                "description": "Login retry timeout EXCLUDING network roundtrip and read out http response. Can also be sourced from the\n`SNOWFLAKE_LOGIN_TIMEOUT` environment variable.\n"
            },
            "oauthAccessToken": {
                "type": "string",
                "description": "Token for use with OAuth. Generating the token is left to other tools. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_refresh_token` or `password`. Can also be sourced from `SNOWFLAKE_OAUTH_ACCESS_TOKEN`\nenvironment variable.\n",
                "deprecationMessage": "Use `token` instead",
                "secret": true
            },
            "oauthClientId": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_CLIENT_ID` environment variable.\n",
                "deprecationMessage": "Use `token_accessor.0.client_id` instead",
                "secret": true
            },
            "oauthClientSecret": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_CLIENT_SECRET` environment\nvariable.\n",
                "deprecationMessage": "Use `token_accessor.0.client_secret` instead",
                "secret": true
            },
            "oauthEndpoint": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_ENDPOINT` environment variable.\n",
                "deprecationMessage": "Use `token_accessor.0.token_endpoint` instead",
                "secret": true
            },
            "oauthRedirectUrl": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_REDIRECT_URL` environment\nvariable.\n",
                "deprecationMessage": "Use `token_accessor.0.redirect_uri` instead",
                "secret": true
            },
            "oauthRefreshToken": {
                "type": "string",
                "description": "Token for use with OAuth. Setup and generation of the token is left to other tools. Should be used in conjunction with\n`oauth_client_id`, `oauth_client_secret`, `oauth_endpoint`, `oauth_redirect_url`. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_access_token` or `password`. Can also be sourced from `SNOWFLAKE_OAUTH_REFRESH_TOKEN`\nenvironment variable.\n",
                "deprecationMessage": "Use `token_accessor.0.refresh_token` instead",
                "secret": true
            },
            "ocspFailOpen": {
                "type": "boolean",
                "description": "True represents OCSP fail open mode. False represents OCSP fail closed mode. Fail open true by default. Can also be\nsourced from the `SNOWFLAKE_OCSP_FAIL_OPEN` environment variable.\n"
            },
            "oktaUrl": {
                "type": "string",
                "description": "The URL of the Okta server. e.g. https://example.okta.com. Can also be sourced from the `SNOWFLAKE_OKTA_URL` environment\nvariable.\n"
            },
            "params": {
                "type": "object",
                "additionalProperties": {
                    "$ref": "pulumi.json#/Any"
                },
                "description": "Sets other connection (i.e. session) parameters. [Parameters](https://docs.snowflake.com/en/sql-reference/parameters)\n"
            },
            "passcode": {
                "type": "string",
                "description": "Specifies the passcode provided by Duo when using multi-factor authentication (MFA) for login. Can also be sourced from\nthe `SNOWFLAKE_PASSCODE` environment variable.\n"
            },
            "passcodeInPassword": {
                "type": "boolean",
                "description": "False by default. Set to true if the MFA passcode is embedded in the login password. Appends the MFA passcode to the end\nof the password. Can also be sourced from the `SNOWFLAKE_PASSCODE_IN_PASSWORD` environment variable.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for username+password auth. Cannot be used with `browser_auth` or `private_key_path`. Can also be sourced from\nthe `SNOWFLAKE_PASSWORD` environment variable.\n",
                "secret": true
            },
            "port": {
                "type": "integer",
                "description": "Support custom port values to snowflake go driver for use with privatelink. Can also be sourced from the\n`SNOWFLAKE_PORT` environment variable.\n"
            },
            "privateKey": {
                "type": "string",
                "description": "Private Key for username+private-key auth. Cannot be used with `browser_auth` or `password`. Can also be sourced from\n`SNOWFLAKE_PRIVATE_KEY` environment variable.\n",
                "secret": true
            },
            "privateKeyPassphrase": {
                "type": "string",
                "description": "Supports the encryption ciphers aes-128-cbc, aes-128-gcm, aes-192-cbc, aes-192-gcm, aes-256-cbc, aes-256-gcm, and\ndes-ede3-cbc. Can also be sourced from `SNOWFLAKE_PRIVATE_KEY_PASSPHRASE` environment variable.\n",
                "secret": true
            },
            "privateKeyPath": {
                "type": "string",
                "description": "Path to a private key for using keypair authentication. Cannot be used with `browser_auth`, `oauth_access_token` or\n`password`. Can also be sourced from `SNOWFLAKE_PRIVATE_KEY_PATH` environment variable.\n",
                "deprecationMessage": "use the [file Function](https://developer.hashicorp.com/terraform/language/functions/file) instead",
                "secret": true
            },
            "profile": {
                "type": "string",
                "description": "Sets the profile to read from ~/.snowflake/config file. Can also be sourced from the `SNOWFLAKE_PROFILE` environment\nvariable.\n"
            },
            "protocol": {
                "type": "string",
                "description": "Either http or https, defaults to https. Can also be sourced from the `SNOWFLAKE_PROTOCOL` environment variable.\n"
            },
            "region": {
                "type": "string",
                "description": "Snowflake region, such as \"eu-central-1\", with this parameter. However, since this parameter is deprecated, it is best\nto specify the region as part of the account parameter. For details, see the description of the account parameter.\n[Snowflake region](https://docs.snowflake.com/en/user-guide/intro-regions.html) to use. Required if using the [legacy\nformat for the `account`\nidentifier](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#format-2-legacy-account-locator-in-a-region)\nin the form of `\u003ccloud_region_id\u003e.\u003ccloud\u003e`. Can also be sourced from the `SNOWFLAKE_REGION` environment variable.\n",
                "deprecationMessage": "Specify the region as part of the account parameter"
            },
            "requestTimeout": {
                "type": "integer",
                "description": "request retry timeout EXCLUDING network roundtrip and read out http response. Can also be sourced from the\n`SNOWFLAKE_REQUEST_TIMEOUT` environment variable.\n"
            },
            "role": {
                "type": "string",
                "description": "Specifies the role to use by default for accessing Snowflake objects in the client session. Can also be sourced from the\n`SNOWFLAKE_ROLE` environment variable. .\n"
            },
            "sessionParams": {
                "type": "object",
                "additionalProperties": {
                    "$ref": "pulumi.json#/Any"
                },
                "description": "Sets session parameters. [Parameters](https://docs.snowflake.com/en/sql-reference/parameters)\n",
                "deprecationMessage": "Use `params` instead"
            },
            "token": {
                "type": "string",
                "description": "Token to use for OAuth and other forms of token based auth. Can also be sourced from the `SNOWFLAKE_TOKEN` environment\nvariable.\n",
                "secret": true
            },
            "tokenAccessor": {
                "$ref": "#/types/snowflake:index/ProviderTokenAccessor:ProviderTokenAccessor"
            },
            "user": {
                "type": "string",
                "description": "Username. Can also be sourced from the `SNOWFLAKE_USER` environment variable. Required unless using `profile`.\n"
            },
            "username": {
                "type": "string",
                "description": "Username for username+password authentication. Can also be sourced from the `SNOWFLAKE_USERNAME` environment variable.\nRequired unless using `profile`.\n",
                "deprecationMessage": "Use `user` instead of `username`"
            },
            "validateDefaultParameters": {
                "type": "boolean",
                "description": "True by default. If false, disables the validation checks for Database, Schema, Warehouse and Role at the time a\nconnection is established. Can also be sourced from the `SNOWFLAKE_VALIDATE_DEFAULT_PARAMETERS` environment variable.\n"
            },
            "warehouse": {
                "type": "string",
                "description": "Specifies the virtual warehouse to use by default for queries, loading, etc. in the client session. Can also be sourced\nfrom the `SNOWFLAKE_WAREHOUSE` environment variable.\n"
            }
        },
        "inputProperties": {
            "account": {
                "type": "string",
                "description": "Specifies your Snowflake account identifier assigned, by Snowflake. For information about account identifiers, see the\n[Snowflake documentation](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html). Can also be sourced\nfrom the `SNOWFLAKE_ACCOUNT` environment variable. Required unless using `profile`.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_ACCOUNT"
                    ]
                }
            },
            "authenticator": {
                "type": "string",
                "description": "Specifies the [authentication type](https://pkg.go.dev/github.com/snowflakedb/gosnowflake#AuthType) to use when\nconnecting to Snowflake. Valid values include: Snowflake, OAuth, ExternalBrowser, Okta, JWT, TokenAccessor,\nUsernamePasswordMFA. Can also be sourced from the `SNOWFLAKE_AUTHENTICATOR` environment variable.\n"
            },
            "browserAuth": {
                "type": "boolean",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_USE_BROWSER_AUTH` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_USE_BROWSER_AUTH"
                    ]
                },
                "deprecationMessage": "Use `authenticator` instead"
            },
            "clientIp": {
                "type": "string",
                "description": "IP address for network checks. Can also be sourced from the `SNOWFLAKE_CLIENT_IP` environment variable.\n"
            },
            "clientRequestMfaToken": {
                "type": "boolean",
                "description": "When true the MFA token is cached in the credential manager. True by default in Windows/OSX. False for Linux. Can also\nbe sourced from the `SNOWFLAKE_CLIENT_REQUEST_MFA_TOKEN` environment variable.\n"
            },
            "clientStoreTemporaryCredential": {
                "type": "boolean",
                "description": "When true the ID token is cached in the credential manager. True by default in Windows/OSX. False for Linux. Can also be\nsourced from the `SNOWFLAKE_CLIENT_STORE_TEMPORARY_CREDENTIAL` environment variable.\n"
            },
            "clientTimeout": {
                "type": "integer",
                "description": "The timeout in seconds for the client to complete the authentication. Default is 900 seconds. Can also be sourced from\nthe `SNOWFLAKE_CLIENT_TIMEOUT` environment variable.\n"
            },
            "disableQueryContextCache": {
                "type": "boolean",
                "description": "Should HTAP query context cache be disabled. Can also be sourced from the `SNOWFLAKE_DISABLE_QUERY_CONTEXT_CACHE`\nenvironment variable.\n"
            },
            "disableTelemetry": {
                "type": "boolean",
                "description": "Indicates whether to disable telemetry. Can also be sourced from the `SNOWFLAKE_DISABLE_TELEMETRY` environment variable.\n"
            },
            "externalBrowserTimeout": {
                "type": "integer",
                "description": "The timeout in seconds for the external browser to complete the authentication. Default is 120 seconds. Can also be\nsourced from the `SNOWFLAKE_EXTERNAL_BROWSER_TIMEOUT` environment variable.\n"
            },
            "host": {
                "type": "string",
                "description": "Supports passing in a custom host value to the snowflake go driver for use with privatelink. Can also be sourced from\nthe `SNOWFLAKE_HOST` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_HOST"
                    ]
                }
            },
            "insecureMode": {
                "type": "boolean",
                "description": "If true, bypass the Online Certificate Status Protocol (OCSP) certificate revocation check. IMPORTANT: Change the\ndefault value for testing or emergency situations only. Can also be sourced from the `SNOWFLAKE_INSECURE_MODE`\nenvironment variable.\n"
            },
            "jwtClientTimeout": {
                "type": "integer",
                "description": "The timeout in seconds for the JWT client to complete the authentication. Default is 10 seconds. Can also be sourced\nfrom the `SNOWFLAKE_JWT_CLIENT_TIMEOUT` environment variable.\n"
            },
            "jwtExpireTimeout": {
                "type": "integer",
                "description": "JWT expire after timeout in seconds. Can also be sourced from the `SNOWFLAKE_JWT_EXPIRE_TIMEOUT` environment variable.\n"
            },
            "keepSessionAlive": {
                "type": "boolean",
                "description": "Enables the session to persist even after the connection is closed. Can also be sourced from the\n`SNOWFLAKE_KEEP_SESSION_ALIVE` environment variable.\n"
            },
            "loginTimeout": {
                "type": "integer",
                "description": "Login retry timeout EXCLUDING network roundtrip and read out http response. Can also be sourced from the\n`SNOWFLAKE_LOGIN_TIMEOUT` environment variable.\n"
            },
            "oauthAccessToken": {
                "type": "string",
                "description": "Token for use with OAuth. Generating the token is left to other tools. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_refresh_token` or `password`. Can also be sourced from `SNOWFLAKE_OAUTH_ACCESS_TOKEN`\nenvironment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_ACCESS_TOKEN"
                    ]
                },
                "deprecationMessage": "Use `token` instead",
                "secret": true
            },
            "oauthClientId": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_CLIENT_ID` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_CLIENT_ID"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.client_id` instead",
                "secret": true
            },
            "oauthClientSecret": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_CLIENT_SECRET` environment\nvariable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_CLIENT_SECRET"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.client_secret` instead",
                "secret": true
            },
            "oauthEndpoint": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_ENDPOINT` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_ENDPOINT"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.token_endpoint` instead",
                "secret": true
            },
            "oauthRedirectUrl": {
                "type": "string",
                "description": "Required when `oauth_refresh_token` is used. Can also be sourced from `SNOWFLAKE_OAUTH_REDIRECT_URL` environment\nvariable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_REDIRECT_URL"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.redirect_uri` instead",
                "secret": true
            },
            "oauthRefreshToken": {
                "type": "string",
                "description": "Token for use with OAuth. Setup and generation of the token is left to other tools. Should be used in conjunction with\n`oauth_client_id`, `oauth_client_secret`, `oauth_endpoint`, `oauth_redirect_url`. Cannot be used with `browser_auth`,\n`private_key_path`, `oauth_access_token` or `password`. Can also be sourced from `SNOWFLAKE_OAUTH_REFRESH_TOKEN`\nenvironment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_OAUTH_REFRESH_TOKEN"
                    ]
                },
                "deprecationMessage": "Use `token_accessor.0.refresh_token` instead",
                "secret": true
            },
            "ocspFailOpen": {
                "type": "boolean",
                "description": "True represents OCSP fail open mode. False represents OCSP fail closed mode. Fail open true by default. Can also be\nsourced from the `SNOWFLAKE_OCSP_FAIL_OPEN` environment variable.\n"
            },
            "oktaUrl": {
                "type": "string",
                "description": "The URL of the Okta server. e.g. https://example.okta.com. Can also be sourced from the `SNOWFLAKE_OKTA_URL` environment\nvariable.\n"
            },
            "params": {
                "type": "object",
                "additionalProperties": {
                    "$ref": "pulumi.json#/Any"
                },
                "description": "Sets other connection (i.e. session) parameters. [Parameters](https://docs.snowflake.com/en/sql-reference/parameters)\n"
            },
            "passcode": {
                "type": "string",
                "description": "Specifies the passcode provided by Duo when using multi-factor authentication (MFA) for login. Can also be sourced from\nthe `SNOWFLAKE_PASSCODE` environment variable.\n"
            },
            "passcodeInPassword": {
                "type": "boolean",
                "description": "False by default. Set to true if the MFA passcode is embedded in the login password. Appends the MFA passcode to the end\nof the password. Can also be sourced from the `SNOWFLAKE_PASSCODE_IN_PASSWORD` environment variable.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for username+password auth. Cannot be used with `browser_auth` or `private_key_path`. Can also be sourced from\nthe `SNOWFLAKE_PASSWORD` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PASSWORD"
                    ]
                },
                "secret": true
            },
            "port": {
                "type": "integer",
                "description": "Support custom port values to snowflake go driver for use with privatelink. Can also be sourced from the\n`SNOWFLAKE_PORT` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PORT"
                    ]
                }
            },
            "privateKey": {
                "type": "string",
                "description": "Private Key for username+private-key auth. Cannot be used with `browser_auth` or `password`. Can also be sourced from\n`SNOWFLAKE_PRIVATE_KEY` environment variable.\n",
                "secret": true
            },
            "privateKeyPassphrase": {
                "type": "string",
                "description": "Supports the encryption ciphers aes-128-cbc, aes-128-gcm, aes-192-cbc, aes-192-gcm, aes-256-cbc, aes-256-gcm, and\ndes-ede3-cbc. Can also be sourced from `SNOWFLAKE_PRIVATE_KEY_PASSPHRASE` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PRIVATE_KEY_PASSPHRASE"
                    ]
                },
                "secret": true
            },
            "privateKeyPath": {
                "type": "string",
                "description": "Path to a private key for using keypair authentication. Cannot be used with `browser_auth`, `oauth_access_token` or\n`password`. Can also be sourced from `SNOWFLAKE_PRIVATE_KEY_PATH` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PRIVATE_KEY_PATH"
                    ]
                },
                "deprecationMessage": "use the [file Function](https://developer.hashicorp.com/terraform/language/functions/file) instead",
                "secret": true
            },
            "profile": {
                "type": "string",
                "description": "Sets the profile to read from ~/.snowflake/config file. Can also be sourced from the `SNOWFLAKE_PROFILE` environment\nvariable.\n"
            },
            "protocol": {
                "type": "string",
                "description": "Either http or https, defaults to https. Can also be sourced from the `SNOWFLAKE_PROTOCOL` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_PROTOCOL"
                    ]
                }
            },
            "region": {
                "type": "string",
                "description": "Snowflake region, such as \"eu-central-1\", with this parameter. However, since this parameter is deprecated, it is best\nto specify the region as part of the account parameter. For details, see the description of the account parameter.\n[Snowflake region](https://docs.snowflake.com/en/user-guide/intro-regions.html) to use. Required if using the [legacy\nformat for the `account`\nidentifier](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#format-2-legacy-account-locator-in-a-region)\nin the form of `\u003ccloud_region_id\u003e.\u003ccloud\u003e`. Can also be sourced from the `SNOWFLAKE_REGION` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_REGION"
                    ]
                },
                "deprecationMessage": "Specify the region as part of the account parameter"
            },
            "requestTimeout": {
                "type": "integer",
                "description": "request retry timeout EXCLUDING network roundtrip and read out http response. Can also be sourced from the\n`SNOWFLAKE_REQUEST_TIMEOUT` environment variable.\n"
            },
            "role": {
                "type": "string",
                "description": "Specifies the role to use by default for accessing Snowflake objects in the client session. Can also be sourced from the\n`SNOWFLAKE_ROLE` environment variable. .\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_ROLE"
                    ]
                }
            },
            "sessionParams": {
                "type": "object",
                "additionalProperties": {
                    "$ref": "pulumi.json#/Any"
                },
                "description": "Sets session parameters. [Parameters](https://docs.snowflake.com/en/sql-reference/parameters)\n",
                "deprecationMessage": "Use `params` instead"
            },
            "token": {
                "type": "string",
                "description": "Token to use for OAuth and other forms of token based auth. Can also be sourced from the `SNOWFLAKE_TOKEN` environment\nvariable.\n",
                "secret": true
            },
            "tokenAccessor": {
                "$ref": "#/types/snowflake:index/ProviderTokenAccessor:ProviderTokenAccessor"
            },
            "user": {
                "type": "string",
                "description": "Username. Can also be sourced from the `SNOWFLAKE_USER` environment variable. Required unless using `profile`.\n"
            },
            "username": {
                "type": "string",
                "description": "Username for username+password authentication. Can also be sourced from the `SNOWFLAKE_USERNAME` environment variable.\nRequired unless using `profile`.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_USER"
                    ]
                },
                "deprecationMessage": "Use `user` instead of `username`"
            },
            "validateDefaultParameters": {
                "type": "boolean",
                "description": "True by default. If false, disables the validation checks for Database, Schema, Warehouse and Role at the time a\nconnection is established. Can also be sourced from the `SNOWFLAKE_VALIDATE_DEFAULT_PARAMETERS` environment variable.\n"
            },
            "warehouse": {
                "type": "string",
                "description": "Specifies the virtual warehouse to use by default for queries, loading, etc. in the client session. Can also be sourced\nfrom the `SNOWFLAKE_WAREHOUSE` environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "SNOWFLAKE_WAREHOUSE"
                    ]
                }
            }
        }
    },
    "resources": {
        "snowflake:index/account:Account": {
            "description": "The account resource allows you to create and manage Snowflake accounts.\n\n    **WARNING** This resource cannot be destroyed!!! The only way to delete accounts is to go through [Snowflake Support](https://docs.snowflake.com/en/user-guide/organizations-manage-accounts.html#deleting-an-account)\n\n    **NOTE** ORGADMIN priviliges are required for this resource\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst orgadmin = new snowflake.Provider(\"orgadmin\", {role: \"ORGADMIN\"});\nconst ac1 = new snowflake.Account(\"ac1\", {\n    adminName: \"John Doe\",\n    adminPassword: \"Abcd1234!\",\n    email: \"john.doe@snowflake.com\",\n    firstName: \"John\",\n    lastName: \"Doe\",\n    mustChangePassword: true,\n    edition: \"STANDARD\",\n    comment: \"Snowflake Test Account\",\n    region: \"AWS_US_WEST_2\",\n}, {\n    provider: snowflake.orgadmin,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\norgadmin = snowflake.Provider(\"orgadmin\", role=\"ORGADMIN\")\nac1 = snowflake.Account(\"ac1\",\n    admin_name=\"John Doe\",\n    admin_password=\"Abcd1234!\",\n    email=\"john.doe@snowflake.com\",\n    first_name=\"John\",\n    last_name=\"Doe\",\n    must_change_password=True,\n    edition=\"STANDARD\",\n    comment=\"Snowflake Test Account\",\n    region=\"AWS_US_WEST_2\",\n    opts=pulumi.ResourceOptions(provider=snowflake[\"orgadmin\"]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgadmin = new Snowflake.Provider(\"orgadmin\", new()\n    {\n        Role = \"ORGADMIN\",\n    });\n\n    var ac1 = new Snowflake.Account(\"ac1\", new()\n    {\n        AdminName = \"John Doe\",\n        AdminPassword = \"Abcd1234!\",\n        Email = \"john.doe@snowflake.com\",\n        FirstName = \"John\",\n        LastName = \"Doe\",\n        MustChangePassword = true,\n        Edition = \"STANDARD\",\n        Comment = \"Snowflake Test Account\",\n        Region = \"AWS_US_WEST_2\",\n    }, new CustomResourceOptions\n    {\n        Provider = snowflake.Orgadmin,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewProvider(ctx, \"orgadmin\", \u0026snowflake.ProviderArgs{\n\t\t\tRole: pulumi.String(\"ORGADMIN\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewAccount(ctx, \"ac1\", \u0026snowflake.AccountArgs{\n\t\t\tAdminName:          pulumi.String(\"John Doe\"),\n\t\t\tAdminPassword:      pulumi.String(\"Abcd1234!\"),\n\t\t\tEmail:              pulumi.String(\"john.doe@snowflake.com\"),\n\t\t\tFirstName:          pulumi.String(\"John\"),\n\t\t\tLastName:           pulumi.String(\"Doe\"),\n\t\t\tMustChangePassword: pulumi.Bool(true),\n\t\t\tEdition:            pulumi.String(\"STANDARD\"),\n\t\t\tComment:            pulumi.String(\"Snowflake Test Account\"),\n\t\t\tRegion:             pulumi.String(\"AWS_US_WEST_2\"),\n\t\t}, pulumi.Provider(snowflake.Orgadmin))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Provider;\nimport com.pulumi.snowflake.ProviderArgs;\nimport com.pulumi.snowflake.Account;\nimport com.pulumi.snowflake.AccountArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgadmin = new Provider(\"orgadmin\", ProviderArgs.builder()        \n            .role(\"ORGADMIN\")\n            .build());\n\n        var ac1 = new Account(\"ac1\", AccountArgs.builder()        \n            .adminName(\"John Doe\")\n            .adminPassword(\"Abcd1234!\")\n            .email(\"john.doe@snowflake.com\")\n            .firstName(\"John\")\n            .lastName(\"Doe\")\n            .mustChangePassword(true)\n            .edition(\"STANDARD\")\n            .comment(\"Snowflake Test Account\")\n            .region(\"AWS_US_WEST_2\")\n            .build(), CustomResourceOptions.builder()\n                .provider(snowflake.orgadmin())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgadmin:\n    type: pulumi:providers:snowflake\n    properties:\n      role: ORGADMIN\n  ac1:\n    type: snowflake:Account\n    properties:\n      adminName: John Doe\n      adminPassword: Abcd1234!\n      email: john.doe@snowflake.com\n      firstName: John\n      lastName: Doe\n      mustChangePassword: true\n      edition: STANDARD\n      comment: Snowflake Test Account\n      region: AWS_US_WEST_2\n    options:\n      provider: ${snowflake.orgadmin}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/account:Account account \u003caccount_locator\u003e\n```\n\n ",
            "properties": {
                "adminName": {
                    "type": "string",
                    "description": "Login name of the initial administrative user of the account. A new user is created in the new account with this name and password and granted the ACCOUNTADMIN role in the account. A login name can be any string consisting of letters, numbers, and underscores. Login names are always case-insensitive.\n"
                },
                "adminPassword": {
                    "type": "string",
                    "description": "Password for the initial administrative user of the account. Optional if the `ADMIN_RSA_PUBLIC_KEY` parameter is specified. For more information about passwords in Snowflake, see [Snowflake-provided Password Policy](https://docs.snowflake.com/en/sql-reference/sql/create-account.html#:~:text=Snowflake%2Dprovided%20Password%20Policy).\n",
                    "secret": true
                },
                "adminRsaPublicKey": {
                    "type": "string",
                    "description": "Assigns a public key to the initial administrative user of the account in order to implement [key pair authentication](https://docs.snowflake.com/en/sql-reference/sql/create-account.html#:~:text=key%20pair%20authentication) for the user. Optional if the `ADMIN_PASSWORD` parameter is specified.\n",
                    "secret": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the account.\n"
                },
                "edition": {
                    "type": "string",
                    "description": "[Snowflake Edition](https://docs.snowflake.com/en/user-guide/intro-editions.html) of the account. Valid values are: STANDARD | ENTERPRISE | BUSINESS_CRITICAL\n"
                },
                "email": {
                    "type": "string",
                    "description": "Email address of the initial administrative user of the account. This email address is used to send any notifications about the account.\n",
                    "secret": true
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the initial administrative user of the account\n",
                    "secret": true
                },
                "gracePeriodInDays": {
                    "type": "integer",
                    "description": "Specifies the number of days to wait before dropping the account. The default is 3 days.\n"
                },
                "isOrgAdmin": {
                    "type": "boolean",
                    "description": "Indicates whether the ORGADMIN role is enabled in an account. If TRUE, the role is enabled.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the initial administrative user of the account\n",
                    "secret": true
                },
                "mustChangePassword": {
                    "type": "boolean",
                    "description": "Specifies whether the new user created to administer the account is forced to change their password upon first login into the account.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier (i.e. name) for the account; must be unique within an organization, regardless of which Snowflake Region the account is in. In addition, the identifier must start with an alphabetic character and cannot contain spaces or special characters except for underscores (_). Note that if the account name includes underscores, features that do not accept account names with underscores (e.g. Okta SSO or SCIM) can reference a version of the account name that substitutes hyphens (-) for the underscores.\n"
                },
                "region": {
                    "type": "string",
                    "description": "ID of the Snowflake Region where the account is created. If no value is provided, Snowflake creates the account in the same Snowflake Region as the current account (i.e. the account in which the CREATE ACCOUNT statement is executed.)\n"
                },
                "regionGroup": {
                    "type": "string",
                    "description": "ID of the Snowflake Region where the account is created. If no value is provided, Snowflake creates the account in the same Snowflake Region as the current account (i.e. the account in which the CREATE ACCOUNT statement is executed.)\n"
                }
            },
            "required": [
                "adminName",
                "edition",
                "email",
                "isOrgAdmin",
                "name"
            ],
            "inputProperties": {
                "adminName": {
                    "type": "string",
                    "description": "Login name of the initial administrative user of the account. A new user is created in the new account with this name and password and granted the ACCOUNTADMIN role in the account. A login name can be any string consisting of letters, numbers, and underscores. Login names are always case-insensitive.\n",
                    "willReplaceOnChanges": true
                },
                "adminPassword": {
                    "type": "string",
                    "description": "Password for the initial administrative user of the account. Optional if the `ADMIN_RSA_PUBLIC_KEY` parameter is specified. For more information about passwords in Snowflake, see [Snowflake-provided Password Policy](https://docs.snowflake.com/en/sql-reference/sql/create-account.html#:~:text=Snowflake%2Dprovided%20Password%20Policy).\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "adminRsaPublicKey": {
                    "type": "string",
                    "description": "Assigns a public key to the initial administrative user of the account in order to implement [key pair authentication](https://docs.snowflake.com/en/sql-reference/sql/create-account.html#:~:text=key%20pair%20authentication) for the user. Optional if the `ADMIN_PASSWORD` parameter is specified.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the account.\n",
                    "willReplaceOnChanges": true
                },
                "edition": {
                    "type": "string",
                    "description": "[Snowflake Edition](https://docs.snowflake.com/en/user-guide/intro-editions.html) of the account. Valid values are: STANDARD | ENTERPRISE | BUSINESS_CRITICAL\n",
                    "willReplaceOnChanges": true
                },
                "email": {
                    "type": "string",
                    "description": "Email address of the initial administrative user of the account. This email address is used to send any notifications about the account.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the initial administrative user of the account\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "gracePeriodInDays": {
                    "type": "integer",
                    "description": "Specifies the number of days to wait before dropping the account. The default is 3 days.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the initial administrative user of the account\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "mustChangePassword": {
                    "type": "boolean",
                    "description": "Specifies whether the new user created to administer the account is forced to change their password upon first login into the account.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier (i.e. name) for the account; must be unique within an organization, regardless of which Snowflake Region the account is in. In addition, the identifier must start with an alphabetic character and cannot contain spaces or special characters except for underscores (_). Note that if the account name includes underscores, features that do not accept account names with underscores (e.g. Okta SSO or SCIM) can reference a version of the account name that substitutes hyphens (-) for the underscores.\n"
                },
                "region": {
                    "type": "string",
                    "description": "ID of the Snowflake Region where the account is created. If no value is provided, Snowflake creates the account in the same Snowflake Region as the current account (i.e. the account in which the CREATE ACCOUNT statement is executed.)\n",
                    "willReplaceOnChanges": true
                },
                "regionGroup": {
                    "type": "string",
                    "description": "ID of the Snowflake Region where the account is created. If no value is provided, Snowflake creates the account in the same Snowflake Region as the current account (i.e. the account in which the CREATE ACCOUNT statement is executed.)\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "adminName",
                "edition",
                "email"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Account resources.\n",
                "properties": {
                    "adminName": {
                        "type": "string",
                        "description": "Login name of the initial administrative user of the account. A new user is created in the new account with this name and password and granted the ACCOUNTADMIN role in the account. A login name can be any string consisting of letters, numbers, and underscores. Login names are always case-insensitive.\n",
                        "willReplaceOnChanges": true
                    },
                    "adminPassword": {
                        "type": "string",
                        "description": "Password for the initial administrative user of the account. Optional if the `ADMIN_RSA_PUBLIC_KEY` parameter is specified. For more information about passwords in Snowflake, see [Snowflake-provided Password Policy](https://docs.snowflake.com/en/sql-reference/sql/create-account.html#:~:text=Snowflake%2Dprovided%20Password%20Policy).\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "adminRsaPublicKey": {
                        "type": "string",
                        "description": "Assigns a public key to the initial administrative user of the account in order to implement [key pair authentication](https://docs.snowflake.com/en/sql-reference/sql/create-account.html#:~:text=key%20pair%20authentication) for the user. Optional if the `ADMIN_PASSWORD` parameter is specified.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the account.\n",
                        "willReplaceOnChanges": true
                    },
                    "edition": {
                        "type": "string",
                        "description": "[Snowflake Edition](https://docs.snowflake.com/en/user-guide/intro-editions.html) of the account. Valid values are: STANDARD | ENTERPRISE | BUSINESS_CRITICAL\n",
                        "willReplaceOnChanges": true
                    },
                    "email": {
                        "type": "string",
                        "description": "Email address of the initial administrative user of the account. This email address is used to send any notifications about the account.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "firstName": {
                        "type": "string",
                        "description": "First name of the initial administrative user of the account\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "gracePeriodInDays": {
                        "type": "integer",
                        "description": "Specifies the number of days to wait before dropping the account. The default is 3 days.\n"
                    },
                    "isOrgAdmin": {
                        "type": "boolean",
                        "description": "Indicates whether the ORGADMIN role is enabled in an account. If TRUE, the role is enabled.\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "Last name of the initial administrative user of the account\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "mustChangePassword": {
                        "type": "boolean",
                        "description": "Specifies whether the new user created to administer the account is forced to change their password upon first login into the account.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier (i.e. name) for the account; must be unique within an organization, regardless of which Snowflake Region the account is in. In addition, the identifier must start with an alphabetic character and cannot contain spaces or special characters except for underscores (_). Note that if the account name includes underscores, features that do not accept account names with underscores (e.g. Okta SSO or SCIM) can reference a version of the account name that substitutes hyphens (-) for the underscores.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "ID of the Snowflake Region where the account is created. If no value is provided, Snowflake creates the account in the same Snowflake Region as the current account (i.e. the account in which the CREATE ACCOUNT statement is executed.)\n",
                        "willReplaceOnChanges": true
                    },
                    "regionGroup": {
                        "type": "string",
                        "description": "ID of the Snowflake Region where the account is created. If no value is provided, Snowflake creates the account in the same Snowflake Region as the current account (i.e. the account in which the CREATE ACCOUNT statement is executed.)\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/accountGrant:AccountGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.AccountGrant(\"grant\", {\n    privilege: \"CREATE ROLE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.AccountGrant(\"grant\",\n    privilege=\"CREATE ROLE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.AccountGrant(\"grant\", new()\n    {\n        Privilege = \"CREATE ROLE\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewAccountGrant(ctx, \"grant\", \u0026snowflake.AccountGrantArgs{\n\t\t\tPrivilege: pulumi.String(\"CREATE ROLE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.AccountGrant;\nimport com.pulumi.snowflake.AccountGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new AccountGrant(\"grant\", AccountGrantArgs.builder()        \n            .privilege(\"CREATE ROLE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:AccountGrant\n    properties:\n      privilege: CREATE ROLE\n      roles:\n        - role1\n        - role2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is privilege|with_grant_option|roles\n\n```sh\n $ pulumi import snowflake:index/accountGrant:AccountGrant example \"privilege|false|role1,role2\"\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The account privilege to grant. Valid privileges are those in [globalPrivileges](https://docs.snowflake.com/en/sql-reference/sql/grant-privilege.html). To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The account privilege to grant. Valid privileges are those in [globalPrivileges](https://docs.snowflake.com/en/sql-reference/sql/grant-privilege.html). To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccountGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The account privilege to grant. Valid privileges are those in [globalPrivileges](https://docs.snowflake.com/en/sql-reference/sql/grant-privilege.html). To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/accountParameter:AccountParameter": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst accountParameter = new snowflake.AccountParameter(\"accountParameter\", {\n    key: \"ALLOW_ID_TOKEN\",\n    value: \"true\",\n});\nconst p2 = new snowflake.AccountParameter(\"p2\", {\n    key: \"CLIENT_ENCRYPTION_KEY_SIZE\",\n    value: \"256\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\naccount_parameter = snowflake.AccountParameter(\"accountParameter\",\n    key=\"ALLOW_ID_TOKEN\",\n    value=\"true\")\np2 = snowflake.AccountParameter(\"p2\",\n    key=\"CLIENT_ENCRYPTION_KEY_SIZE\",\n    value=\"256\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var accountParameter = new Snowflake.AccountParameter(\"accountParameter\", new()\n    {\n        Key = \"ALLOW_ID_TOKEN\",\n        Value = \"true\",\n    });\n\n    var p2 = new Snowflake.AccountParameter(\"p2\", new()\n    {\n        Key = \"CLIENT_ENCRYPTION_KEY_SIZE\",\n        Value = \"256\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewAccountParameter(ctx, \"accountParameter\", \u0026snowflake.AccountParameterArgs{\n\t\t\tKey:   pulumi.String(\"ALLOW_ID_TOKEN\"),\n\t\t\tValue: pulumi.String(\"true\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewAccountParameter(ctx, \"p2\", \u0026snowflake.AccountParameterArgs{\n\t\t\tKey:   pulumi.String(\"CLIENT_ENCRYPTION_KEY_SIZE\"),\n\t\t\tValue: pulumi.String(\"256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.AccountParameter;\nimport com.pulumi.snowflake.AccountParameterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var accountParameter = new AccountParameter(\"accountParameter\", AccountParameterArgs.builder()        \n            .key(\"ALLOW_ID_TOKEN\")\n            .value(\"true\")\n            .build());\n\n        var p2 = new AccountParameter(\"p2\", AccountParameterArgs.builder()        \n            .key(\"CLIENT_ENCRYPTION_KEY_SIZE\")\n            .value(\"256\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  accountParameter:\n    type: snowflake:AccountParameter\n    properties:\n      key: ALLOW_ID_TOKEN\n      value: 'true'\n  p2:\n    type: snowflake:AccountParameter\n    properties:\n      key: CLIENT_ENCRYPTION_KEY_SIZE\n      value: '256'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/accountParameter:AccountParameter p \u003cparameter_name\u003e\n```\n\n ",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Name of account parameter. Valid values are those in [account parameters](https://docs.snowflake.com/en/sql-reference/parameters.html#account-parameters).\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of account parameter, as a string. Constraints are the same as those for the parameters in Snowflake documentation.\n"
                }
            },
            "required": [
                "key",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "Name of account parameter. Valid values are those in [account parameters](https://docs.snowflake.com/en/sql-reference/parameters.html#account-parameters).\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of account parameter, as a string. Constraints are the same as those for the parameters in Snowflake documentation.\n"
                }
            },
            "requiredInputs": [
                "key",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccountParameter resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Name of account parameter. Valid values are those in [account parameters](https://docs.snowflake.com/en/sql-reference/parameters.html#account-parameters).\n",
                        "willReplaceOnChanges": true
                    },
                    "value": {
                        "type": "string",
                        "description": "Value of account parameter, as a string. Constraints are the same as those for the parameters in Snowflake documentation.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/accountPasswordPolicyAttachment:AccountPasswordPolicyAttachment": {
            "description": "Specifies the password policy to use for the current account. To set the password policy of a different account, use a provider alias.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst _default = new snowflake.PasswordPolicy(\"default\", {\n    database: \"prod\",\n    schema: \"security\",\n});\nconst attachment = new snowflake.AccountPasswordPolicyAttachment(\"attachment\", {passwordPolicy: _default.qualifiedName});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndefault = snowflake.PasswordPolicy(\"default\",\n    database=\"prod\",\n    schema=\"security\")\nattachment = snowflake.AccountPasswordPolicyAttachment(\"attachment\", password_policy=default.qualified_name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @default = new Snowflake.PasswordPolicy(\"default\", new()\n    {\n        Database = \"prod\",\n        Schema = \"security\",\n    });\n\n    var attachment = new Snowflake.AccountPasswordPolicyAttachment(\"attachment\", new()\n    {\n        PasswordPolicy = @default.QualifiedName,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewPasswordPolicy(ctx, \"default\", \u0026snowflake.PasswordPolicyArgs{\n\t\t\tDatabase: pulumi.String(\"prod\"),\n\t\t\tSchema:   pulumi.String(\"security\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewAccountPasswordPolicyAttachment(ctx, \"attachment\", \u0026snowflake.AccountPasswordPolicyAttachmentArgs{\n\t\t\tPasswordPolicy: _default.QualifiedName,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.PasswordPolicy;\nimport com.pulumi.snowflake.PasswordPolicyArgs;\nimport com.pulumi.snowflake.AccountPasswordPolicyAttachment;\nimport com.pulumi.snowflake.AccountPasswordPolicyAttachmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var default_ = new PasswordPolicy(\"default\", PasswordPolicyArgs.builder()        \n            .database(\"prod\")\n            .schema(\"security\")\n            .build());\n\n        var attachment = new AccountPasswordPolicyAttachment(\"attachment\", AccountPasswordPolicyAttachmentArgs.builder()        \n            .passwordPolicy(default_.qualifiedName())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  default:\n    type: snowflake:PasswordPolicy\n    properties:\n      database: prod\n      schema: security\n  attachment:\n    type: snowflake:AccountPasswordPolicyAttachment\n    properties:\n      passwordPolicy: ${default.qualifiedName}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "passwordPolicy": {
                    "type": "string",
                    "description": "Qualified name (`\"db\".\"schema\".\"policy_name\"`) of the password policy to apply to the current account.\n"
                }
            },
            "required": [
                "passwordPolicy"
            ],
            "inputProperties": {
                "passwordPolicy": {
                    "type": "string",
                    "description": "Qualified name (`\"db\".\"schema\".\"policy_name\"`) of the password policy to apply to the current account.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "passwordPolicy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccountPasswordPolicyAttachment resources.\n",
                "properties": {
                    "passwordPolicy": {
                        "type": "string",
                        "description": "Qualified name (`\"db\".\"schema\".\"policy_name\"`) of the password policy to apply to the current account.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/alert:Alert": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst alert = new snowflake.Alert(\"alert\", {\n    action: \"select 1 as c\",\n    alertSchedule: {\n        interval: 10,\n    },\n    comment: \"my alert\",\n    condition: \"select 1 as c\",\n    database: \"database\",\n    enabled: true,\n    schema: \"schema\",\n    warehouse: \"warehouse\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nalert = snowflake.Alert(\"alert\",\n    action=\"select 1 as c\",\n    alert_schedule=snowflake.AlertAlertScheduleArgs(\n        interval=10,\n    ),\n    comment=\"my alert\",\n    condition=\"select 1 as c\",\n    database=\"database\",\n    enabled=True,\n    schema=\"schema\",\n    warehouse=\"warehouse\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var alert = new Snowflake.Alert(\"alert\", new()\n    {\n        Action = \"select 1 as c\",\n        AlertSchedule = new Snowflake.Inputs.AlertAlertScheduleArgs\n        {\n            Interval = 10,\n        },\n        Comment = \"my alert\",\n        Condition = \"select 1 as c\",\n        Database = \"database\",\n        Enabled = true,\n        Schema = \"schema\",\n        Warehouse = \"warehouse\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewAlert(ctx, \"alert\", \u0026snowflake.AlertArgs{\n\t\t\tAction: pulumi.String(\"select 1 as c\"),\n\t\t\tAlertSchedule: \u0026snowflake.AlertAlertScheduleArgs{\n\t\t\t\tInterval: pulumi.Int(10),\n\t\t\t},\n\t\t\tComment:   pulumi.String(\"my alert\"),\n\t\t\tCondition: pulumi.String(\"select 1 as c\"),\n\t\t\tDatabase:  pulumi.String(\"database\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tSchema:    pulumi.String(\"schema\"),\n\t\t\tWarehouse: pulumi.String(\"warehouse\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Alert;\nimport com.pulumi.snowflake.AlertArgs;\nimport com.pulumi.snowflake.inputs.AlertAlertScheduleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var alert = new Alert(\"alert\", AlertArgs.builder()        \n            .action(\"select 1 as c\")\n            .alertSchedule(AlertAlertScheduleArgs.builder()\n                .interval(10)\n                .build())\n            .comment(\"my alert\")\n            .condition(\"select 1 as c\")\n            .database(\"database\")\n            .enabled(true)\n            .schema(\"schema\")\n            .warehouse(\"warehouse\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  alert:\n    type: snowflake:Alert\n    properties:\n      action: select 1 as c\n      alertSchedule:\n        interval: 10\n      comment: my alert\n      condition: select 1 as c\n      database: database\n      enabled: true\n      schema: schema\n      warehouse: warehouse\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | alert name\n\n```sh\n $ pulumi import snowflake:index/alert:Alert example 'dbName|schemaName|alertName'\n```\n\n ",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "The SQL statement that should be executed if the condition returns one or more rows.\n"
                },
                "alertSchedule": {
                    "$ref": "#/types/snowflake:index/AlertAlertSchedule:AlertAlertSchedule",
                    "description": "The schedule for periodically running an alert.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the alert.\n"
                },
                "condition": {
                    "type": "string",
                    "description": "The SQL statement that represents the condition for the alert. (SELECT, SHOW, CALL)\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the alert.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies if an alert should be 'started' (enabled) after creation or should remain 'suspended' (default).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the alert; must be unique for the database and schema in which the alert is created.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the alert.\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse the alert will use.\n"
                }
            },
            "required": [
                "action",
                "condition",
                "database",
                "name",
                "schema",
                "warehouse"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": "The SQL statement that should be executed if the condition returns one or more rows.\n"
                },
                "alertSchedule": {
                    "$ref": "#/types/snowflake:index/AlertAlertSchedule:AlertAlertSchedule",
                    "description": "The schedule for periodically running an alert.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the alert.\n"
                },
                "condition": {
                    "type": "string",
                    "description": "The SQL statement that represents the condition for the alert. (SELECT, SHOW, CALL)\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the alert.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies if an alert should be 'started' (enabled) after creation or should remain 'suspended' (default).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the alert; must be unique for the database and schema in which the alert is created.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the alert.\n",
                    "willReplaceOnChanges": true
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse the alert will use.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "action",
                "condition",
                "database",
                "schema",
                "warehouse"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Alert resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "The SQL statement that should be executed if the condition returns one or more rows.\n"
                    },
                    "alertSchedule": {
                        "$ref": "#/types/snowflake:index/AlertAlertSchedule:AlertAlertSchedule",
                        "description": "The schedule for periodically running an alert.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the alert.\n"
                    },
                    "condition": {
                        "type": "string",
                        "description": "The SQL statement that represents the condition for the alert. (SELECT, SHOW, CALL)\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the alert.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies if an alert should be 'started' (enabled) after creation or should remain 'suspended' (default).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the alert; must be unique for the database and schema in which the alert is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the alert.\n",
                        "willReplaceOnChanges": true
                    },
                    "warehouse": {
                        "type": "string",
                        "description": "The warehouse the alert will use.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/apiIntegration:ApiIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst aws = new snowflake.ApiIntegration(\"aws\", {\n    apiAllowedPrefixes: [\"https://123456.execute-api.us-west-2.amazonaws.com/prod/\"],\n    apiAwsRoleArn: \"arn:aws:iam::000000000001:/role/test\",\n    apiProvider: \"aws_api_gateway\",\n    enabled: true,\n});\nconst azure = new snowflake.ApiIntegration(\"azure\", {\n    apiAllowedPrefixes: [\"https://apim-hello-world.azure-api.net/\"],\n    apiProvider: \"azure_api_management\",\n    azureAdApplicationId: \"11111111-1111-1111-1111-111111111111\",\n    azureTenantId: \"00000000-0000-0000-0000-000000000000\",\n    enabled: true,\n});\nconst gcp = new snowflake.ApiIntegration(\"gcp\", {\n    apiAllowedPrefixes: [\"https://gateway-id-123456.uc.gateway.dev/\"],\n    apiProvider: \"google_api_gateway\",\n    enabled: true,\n    googleAudience: \"api-gateway-id-123456.apigateway.gcp-project.cloud.goog\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\naws = snowflake.ApiIntegration(\"aws\",\n    api_allowed_prefixes=[\"https://123456.execute-api.us-west-2.amazonaws.com/prod/\"],\n    api_aws_role_arn=\"arn:aws:iam::000000000001:/role/test\",\n    api_provider=\"aws_api_gateway\",\n    enabled=True)\nazure = snowflake.ApiIntegration(\"azure\",\n    api_allowed_prefixes=[\"https://apim-hello-world.azure-api.net/\"],\n    api_provider=\"azure_api_management\",\n    azure_ad_application_id=\"11111111-1111-1111-1111-111111111111\",\n    azure_tenant_id=\"00000000-0000-0000-0000-000000000000\",\n    enabled=True)\ngcp = snowflake.ApiIntegration(\"gcp\",\n    api_allowed_prefixes=[\"https://gateway-id-123456.uc.gateway.dev/\"],\n    api_provider=\"google_api_gateway\",\n    enabled=True,\n    google_audience=\"api-gateway-id-123456.apigateway.gcp-project.cloud.goog\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var aws = new Snowflake.ApiIntegration(\"aws\", new()\n    {\n        ApiAllowedPrefixes = new[]\n        {\n            \"https://123456.execute-api.us-west-2.amazonaws.com/prod/\",\n        },\n        ApiAwsRoleArn = \"arn:aws:iam::000000000001:/role/test\",\n        ApiProvider = \"aws_api_gateway\",\n        Enabled = true,\n    });\n\n    var azure = new Snowflake.ApiIntegration(\"azure\", new()\n    {\n        ApiAllowedPrefixes = new[]\n        {\n            \"https://apim-hello-world.azure-api.net/\",\n        },\n        ApiProvider = \"azure_api_management\",\n        AzureAdApplicationId = \"11111111-1111-1111-1111-111111111111\",\n        AzureTenantId = \"00000000-0000-0000-0000-000000000000\",\n        Enabled = true,\n    });\n\n    var gcp = new Snowflake.ApiIntegration(\"gcp\", new()\n    {\n        ApiAllowedPrefixes = new[]\n        {\n            \"https://gateway-id-123456.uc.gateway.dev/\",\n        },\n        ApiProvider = \"google_api_gateway\",\n        Enabled = true,\n        GoogleAudience = \"api-gateway-id-123456.apigateway.gcp-project.cloud.goog\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewApiIntegration(ctx, \"aws\", \u0026snowflake.ApiIntegrationArgs{\n\t\t\tApiAllowedPrefixes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://123456.execute-api.us-west-2.amazonaws.com/prod/\"),\n\t\t\t},\n\t\t\tApiAwsRoleArn: pulumi.String(\"arn:aws:iam::000000000001:/role/test\"),\n\t\t\tApiProvider:   pulumi.String(\"aws_api_gateway\"),\n\t\t\tEnabled:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewApiIntegration(ctx, \"azure\", \u0026snowflake.ApiIntegrationArgs{\n\t\t\tApiAllowedPrefixes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://apim-hello-world.azure-api.net/\"),\n\t\t\t},\n\t\t\tApiProvider:          pulumi.String(\"azure_api_management\"),\n\t\t\tAzureAdApplicationId: pulumi.String(\"11111111-1111-1111-1111-111111111111\"),\n\t\t\tAzureTenantId:        pulumi.String(\"00000000-0000-0000-0000-000000000000\"),\n\t\t\tEnabled:              pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewApiIntegration(ctx, \"gcp\", \u0026snowflake.ApiIntegrationArgs{\n\t\t\tApiAllowedPrefixes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://gateway-id-123456.uc.gateway.dev/\"),\n\t\t\t},\n\t\t\tApiProvider:    pulumi.String(\"google_api_gateway\"),\n\t\t\tEnabled:        pulumi.Bool(true),\n\t\t\tGoogleAudience: pulumi.String(\"api-gateway-id-123456.apigateway.gcp-project.cloud.goog\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ApiIntegration;\nimport com.pulumi.snowflake.ApiIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aws = new ApiIntegration(\"aws\", ApiIntegrationArgs.builder()        \n            .apiAllowedPrefixes(\"https://123456.execute-api.us-west-2.amazonaws.com/prod/\")\n            .apiAwsRoleArn(\"arn:aws:iam::000000000001:/role/test\")\n            .apiProvider(\"aws_api_gateway\")\n            .enabled(true)\n            .build());\n\n        var azure = new ApiIntegration(\"azure\", ApiIntegrationArgs.builder()        \n            .apiAllowedPrefixes(\"https://apim-hello-world.azure-api.net/\")\n            .apiProvider(\"azure_api_management\")\n            .azureAdApplicationId(\"11111111-1111-1111-1111-111111111111\")\n            .azureTenantId(\"00000000-0000-0000-0000-000000000000\")\n            .enabled(true)\n            .build());\n\n        var gcp = new ApiIntegration(\"gcp\", ApiIntegrationArgs.builder()        \n            .apiAllowedPrefixes(\"https://gateway-id-123456.uc.gateway.dev/\")\n            .apiProvider(\"google_api_gateway\")\n            .enabled(true)\n            .googleAudience(\"api-gateway-id-123456.apigateway.gcp-project.cloud.goog\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aws:\n    type: snowflake:ApiIntegration\n    properties:\n      apiAllowedPrefixes:\n        - https://123456.execute-api.us-west-2.amazonaws.com/prod/\n      apiAwsRoleArn: arn:aws:iam::000000000001:/role/test\n      apiProvider: aws_api_gateway\n      enabled: true\n  azure:\n    type: snowflake:ApiIntegration\n    properties:\n      apiAllowedPrefixes:\n        - https://apim-hello-world.azure-api.net/\n      apiProvider: azure_api_management\n      azureAdApplicationId: 11111111-1111-1111-1111-111111111111\n      azureTenantId: 00000000-0000-0000-0000-000000000000\n      enabled: true\n  gcp:\n    type: snowflake:ApiIntegration\n    properties:\n      apiAllowedPrefixes:\n        - https://gateway-id-123456.uc.gateway.dev/\n      apiProvider: google_api_gateway\n      enabled: true\n      googleAudience: api-gateway-id-123456.apigateway.gcp-project.cloud.goog\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/apiIntegration:ApiIntegration example name\n```\n\n ",
            "properties": {
                "apiAllowedPrefixes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly limits external functions that use the integration to reference one or more HTTPS proxy service endpoints and resources within those proxies.\n"
                },
                "apiAwsExternalId": {
                    "type": "string",
                    "description": "The external ID that Snowflake will use when assuming the AWS role.\n"
                },
                "apiAwsIamUserArn": {
                    "type": "string",
                    "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                },
                "apiAwsRoleArn": {
                    "type": "string",
                    "description": "ARN of a cloud platform role.\n"
                },
                "apiBlockedPrefixes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Lists the endpoints and resources in the HTTPS proxy service that are not allowed to be called from Snowflake.\n"
                },
                "apiGcpServiceAccount": {
                    "type": "string",
                    "description": "The service account used for communication with the Google API Gateway.\n"
                },
                "apiKey": {
                    "type": "string",
                    "description": "The API key (also called a “subscription key”).\n",
                    "secret": true
                },
                "apiProvider": {
                    "type": "string",
                    "description": "Specifies the HTTPS proxy service type.\n"
                },
                "azureAdApplicationId": {
                    "type": "string",
                    "description": "The 'Application (client) id' of the Azure AD app for your remote service.\n"
                },
                "azureConsentUrl": {
                    "type": "string"
                },
                "azureMultiTenantAppName": {
                    "type": "string"
                },
                "azureTenantId": {
                    "type": "string",
                    "description": "Specifies the ID for your Office 365 tenant that all Azure API Management instances belong to.\n"
                },
                "comment": {
                    "type": "string"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the API integration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this API integration is enabled or disabled. If the API integration is disabled, any external function that relies on it will not work.\n"
                },
                "googleAudience": {
                    "type": "string",
                    "description": "The audience claim when generating the JWT (JSON Web Token) to authenticate to the Google API Gateway.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the API integration. This name follows the rules for Object Identifiers. The name should be unique among api integrations in your account.\n"
                }
            },
            "required": [
                "apiAllowedPrefixes",
                "apiAwsExternalId",
                "apiAwsIamUserArn",
                "apiGcpServiceAccount",
                "apiProvider",
                "azureConsentUrl",
                "azureMultiTenantAppName",
                "createdOn",
                "name"
            ],
            "inputProperties": {
                "apiAllowedPrefixes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly limits external functions that use the integration to reference one or more HTTPS proxy service endpoints and resources within those proxies.\n"
                },
                "apiAwsRoleArn": {
                    "type": "string",
                    "description": "ARN of a cloud platform role.\n"
                },
                "apiBlockedPrefixes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Lists the endpoints and resources in the HTTPS proxy service that are not allowed to be called from Snowflake.\n"
                },
                "apiGcpServiceAccount": {
                    "type": "string",
                    "description": "The service account used for communication with the Google API Gateway.\n"
                },
                "apiKey": {
                    "type": "string",
                    "description": "The API key (also called a “subscription key”).\n",
                    "secret": true
                },
                "apiProvider": {
                    "type": "string",
                    "description": "Specifies the HTTPS proxy service type.\n"
                },
                "azureAdApplicationId": {
                    "type": "string",
                    "description": "The 'Application (client) id' of the Azure AD app for your remote service.\n"
                },
                "azureTenantId": {
                    "type": "string",
                    "description": "Specifies the ID for your Office 365 tenant that all Azure API Management instances belong to.\n"
                },
                "comment": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this API integration is enabled or disabled. If the API integration is disabled, any external function that relies on it will not work.\n"
                },
                "googleAudience": {
                    "type": "string",
                    "description": "The audience claim when generating the JWT (JSON Web Token) to authenticate to the Google API Gateway.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the API integration. This name follows the rules for Object Identifiers. The name should be unique among api integrations in your account.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "apiAllowedPrefixes",
                "apiProvider"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiIntegration resources.\n",
                "properties": {
                    "apiAllowedPrefixes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Explicitly limits external functions that use the integration to reference one or more HTTPS proxy service endpoints and resources within those proxies.\n"
                    },
                    "apiAwsExternalId": {
                        "type": "string",
                        "description": "The external ID that Snowflake will use when assuming the AWS role.\n"
                    },
                    "apiAwsIamUserArn": {
                        "type": "string",
                        "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                    },
                    "apiAwsRoleArn": {
                        "type": "string",
                        "description": "ARN of a cloud platform role.\n"
                    },
                    "apiBlockedPrefixes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Lists the endpoints and resources in the HTTPS proxy service that are not allowed to be called from Snowflake.\n"
                    },
                    "apiGcpServiceAccount": {
                        "type": "string",
                        "description": "The service account used for communication with the Google API Gateway.\n"
                    },
                    "apiKey": {
                        "type": "string",
                        "description": "The API key (also called a “subscription key”).\n",
                        "secret": true
                    },
                    "apiProvider": {
                        "type": "string",
                        "description": "Specifies the HTTPS proxy service type.\n"
                    },
                    "azureAdApplicationId": {
                        "type": "string",
                        "description": "The 'Application (client) id' of the Azure AD app for your remote service.\n"
                    },
                    "azureConsentUrl": {
                        "type": "string"
                    },
                    "azureMultiTenantAppName": {
                        "type": "string"
                    },
                    "azureTenantId": {
                        "type": "string",
                        "description": "Specifies the ID for your Office 365 tenant that all Azure API Management instances belong to.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the API integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether this API integration is enabled or disabled. If the API integration is disabled, any external function that relies on it will not work.\n"
                    },
                    "googleAudience": {
                        "type": "string",
                        "description": "The audience claim when generating the JWT (JSON Web Token) to authenticate to the Google API Gateway.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the API integration. This name follows the rules for Object Identifiers. The name should be unique among api integrations in your account.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/database:Database": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst simple = new snowflake.Database(\"simple\", {\n    comment: \"test comment\",\n    dataRetentionTimeInDays: 3,\n});\nconst withReplication = new snowflake.Database(\"withReplication\", {\n    comment: \"test comment 2\",\n    replicationConfiguration: {\n        accounts: [\n            \"test_account1\",\n            \"test_account_2\",\n        ],\n        ignoreEditionCheck: true,\n    },\n});\nconst fromReplica = new snowflake.Database(\"fromReplica\", {\n    comment: \"test comment\",\n    dataRetentionTimeInDays: 3,\n    fromReplica: \"org1\\\".\\\"account1\\\".\\\"primary_db_name\",\n});\nconst fromShare = new snowflake.Database(\"fromShare\", {\n    comment: \"test comment\",\n    fromShare: {\n        provider: \"org1.account1\",\n        share: \"share1\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nsimple = snowflake.Database(\"simple\",\n    comment=\"test comment\",\n    data_retention_time_in_days=3)\nwith_replication = snowflake.Database(\"withReplication\",\n    comment=\"test comment 2\",\n    replication_configuration=snowflake.DatabaseReplicationConfigurationArgs(\n        accounts=[\n            \"test_account1\",\n            \"test_account_2\",\n        ],\n        ignore_edition_check=True,\n    ))\nfrom_replica = snowflake.Database(\"fromReplica\",\n    comment=\"test comment\",\n    data_retention_time_in_days=3,\n    from_replica=\"org1\\\".\\\"account1\\\".\\\"primary_db_name\")\nfrom_share = snowflake.Database(\"fromShare\",\n    comment=\"test comment\",\n    from_share={\n        \"provider\": \"org1.account1\",\n        \"share\": \"share1\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var simple = new Snowflake.Database(\"simple\", new()\n    {\n        Comment = \"test comment\",\n        DataRetentionTimeInDays = 3,\n    });\n\n    var withReplication = new Snowflake.Database(\"withReplication\", new()\n    {\n        Comment = \"test comment 2\",\n        ReplicationConfiguration = new Snowflake.Inputs.DatabaseReplicationConfigurationArgs\n        {\n            Accounts = new[]\n            {\n                \"test_account1\",\n                \"test_account_2\",\n            },\n            IgnoreEditionCheck = true,\n        },\n    });\n\n    var fromReplica = new Snowflake.Database(\"fromReplica\", new()\n    {\n        Comment = \"test comment\",\n        DataRetentionTimeInDays = 3,\n        FromReplica = \"org1\\\".\\\"account1\\\".\\\"primary_db_name\",\n    });\n\n    var fromShare = new Snowflake.Database(\"fromShare\", new()\n    {\n        Comment = \"test comment\",\n        FromShare = \n        {\n            { \"provider\", \"org1.account1\" },\n            { \"share\", \"share1\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewDatabase(ctx, \"simple\", \u0026snowflake.DatabaseArgs{\n\t\t\tComment:                 pulumi.String(\"test comment\"),\n\t\t\tDataRetentionTimeInDays: pulumi.Int(3),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewDatabase(ctx, \"withReplication\", \u0026snowflake.DatabaseArgs{\n\t\t\tComment: pulumi.String(\"test comment 2\"),\n\t\t\tReplicationConfiguration: \u0026snowflake.DatabaseReplicationConfigurationArgs{\n\t\t\t\tAccounts: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"test_account1\"),\n\t\t\t\t\tpulumi.String(\"test_account_2\"),\n\t\t\t\t},\n\t\t\t\tIgnoreEditionCheck: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewDatabase(ctx, \"fromReplica\", \u0026snowflake.DatabaseArgs{\n\t\t\tComment:                 pulumi.String(\"test comment\"),\n\t\t\tDataRetentionTimeInDays: pulumi.Int(3),\n\t\t\tFromReplica:             pulumi.String(\"org1\\\".\\\"account1\\\".\\\"primary_db_name\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewDatabase(ctx, \"fromShare\", \u0026snowflake.DatabaseArgs{\n\t\t\tComment: pulumi.String(\"test comment\"),\n\t\t\tFromShare: pulumi.StringMap{\n\t\t\t\t\"provider\": pulumi.String(\"org1.account1\"),\n\t\t\t\t\"share\":    pulumi.String(\"share1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.DatabaseArgs;\nimport com.pulumi.snowflake.inputs.DatabaseReplicationConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var simple = new Database(\"simple\", DatabaseArgs.builder()        \n            .comment(\"test comment\")\n            .dataRetentionTimeInDays(3)\n            .build());\n\n        var withReplication = new Database(\"withReplication\", DatabaseArgs.builder()        \n            .comment(\"test comment 2\")\n            .replicationConfiguration(DatabaseReplicationConfigurationArgs.builder()\n                .accounts(                \n                    \"test_account1\",\n                    \"test_account_2\")\n                .ignoreEditionCheck(true)\n                .build())\n            .build());\n\n        var fromReplica = new Database(\"fromReplica\", DatabaseArgs.builder()        \n            .comment(\"test comment\")\n            .dataRetentionTimeInDays(3)\n            .fromReplica(\"org1\\\".\\\"account1\\\".\\\"primary_db_name\")\n            .build());\n\n        var fromShare = new Database(\"fromShare\", DatabaseArgs.builder()        \n            .comment(\"test comment\")\n            .fromShare(Map.ofEntries(\n                Map.entry(\"provider\", \"org1.account1\"),\n                Map.entry(\"share\", \"share1\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  simple:\n    type: snowflake:Database\n    properties:\n      comment: test comment\n      dataRetentionTimeInDays: 3\n  withReplication:\n    type: snowflake:Database\n    properties:\n      comment: test comment 2\n      replicationConfiguration:\n        accounts:\n          - test_account1\n          - test_account_2\n        ignoreEditionCheck: true\n  fromReplica:\n    type: snowflake:Database\n    properties:\n      comment: test comment\n      dataRetentionTimeInDays: 3\n      fromReplica: org1\".\"account1\".\"primary_db_name\n  fromShare:\n    type: snowflake:Database\n    properties:\n      comment: test comment\n      fromShare:\n        provider: org1.account1\n        share: share1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/database:Database example name\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string"
                },
                "dataRetentionTimeInDays": {
                    "type": "integer",
                    "description": "Number of days for which Snowflake retains historical data for performing Time Travel actions (SELECT, CLONE, UNDROP) on the object. A value of 0 effectively disables Time Travel for the specified database, schema, or table. For more information, see Understanding \u0026 Using Time Travel.\n"
                },
                "fromDatabase": {
                    "type": "string",
                    "description": "Specify a database to create a clone from.\n"
                },
                "fromReplica": {
                    "type": "string",
                    "description": "Specify a fully-qualified path to a database to create a replica from. A fully qualified path follows the format of \"\\n\\n\".\"\\n\\n\".\"\\n\\n\". An example would be: \"myorg1\".\"account1\".\"db1\"\n"
                },
                "fromShare": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specify a provider and a share in this map to create a database from a share.\n"
                },
                "isTransient": {
                    "type": "boolean",
                    "description": "Specifies a database as transient. Transient databases do not have a Fail-safe period so they do not incur additional storage costs once they leave Time Travel; however, this means they are also not protected by Fail-safe in the event of a data loss.\n"
                },
                "name": {
                    "type": "string"
                },
                "replicationConfiguration": {
                    "$ref": "#/types/snowflake:index/DatabaseReplicationConfiguration:DatabaseReplicationConfiguration",
                    "description": "When set, specifies the configurations for database replication.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string"
                },
                "dataRetentionTimeInDays": {
                    "type": "integer",
                    "description": "Number of days for which Snowflake retains historical data for performing Time Travel actions (SELECT, CLONE, UNDROP) on the object. A value of 0 effectively disables Time Travel for the specified database, schema, or table. For more information, see Understanding \u0026 Using Time Travel.\n"
                },
                "fromDatabase": {
                    "type": "string",
                    "description": "Specify a database to create a clone from.\n",
                    "willReplaceOnChanges": true
                },
                "fromReplica": {
                    "type": "string",
                    "description": "Specify a fully-qualified path to a database to create a replica from. A fully qualified path follows the format of \"\\n\\n\".\"\\n\\n\".\"\\n\\n\". An example would be: \"myorg1\".\"account1\".\"db1\"\n",
                    "willReplaceOnChanges": true
                },
                "fromShare": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specify a provider and a share in this map to create a database from a share.\n",
                    "willReplaceOnChanges": true
                },
                "isTransient": {
                    "type": "boolean",
                    "description": "Specifies a database as transient. Transient databases do not have a Fail-safe period so they do not incur additional storage costs once they leave Time Travel; however, this means they are also not protected by Fail-safe in the event of a data loss.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string"
                },
                "replicationConfiguration": {
                    "$ref": "#/types/snowflake:index/DatabaseReplicationConfiguration:DatabaseReplicationConfiguration",
                    "description": "When set, specifies the configurations for database replication.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Database resources.\n",
                "properties": {
                    "comment": {
                        "type": "string"
                    },
                    "dataRetentionTimeInDays": {
                        "type": "integer",
                        "description": "Number of days for which Snowflake retains historical data for performing Time Travel actions (SELECT, CLONE, UNDROP) on the object. A value of 0 effectively disables Time Travel for the specified database, schema, or table. For more information, see Understanding \u0026 Using Time Travel.\n"
                    },
                    "fromDatabase": {
                        "type": "string",
                        "description": "Specify a database to create a clone from.\n",
                        "willReplaceOnChanges": true
                    },
                    "fromReplica": {
                        "type": "string",
                        "description": "Specify a fully-qualified path to a database to create a replica from. A fully qualified path follows the format of \"\\n\\n\".\"\\n\\n\".\"\\n\\n\". An example would be: \"myorg1\".\"account1\".\"db1\"\n",
                        "willReplaceOnChanges": true
                    },
                    "fromShare": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specify a provider and a share in this map to create a database from a share.\n",
                        "willReplaceOnChanges": true
                    },
                    "isTransient": {
                        "type": "boolean",
                        "description": "Specifies a database as transient. Transient databases do not have a Fail-safe period so they do not incur additional storage costs once they leave Time Travel; however, this means they are also not protected by Fail-safe in the event of a data loss.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string"
                    },
                    "replicationConfiguration": {
                        "$ref": "#/types/snowflake:index/DatabaseReplicationConfiguration:DatabaseReplicationConfiguration",
                        "description": "When set, specifies the configurations for database replication.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/databaseGrant:DatabaseGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.DatabaseGrant(\"grant\", {\n    databaseName: \"database\",\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.DatabaseGrant(\"grant\",\n    database_name=\"database\",\n    privilege=\"USAGE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.DatabaseGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        Privilege = \"USAGE\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        Shares = new[]\n        {\n            \"share1\",\n            \"share2\",\n        },\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewDatabaseGrant(ctx, \"grant\", \u0026snowflake.DatabaseGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tPrivilege:    pulumi.String(\"USAGE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.DatabaseGrant;\nimport com.pulumi.snowflake.DatabaseGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new DatabaseGrant(\"grant\", DatabaseGrantArgs.builder()        \n            .databaseName(\"database\")\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:DatabaseGrant\n    properties:\n      databaseName: database\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|privilege|with_grant_option|roles|shares\n\n```sh\n $ pulumi import snowflake:index/databaseGrant:DatabaseGrant example \"MY_DATABASE|USAGE|false|role1,role2|share1,share2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the database. To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the database. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatabaseGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the database. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares.\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/databaseRole:DatabaseRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst dbRole = new snowflake.DatabaseRole(\"dbRole\", {\n    comment: \"my db role\",\n    database: \"database\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndb_role = snowflake.DatabaseRole(\"dbRole\",\n    comment=\"my db role\",\n    database=\"database\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dbRole = new Snowflake.DatabaseRole(\"dbRole\", new()\n    {\n        Comment = \"my db role\",\n        Database = \"database\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewDatabaseRole(ctx, \"dbRole\", \u0026snowflake.DatabaseRoleArgs{\n\t\t\tComment:  pulumi.String(\"my db role\"),\n\t\t\tDatabase: pulumi.String(\"database\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.DatabaseRole;\nimport com.pulumi.snowflake.DatabaseRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dbRole = new DatabaseRole(\"dbRole\", DatabaseRoleArgs.builder()        \n            .comment(\"my db role\")\n            .database(\"database\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dbRole:\n    type: snowflake:DatabaseRole\n    properties:\n      comment: my db role\n      database: database\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/databaseRole:DatabaseRole example 'dbName|roleName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the database role.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the database role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the database role.\n"
                }
            },
            "required": [
                "database",
                "name"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the database role.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the database role.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the database role.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatabaseRole resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the database role.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the database role.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the database role.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/dynamicTable:DynamicTable": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\n// https://docs.snowflake.com/en/sql-reference/sql/create-dynamic-table#examples\nconst dt = new snowflake.DynamicTable(\"dt\", {\n    comment: \"example comment\",\n    database: \"mydb\",\n    query: \"SELECT product_id, product_name FROM \\\"mydb\\\".\\\"myschema\\\".\\\"staging_table\\\"\",\n    schema: \"myschema\",\n    targetLag: {\n        maximumDuration: \"20 minutes\",\n    },\n    warehouse: \"mywh\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\n# https://docs.snowflake.com/en/sql-reference/sql/create-dynamic-table#examples\ndt = snowflake.DynamicTable(\"dt\",\n    comment=\"example comment\",\n    database=\"mydb\",\n    query=\"SELECT product_id, product_name FROM \\\"mydb\\\".\\\"myschema\\\".\\\"staging_table\\\"\",\n    schema=\"myschema\",\n    target_lag=snowflake.DynamicTableTargetLagArgs(\n        maximum_duration=\"20 minutes\",\n    ),\n    warehouse=\"mywh\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // https://docs.snowflake.com/en/sql-reference/sql/create-dynamic-table#examples\n    var dt = new Snowflake.DynamicTable(\"dt\", new()\n    {\n        Comment = \"example comment\",\n        Database = \"mydb\",\n        Query = \"SELECT product_id, product_name FROM \\\"mydb\\\".\\\"myschema\\\".\\\"staging_table\\\"\",\n        Schema = \"myschema\",\n        TargetLag = new Snowflake.Inputs.DynamicTableTargetLagArgs\n        {\n            MaximumDuration = \"20 minutes\",\n        },\n        Warehouse = \"mywh\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewDynamicTable(ctx, \"dt\", \u0026snowflake.DynamicTableArgs{\n\t\t\tComment:  pulumi.String(\"example comment\"),\n\t\t\tDatabase: pulumi.String(\"mydb\"),\n\t\t\tQuery:    pulumi.String(\"SELECT product_id, product_name FROM \\\"mydb\\\".\\\"myschema\\\".\\\"staging_table\\\"\"),\n\t\t\tSchema:   pulumi.String(\"myschema\"),\n\t\t\tTargetLag: \u0026snowflake.DynamicTableTargetLagArgs{\n\t\t\t\tMaximumDuration: pulumi.String(\"20 minutes\"),\n\t\t\t},\n\t\t\tWarehouse: pulumi.String(\"mywh\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.DynamicTable;\nimport com.pulumi.snowflake.DynamicTableArgs;\nimport com.pulumi.snowflake.inputs.DynamicTableTargetLagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dt = new DynamicTable(\"dt\", DynamicTableArgs.builder()        \n            .comment(\"example comment\")\n            .database(\"mydb\")\n            .query(\"SELECT product_id, product_name FROM \\\"mydb\\\".\\\"myschema\\\".\\\"staging_table\\\"\")\n            .schema(\"myschema\")\n            .targetLag(DynamicTableTargetLagArgs.builder()\n                .maximumDuration(\"20 minutes\")\n                .build())\n            .warehouse(\"mywh\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # https://docs.snowflake.com/en/sql-reference/sql/create-dynamic-table#examples\n  dt:\n    type: snowflake:DynamicTable\n    properties:\n      comment: example comment\n      database: mydb\n      query: SELECT product_id, product_name FROM \"mydb\".\"myschema\".\"staging_table\"\n      schema: myschema\n      targetLag:\n        maximumDuration: 20 minutes\n      warehouse: mywh\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/dynamicTable:DynamicTable dt \"mydb|myschema|product\"\n```\n\n ",
            "properties": {
                "automaticClustering": {
                    "type": "boolean",
                    "description": "Whether auto-clustering is enabled on the dynamic table. Not currently supported for dynamic tables.\n"
                },
                "bytes": {
                    "type": "integer",
                    "description": "Number of bytes that will be scanned if the entire dynamic table is scanned in a query.\n"
                },
                "clusterBy": {
                    "type": "string",
                    "description": "The clustering key for the dynamic table.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the dynamic table.\n"
                },
                "dataTimestamp": {
                    "type": "string",
                    "description": "Timestamp of the data in the base object(s) that is included in the dynamic table.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the dynamic table.\n"
                },
                "isClone": {
                    "type": "boolean",
                    "description": "TRUE if the dynamic table has been cloned, else FALSE.\n"
                },
                "isReplica": {
                    "type": "boolean",
                    "description": "TRUE if the dynamic table is a replica. else FALSE.\n"
                },
                "lastSuspendedOn": {
                    "type": "string",
                    "description": "Timestamp of last suspension.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier (i.e. name) for the dynamic table; must be unique for the schema in which the dynamic table is created.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Specifies whether to replace the dynamic table if it already exists.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Role that owns the dynamic table.\n"
                },
                "query": {
                    "type": "string",
                    "description": "Specifies the query to use to populate the dynamic table.\n"
                },
                "refreshMode": {
                    "type": "string",
                    "description": "INCREMENTAL if the dynamic table will use incremental refreshes, or FULL if it will recompute the whole table on every refresh.\n"
                },
                "refreshModeReason": {
                    "type": "string",
                    "description": "Explanation for why FULL refresh mode was chosen. NULL if refresh mode is not FULL.\n"
                },
                "rows": {
                    "type": "integer",
                    "description": "Number of rows in the table.\n"
                },
                "schedulingState": {
                    "type": "string",
                    "description": "Displays RUNNING for dynamic tables that are actively scheduling refreshes and SUSPENDED for suspended dynamic tables.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the dynamic table.\n"
                },
                "targetLag": {
                    "$ref": "#/types/snowflake:index/DynamicTableTargetLag:DynamicTableTargetLag",
                    "description": "Specifies the target lag time for the dynamic table.\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse in which to create the dynamic table.\n"
                }
            },
            "required": [
                "automaticClustering",
                "bytes",
                "clusterBy",
                "dataTimestamp",
                "database",
                "isClone",
                "isReplica",
                "lastSuspendedOn",
                "name",
                "owner",
                "query",
                "refreshMode",
                "refreshModeReason",
                "rows",
                "schedulingState",
                "schema",
                "targetLag",
                "warehouse"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the dynamic table.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the dynamic table.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier (i.e. name) for the dynamic table; must be unique for the schema in which the dynamic table is created.\n",
                    "willReplaceOnChanges": true
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Specifies whether to replace the dynamic table if it already exists.\n"
                },
                "query": {
                    "type": "string",
                    "description": "Specifies the query to use to populate the dynamic table.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the dynamic table.\n"
                },
                "targetLag": {
                    "$ref": "#/types/snowflake:index/DynamicTableTargetLag:DynamicTableTargetLag",
                    "description": "Specifies the target lag time for the dynamic table.\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse in which to create the dynamic table.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "query",
                "schema",
                "targetLag",
                "warehouse"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DynamicTable resources.\n",
                "properties": {
                    "automaticClustering": {
                        "type": "boolean",
                        "description": "Whether auto-clustering is enabled on the dynamic table. Not currently supported for dynamic tables.\n"
                    },
                    "bytes": {
                        "type": "integer",
                        "description": "Number of bytes that will be scanned if the entire dynamic table is scanned in a query.\n"
                    },
                    "clusterBy": {
                        "type": "string",
                        "description": "The clustering key for the dynamic table.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the dynamic table.\n"
                    },
                    "dataTimestamp": {
                        "type": "string",
                        "description": "Timestamp of the data in the base object(s) that is included in the dynamic table.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the dynamic table.\n"
                    },
                    "isClone": {
                        "type": "boolean",
                        "description": "TRUE if the dynamic table has been cloned, else FALSE.\n"
                    },
                    "isReplica": {
                        "type": "boolean",
                        "description": "TRUE if the dynamic table is a replica. else FALSE.\n"
                    },
                    "lastSuspendedOn": {
                        "type": "string",
                        "description": "Timestamp of last suspension.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier (i.e. name) for the dynamic table; must be unique for the schema in which the dynamic table is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "orReplace": {
                        "type": "boolean",
                        "description": "Specifies whether to replace the dynamic table if it already exists.\n"
                    },
                    "owner": {
                        "type": "string",
                        "description": "Role that owns the dynamic table.\n"
                    },
                    "query": {
                        "type": "string",
                        "description": "Specifies the query to use to populate the dynamic table.\n",
                        "willReplaceOnChanges": true
                    },
                    "refreshMode": {
                        "type": "string",
                        "description": "INCREMENTAL if the dynamic table will use incremental refreshes, or FULL if it will recompute the whole table on every refresh.\n"
                    },
                    "refreshModeReason": {
                        "type": "string",
                        "description": "Explanation for why FULL refresh mode was chosen. NULL if refresh mode is not FULL.\n"
                    },
                    "rows": {
                        "type": "integer",
                        "description": "Number of rows in the table.\n"
                    },
                    "schedulingState": {
                        "type": "string",
                        "description": "Displays RUNNING for dynamic tables that are actively scheduling refreshes and SUSPENDED for suspended dynamic tables.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the dynamic table.\n"
                    },
                    "targetLag": {
                        "$ref": "#/types/snowflake:index/DynamicTableTargetLag:DynamicTableTargetLag",
                        "description": "Specifies the target lag time for the dynamic table.\n"
                    },
                    "warehouse": {
                        "type": "string",
                        "description": "The warehouse in which to create the dynamic table.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/emailNotificationIntegration:EmailNotificationIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst emailInt = new snowflake.EmailNotificationIntegration(\"emailInt\", {\n    allowedRecipients: [\"john.doe@gmail.com\"],\n    comment: \"A notification integration.\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nemail_int = snowflake.EmailNotificationIntegration(\"emailInt\",\n    allowed_recipients=[\"john.doe@gmail.com\"],\n    comment=\"A notification integration.\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var emailInt = new Snowflake.EmailNotificationIntegration(\"emailInt\", new()\n    {\n        AllowedRecipients = new[]\n        {\n            \"john.doe@gmail.com\",\n        },\n        Comment = \"A notification integration.\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewEmailNotificationIntegration(ctx, \"emailInt\", \u0026snowflake.EmailNotificationIntegrationArgs{\n\t\t\tAllowedRecipients: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"john.doe@gmail.com\"),\n\t\t\t},\n\t\t\tComment: pulumi.String(\"A notification integration.\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.EmailNotificationIntegration;\nimport com.pulumi.snowflake.EmailNotificationIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var emailInt = new EmailNotificationIntegration(\"emailInt\", EmailNotificationIntegrationArgs.builder()        \n            .allowedRecipients(\"john.doe@gmail.com\")\n            .comment(\"A notification integration.\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  emailInt:\n    type: snowflake:EmailNotificationIntegration\n    properties:\n      allowedRecipients:\n        - john.doe@gmail.com\n      comment: A notification integration.\n      enabled: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/emailNotificationIntegration:EmailNotificationIntegration example name\n```\n\n ",
            "properties": {
                "allowedRecipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of email addresses that should receive notifications.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A comment for the email integration.\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                }
            },
            "required": [
                "enabled",
                "name"
            ],
            "inputProperties": {
                "allowedRecipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of email addresses that should receive notifications.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A comment for the email integration.\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EmailNotificationIntegration resources.\n",
                "properties": {
                    "allowedRecipients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of email addresses that should receive notifications.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A comment for the email integration.\n"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/externalFunction:ExternalFunction": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst testExtFunc = new snowflake.ExternalFunction(\"testExtFunc\", {\n    apiIntegration: \"api_integration_name\",\n    args: [\n        {\n            name: \"arg1\",\n            type: \"varchar\",\n        },\n        {\n            name: \"arg2\",\n            type: \"varchar\",\n        },\n    ],\n    database: \"my_test_db\",\n    returnBehavior: \"IMMUTABLE\",\n    returnType: \"variant\",\n    schema: \"my_test_schema\",\n    urlOfProxyAndResource: \"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntest_ext_func = snowflake.ExternalFunction(\"testExtFunc\",\n    api_integration=\"api_integration_name\",\n    args=[\n        snowflake.ExternalFunctionArgArgs(\n            name=\"arg1\",\n            type=\"varchar\",\n        ),\n        snowflake.ExternalFunctionArgArgs(\n            name=\"arg2\",\n            type=\"varchar\",\n        ),\n    ],\n    database=\"my_test_db\",\n    return_behavior=\"IMMUTABLE\",\n    return_type=\"variant\",\n    schema=\"my_test_schema\",\n    url_of_proxy_and_resource=\"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testExtFunc = new Snowflake.ExternalFunction(\"testExtFunc\", new()\n    {\n        ApiIntegration = \"api_integration_name\",\n        Args = new[]\n        {\n            new Snowflake.Inputs.ExternalFunctionArgArgs\n            {\n                Name = \"arg1\",\n                Type = \"varchar\",\n            },\n            new Snowflake.Inputs.ExternalFunctionArgArgs\n            {\n                Name = \"arg2\",\n                Type = \"varchar\",\n            },\n        },\n        Database = \"my_test_db\",\n        ReturnBehavior = \"IMMUTABLE\",\n        ReturnType = \"variant\",\n        Schema = \"my_test_schema\",\n        UrlOfProxyAndResource = \"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewExternalFunction(ctx, \"testExtFunc\", \u0026snowflake.ExternalFunctionArgs{\n\t\t\tApiIntegration: pulumi.String(\"api_integration_name\"),\n\t\t\tArgs: snowflake.ExternalFunctionArgArray{\n\t\t\t\t\u0026snowflake.ExternalFunctionArgArgs{\n\t\t\t\t\tName: pulumi.String(\"arg1\"),\n\t\t\t\t\tType: pulumi.String(\"varchar\"),\n\t\t\t\t},\n\t\t\t\t\u0026snowflake.ExternalFunctionArgArgs{\n\t\t\t\t\tName: pulumi.String(\"arg2\"),\n\t\t\t\t\tType: pulumi.String(\"varchar\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDatabase:              pulumi.String(\"my_test_db\"),\n\t\t\tReturnBehavior:        pulumi.String(\"IMMUTABLE\"),\n\t\t\tReturnType:            pulumi.String(\"variant\"),\n\t\t\tSchema:                pulumi.String(\"my_test_schema\"),\n\t\t\tUrlOfProxyAndResource: pulumi.String(\"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ExternalFunction;\nimport com.pulumi.snowflake.ExternalFunctionArgs;\nimport com.pulumi.snowflake.inputs.ExternalFunctionArgArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testExtFunc = new ExternalFunction(\"testExtFunc\", ExternalFunctionArgs.builder()        \n            .apiIntegration(\"api_integration_name\")\n            .args(            \n                ExternalFunctionArgArgs.builder()\n                    .name(\"arg1\")\n                    .type(\"varchar\")\n                    .build(),\n                ExternalFunctionArgArgs.builder()\n                    .name(\"arg2\")\n                    .type(\"varchar\")\n                    .build())\n            .database(\"my_test_db\")\n            .returnBehavior(\"IMMUTABLE\")\n            .returnType(\"variant\")\n            .schema(\"my_test_schema\")\n            .urlOfProxyAndResource(\"https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testExtFunc:\n    type: snowflake:ExternalFunction\n    properties:\n      apiIntegration: api_integration_name\n      args:\n        - name: arg1\n          type: varchar\n        - name: arg2\n          type: varchar\n      database: my_test_db\n      returnBehavior: IMMUTABLE\n      returnType: variant\n      schema: my_test_schema\n      urlOfProxyAndResource: https://123456.execute-api.us-west-2.amazonaws.com/prod/test_func\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | external function name | \u003clist of function arg types, separated with '-'\u003e\n\n```sh\n $ pulumi import snowflake:index/externalFunction:ExternalFunction example 'dbName|schemaName|externalFunctionName|varchar-varchar-varchar'\n```\n\n ",
            "properties": {
                "apiIntegration": {
                    "type": "string",
                    "description": "The name of the API integration object that should be used to authenticate the call to the proxy service.\n"
                },
                "args": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalFunctionArg:ExternalFunctionArg"
                    },
                    "description": "Specifies the arguments/inputs for the external function. These should correspond to the arguments that the remote service expects.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A description of the external function.\n"
                },
                "compression": {
                    "type": "string",
                    "description": "If specified, the JSON payload is compressed when sent from Snowflake to the proxy service, and when sent back from the proxy service to Snowflake.\n"
                },
                "contextHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Binds Snowflake context function results to HTTP headers.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the external function was created.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the external function.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalFunctionHeader:ExternalFunctionHeader"
                    },
                    "description": "Allows users to specify key-value metadata that is sent with every request as HTTP headers.\n"
                },
                "maxBatchRows": {
                    "type": "integer",
                    "description": "This specifies the maximum number of rows in each batch sent to the proxy service.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Argument name\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the external function when called with null inputs.\n"
                },
                "requestTranslator": {
                    "type": "string",
                    "description": "This specifies the name of the request translator function\n"
                },
                "responseTranslator": {
                    "type": "string",
                    "description": "This specifies the name of the response translator function.\n"
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n"
                },
                "returnNullAllowed": {
                    "type": "boolean",
                    "description": "Indicates whether the function can return NULL values or must return only NON-NULL values.\n"
                },
                "returnType": {
                    "type": "string",
                    "description": "Specifies the data type returned by the external function.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the external function.\n"
                },
                "urlOfProxyAndResource": {
                    "type": "string",
                    "description": "This is the invocation URL of the proxy service and resource through which Snowflake calls the remote service.\n"
                }
            },
            "required": [
                "apiIntegration",
                "createdOn",
                "database",
                "name",
                "returnBehavior",
                "returnType",
                "schema",
                "urlOfProxyAndResource"
            ],
            "inputProperties": {
                "apiIntegration": {
                    "type": "string",
                    "description": "The name of the API integration object that should be used to authenticate the call to the proxy service.\n",
                    "willReplaceOnChanges": true
                },
                "args": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalFunctionArg:ExternalFunctionArg"
                    },
                    "description": "Specifies the arguments/inputs for the external function. These should correspond to the arguments that the remote service expects.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "A description of the external function.\n",
                    "willReplaceOnChanges": true
                },
                "compression": {
                    "type": "string",
                    "description": "If specified, the JSON payload is compressed when sent from Snowflake to the proxy service, and when sent back from the proxy service to Snowflake.\n",
                    "willReplaceOnChanges": true
                },
                "contextHeaders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Binds Snowflake context function results to HTTP headers.\n",
                    "willReplaceOnChanges": true
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the external function.\n",
                    "willReplaceOnChanges": true
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalFunctionHeader:ExternalFunctionHeader"
                    },
                    "description": "Allows users to specify key-value metadata that is sent with every request as HTTP headers.\n",
                    "willReplaceOnChanges": true
                },
                "maxBatchRows": {
                    "type": "integer",
                    "description": "This specifies the maximum number of rows in each batch sent to the proxy service.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Argument name\n",
                    "willReplaceOnChanges": true
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the external function when called with null inputs.\n",
                    "willReplaceOnChanges": true
                },
                "requestTranslator": {
                    "type": "string",
                    "description": "This specifies the name of the request translator function\n",
                    "willReplaceOnChanges": true
                },
                "responseTranslator": {
                    "type": "string",
                    "description": "This specifies the name of the response translator function.\n",
                    "willReplaceOnChanges": true
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n",
                    "willReplaceOnChanges": true
                },
                "returnNullAllowed": {
                    "type": "boolean",
                    "description": "Indicates whether the function can return NULL values or must return only NON-NULL values.\n",
                    "willReplaceOnChanges": true
                },
                "returnType": {
                    "type": "string",
                    "description": "Specifies the data type returned by the external function.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the external function.\n",
                    "willReplaceOnChanges": true
                },
                "urlOfProxyAndResource": {
                    "type": "string",
                    "description": "This is the invocation URL of the proxy service and resource through which Snowflake calls the remote service.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "apiIntegration",
                "database",
                "returnBehavior",
                "returnType",
                "schema",
                "urlOfProxyAndResource"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalFunction resources.\n",
                "properties": {
                    "apiIntegration": {
                        "type": "string",
                        "description": "The name of the API integration object that should be used to authenticate the call to the proxy service.\n",
                        "willReplaceOnChanges": true
                    },
                    "args": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ExternalFunctionArg:ExternalFunctionArg"
                        },
                        "description": "Specifies the arguments/inputs for the external function. These should correspond to the arguments that the remote service expects.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "A description of the external function.\n",
                        "willReplaceOnChanges": true
                    },
                    "compression": {
                        "type": "string",
                        "description": "If specified, the JSON payload is compressed when sent from Snowflake to the proxy service, and when sent back from the proxy service to Snowflake.\n",
                        "willReplaceOnChanges": true
                    },
                    "contextHeaders": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Binds Snowflake context function results to HTTP headers.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the external function was created.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the external function.\n",
                        "willReplaceOnChanges": true
                    },
                    "headers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ExternalFunctionHeader:ExternalFunctionHeader"
                        },
                        "description": "Allows users to specify key-value metadata that is sent with every request as HTTP headers.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxBatchRows": {
                        "type": "integer",
                        "description": "This specifies the maximum number of rows in each batch sent to the proxy service.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Argument name\n",
                        "willReplaceOnChanges": true
                    },
                    "nullInputBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the external function when called with null inputs.\n",
                        "willReplaceOnChanges": true
                    },
                    "requestTranslator": {
                        "type": "string",
                        "description": "This specifies the name of the request translator function\n",
                        "willReplaceOnChanges": true
                    },
                    "responseTranslator": {
                        "type": "string",
                        "description": "This specifies the name of the response translator function.\n",
                        "willReplaceOnChanges": true
                    },
                    "returnBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the function when returning results\n",
                        "willReplaceOnChanges": true
                    },
                    "returnNullAllowed": {
                        "type": "boolean",
                        "description": "Indicates whether the function can return NULL values or must return only NON-NULL values.\n",
                        "willReplaceOnChanges": true
                    },
                    "returnType": {
                        "type": "string",
                        "description": "Specifies the data type returned by the external function.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the external function.\n",
                        "willReplaceOnChanges": true
                    },
                    "urlOfProxyAndResource": {
                        "type": "string",
                        "description": "This is the invocation URL of the proxy service and resource through which Snowflake calls the remote service.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/externalOauthIntegration:ExternalOauthIntegration": {
            "description": "An External OAuth security integration allows a client to use a third-party authorization server to obtain the access tokens needed to interact with Snowflake.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst azure = new snowflake.ExternalOauthIntegration(\"azure\", {\n    audienceUrls: [\"https://analysis.windows.net/powerbi/connector/Snowflake\"],\n    enabled: true,\n    issuer: \"https://sts.windows.net/00000000-0000-0000-0000-000000000000\",\n    jwsKeysUrls: [\"https://login.windows.net/common/discovery/keys\"],\n    snowflakeUserMappingAttribute: \"LOGIN_NAME\",\n    tokenUserMappingClaims: [\"upn\"],\n    type: \"AZURE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nazure = snowflake.ExternalOauthIntegration(\"azure\",\n    audience_urls=[\"https://analysis.windows.net/powerbi/connector/Snowflake\"],\n    enabled=True,\n    issuer=\"https://sts.windows.net/00000000-0000-0000-0000-000000000000\",\n    jws_keys_urls=[\"https://login.windows.net/common/discovery/keys\"],\n    snowflake_user_mapping_attribute=\"LOGIN_NAME\",\n    token_user_mapping_claims=[\"upn\"],\n    type=\"AZURE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var azure = new Snowflake.ExternalOauthIntegration(\"azure\", new()\n    {\n        AudienceUrls = new[]\n        {\n            \"https://analysis.windows.net/powerbi/connector/Snowflake\",\n        },\n        Enabled = true,\n        Issuer = \"https://sts.windows.net/00000000-0000-0000-0000-000000000000\",\n        JwsKeysUrls = new[]\n        {\n            \"https://login.windows.net/common/discovery/keys\",\n        },\n        SnowflakeUserMappingAttribute = \"LOGIN_NAME\",\n        TokenUserMappingClaims = new[]\n        {\n            \"upn\",\n        },\n        Type = \"AZURE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewExternalOauthIntegration(ctx, \"azure\", \u0026snowflake.ExternalOauthIntegrationArgs{\n\t\t\tAudienceUrls: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://analysis.windows.net/powerbi/connector/Snowflake\"),\n\t\t\t},\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tIssuer:  pulumi.String(\"https://sts.windows.net/00000000-0000-0000-0000-000000000000\"),\n\t\t\tJwsKeysUrls: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"https://login.windows.net/common/discovery/keys\"),\n\t\t\t},\n\t\t\tSnowflakeUserMappingAttribute: pulumi.String(\"LOGIN_NAME\"),\n\t\t\tTokenUserMappingClaims: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"upn\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ExternalOauthIntegration;\nimport com.pulumi.snowflake.ExternalOauthIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var azure = new ExternalOauthIntegration(\"azure\", ExternalOauthIntegrationArgs.builder()        \n            .audienceUrls(\"https://analysis.windows.net/powerbi/connector/Snowflake\")\n            .enabled(true)\n            .issuer(\"https://sts.windows.net/00000000-0000-0000-0000-000000000000\")\n            .jwsKeysUrls(\"https://login.windows.net/common/discovery/keys\")\n            .snowflakeUserMappingAttribute(\"LOGIN_NAME\")\n            .tokenUserMappingClaims(\"upn\")\n            .type(\"AZURE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  azure:\n    type: snowflake:ExternalOauthIntegration\n    properties:\n      audienceUrls:\n        - https://analysis.windows.net/powerbi/connector/Snowflake\n      enabled: true\n      issuer: https://sts.windows.net/00000000-0000-0000-0000-000000000000\n      jwsKeysUrls:\n        - https://login.windows.net/common/discovery/keys\n      snowflakeUserMappingAttribute: LOGIN_NAME\n      tokenUserMappingClaims:\n        - upn\n      type: AZURE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/externalOauthIntegration:ExternalOauthIntegration example name\n```\n\n ",
            "properties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of roles that the client can set as the primary role.\n"
                },
                "anyRoleMode": {
                    "type": "string",
                    "description": "Specifies whether the OAuth client or user can use a role that is not defined in the OAuth access token.\n"
                },
                "audienceUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies additional values that can be used for the access token's audience validation on top of using the Customer's Snowflake Account URL\n"
                },
                "blockedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of roles that a client cannot set as the primary role. Do not include ACCOUNTADMIN, ORGADMIN or SECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the OAuth integration.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the External OAUTH integration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether to initiate operation of the integration or suspend it.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Specifies the URL to define the OAuth 2.0 authorization server.\n"
                },
                "jwsKeysUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the endpoint or a list of endpoints from which to download public keys or certificates to validate an External OAuth access token. The maximum number of URLs that can be specified in the list is 3.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the External Oath integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n"
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies a second RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers. Used for key rotation.\n"
                },
                "scopeDelimiter": {
                    "type": "string",
                    "description": "Specifies the scope delimiter in the authorization token.\n"
                },
                "scopeMappingAttribute": {
                    "type": "string",
                    "description": "Specifies the access token claim to map the access token to an account role.\n"
                },
                "snowflakeUserMappingAttribute": {
                    "type": "string",
                    "description": "Indicates which Snowflake user record attribute should be used to map the access token to a Snowflake user record.\n"
                },
                "tokenUserMappingClaims": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the access token claim or claims that can be used to map the access token to a Snowflake user record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the OAuth 2.0 authorization server to be Okta, Microsoft Azure AD, Ping Identity PingFederate, or a Custom OAuth 2.0 authorization server.\n"
                }
            },
            "required": [
                "createdOn",
                "enabled",
                "issuer",
                "name",
                "snowflakeUserMappingAttribute",
                "tokenUserMappingClaims",
                "type"
            ],
            "inputProperties": {
                "allowedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of roles that the client can set as the primary role.\n"
                },
                "anyRoleMode": {
                    "type": "string",
                    "description": "Specifies whether the OAuth client or user can use a role that is not defined in the OAuth access token.\n"
                },
                "audienceUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies additional values that can be used for the access token's audience validation on top of using the Customer's Snowflake Account URL\n"
                },
                "blockedRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of roles that a client cannot set as the primary role. Do not include ACCOUNTADMIN, ORGADMIN or SECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the OAuth integration.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether to initiate operation of the integration or suspend it.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "Specifies the URL to define the OAuth 2.0 authorization server.\n"
                },
                "jwsKeysUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the endpoint or a list of endpoints from which to download public keys or certificates to validate an External OAuth access token. The maximum number of URLs that can be specified in the list is 3.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the External Oath integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n",
                    "willReplaceOnChanges": true
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies a Base64-encoded RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies a second RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers. Used for key rotation.\n"
                },
                "scopeDelimiter": {
                    "type": "string",
                    "description": "Specifies the scope delimiter in the authorization token.\n"
                },
                "scopeMappingAttribute": {
                    "type": "string",
                    "description": "Specifies the access token claim to map the access token to an account role.\n"
                },
                "snowflakeUserMappingAttribute": {
                    "type": "string",
                    "description": "Indicates which Snowflake user record attribute should be used to map the access token to a Snowflake user record.\n"
                },
                "tokenUserMappingClaims": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the access token claim or claims that can be used to map the access token to a Snowflake user record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the OAuth 2.0 authorization server to be Okta, Microsoft Azure AD, Ping Identity PingFederate, or a Custom OAuth 2.0 authorization server.\n"
                }
            },
            "requiredInputs": [
                "enabled",
                "issuer",
                "snowflakeUserMappingAttribute",
                "tokenUserMappingClaims",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalOauthIntegration resources.\n",
                "properties": {
                    "allowedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of roles that the client can set as the primary role.\n"
                    },
                    "anyRoleMode": {
                        "type": "string",
                        "description": "Specifies whether the OAuth client or user can use a role that is not defined in the OAuth access token.\n"
                    },
                    "audienceUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies additional values that can be used for the access token's audience validation on top of using the Customer's Snowflake Account URL\n"
                    },
                    "blockedRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of roles that a client cannot set as the primary role. Do not include ACCOUNTADMIN, ORGADMIN or SECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the OAuth integration.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the External OAUTH integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether to initiate operation of the integration or suspend it.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "Specifies the URL to define the OAuth 2.0 authorization server.\n"
                    },
                    "jwsKeysUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the endpoint or a list of endpoints from which to download public keys or certificates to validate an External OAuth access token. The maximum number of URLs that can be specified in the list is 3.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the External Oath integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "rsaPublicKey": {
                        "type": "string",
                        "description": "Specifies a Base64-encoded RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers.\n"
                    },
                    "rsaPublicKey2": {
                        "type": "string",
                        "description": "Specifies a second RSA public key, without the -----BEGIN PUBLIC KEY----- and -----END PUBLIC KEY----- headers. Used for key rotation.\n"
                    },
                    "scopeDelimiter": {
                        "type": "string",
                        "description": "Specifies the scope delimiter in the authorization token.\n"
                    },
                    "scopeMappingAttribute": {
                        "type": "string",
                        "description": "Specifies the access token claim to map the access token to an account role.\n"
                    },
                    "snowflakeUserMappingAttribute": {
                        "type": "string",
                        "description": "Indicates which Snowflake user record attribute should be used to map the access token to a Snowflake user record.\n"
                    },
                    "tokenUserMappingClaims": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the access token claim or claims that can be used to map the access token to a Snowflake user record.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the OAuth 2.0 authorization server to be Okta, Microsoft Azure AD, Ping Identity PingFederate, or a Custom OAuth 2.0 authorization server.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/externalTable:ExternalTable": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst externalTable = new snowflake.ExternalTable(\"externalTable\", {\n    columns: [\n        {\n            name: \"id\",\n            type: \"int\",\n        },\n        {\n            name: \"data\",\n            type: \"text\",\n        },\n    ],\n    comment: \"External table\",\n    database: \"db\",\n    fileFormat: \"TYPE = CSV FIELD_DELIMITER = '|'\",\n    schema: \"schema\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexternal_table = snowflake.ExternalTable(\"externalTable\",\n    columns=[\n        snowflake.ExternalTableColumnArgs(\n            name=\"id\",\n            type=\"int\",\n        ),\n        snowflake.ExternalTableColumnArgs(\n            name=\"data\",\n            type=\"text\",\n        ),\n    ],\n    comment=\"External table\",\n    database=\"db\",\n    file_format=\"TYPE = CSV FIELD_DELIMITER = '|'\",\n    schema=\"schema\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var externalTable = new Snowflake.ExternalTable(\"externalTable\", new()\n    {\n        Columns = new[]\n        {\n            new Snowflake.Inputs.ExternalTableColumnArgs\n            {\n                Name = \"id\",\n                Type = \"int\",\n            },\n            new Snowflake.Inputs.ExternalTableColumnArgs\n            {\n                Name = \"data\",\n                Type = \"text\",\n            },\n        },\n        Comment = \"External table\",\n        Database = \"db\",\n        FileFormat = \"TYPE = CSV FIELD_DELIMITER = '|'\",\n        Schema = \"schema\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewExternalTable(ctx, \"externalTable\", \u0026snowflake.ExternalTableArgs{\n\t\t\tColumns: snowflake.ExternalTableColumnArray{\n\t\t\t\t\u0026snowflake.ExternalTableColumnArgs{\n\t\t\t\t\tName: pulumi.String(\"id\"),\n\t\t\t\t\tType: pulumi.String(\"int\"),\n\t\t\t\t},\n\t\t\t\t\u0026snowflake.ExternalTableColumnArgs{\n\t\t\t\t\tName: pulumi.String(\"data\"),\n\t\t\t\t\tType: pulumi.String(\"text\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tComment:    pulumi.String(\"External table\"),\n\t\t\tDatabase:   pulumi.String(\"db\"),\n\t\t\tFileFormat: pulumi.String(\"TYPE = CSV FIELD_DELIMITER = '|'\"),\n\t\t\tSchema:     pulumi.String(\"schema\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ExternalTable;\nimport com.pulumi.snowflake.ExternalTableArgs;\nimport com.pulumi.snowflake.inputs.ExternalTableColumnArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var externalTable = new ExternalTable(\"externalTable\", ExternalTableArgs.builder()        \n            .columns(            \n                ExternalTableColumnArgs.builder()\n                    .name(\"id\")\n                    .type(\"int\")\n                    .build(),\n                ExternalTableColumnArgs.builder()\n                    .name(\"data\")\n                    .type(\"text\")\n                    .build())\n            .comment(\"External table\")\n            .database(\"db\")\n            .fileFormat(\"TYPE = CSV FIELD_DELIMITER = '|'\")\n            .schema(\"schema\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  externalTable:\n    type: snowflake:ExternalTable\n    properties:\n      columns:\n        - name: id\n          type: int\n        - name: data\n          type: text\n      comment: External table\n      database: db\n      fileFormat: TYPE = CSV FIELD_DELIMITER = '|'\n      schema: schema\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | external table name\n\n```sh\n $ pulumi import snowflake:index/externalTable:ExternalTable example 'dbName|schemaName|externalTableName'\n```\n\n ",
            "properties": {
                "autoRefresh": {
                    "type": "boolean",
                    "description": "Specifies whether to automatically refresh the external table metadata once, immediately after the external table is created.\n"
                },
                "awsSnsTopic": {
                    "type": "string",
                    "description": "Specifies the aws sns topic for the external table.\n"
                },
                "columns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalTableColumn:ExternalTableColumn"
                    },
                    "description": "Definitions of a column to create in the external table. Minimum one required.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the external table.\n"
                },
                "copyGrants": {
                    "type": "boolean",
                    "description": "Specifies to retain the access permissions from the original table when an external table is recreated using the CREATE OR REPLACE TABLE variant\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "fileFormat": {
                    "type": "string",
                    "description": "Specifies the file format for the external table.\n"
                },
                "location": {
                    "type": "string",
                    "description": "Specifies a location for the external table.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Column name\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Name of the role that owns the external table.\n"
                },
                "partitionBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies any partition columns to evaluate for the external table.\n"
                },
                "pattern": {
                    "type": "string",
                    "description": "Specifies the file names and/or paths on the external stage to match.\n"
                },
                "refreshOnCreate": {
                    "type": "boolean",
                    "description": "Specifies weather to refresh when an external table is created.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "tableFormat": {
                    "type": "string",
                    "description": "Identifies the external table table type. For now, only \"delta\" for Delta Lake table format is supported.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalTableTag:ExternalTableTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "required": [
                "columns",
                "database",
                "fileFormat",
                "location",
                "name",
                "owner",
                "schema"
            ],
            "inputProperties": {
                "autoRefresh": {
                    "type": "boolean",
                    "description": "Specifies whether to automatically refresh the external table metadata once, immediately after the external table is created.\n",
                    "willReplaceOnChanges": true
                },
                "awsSnsTopic": {
                    "type": "string",
                    "description": "Specifies the aws sns topic for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "columns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalTableColumn:ExternalTableColumn"
                    },
                    "description": "Definitions of a column to create in the external table. Minimum one required.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "copyGrants": {
                    "type": "boolean",
                    "description": "Specifies to retain the access permissions from the original table when an external table is recreated using the CREATE OR REPLACE TABLE variant\n",
                    "willReplaceOnChanges": true
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "fileFormat": {
                    "type": "string",
                    "description": "Specifies the file format for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "location": {
                    "type": "string",
                    "description": "Specifies a location for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Column name\n",
                    "willReplaceOnChanges": true
                },
                "partitionBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies any partition columns to evaluate for the external table.\n",
                    "willReplaceOnChanges": true
                },
                "pattern": {
                    "type": "string",
                    "description": "Specifies the file names and/or paths on the external stage to match.\n",
                    "willReplaceOnChanges": true
                },
                "refreshOnCreate": {
                    "type": "boolean",
                    "description": "Specifies weather to refresh when an external table is created.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "tableFormat": {
                    "type": "string",
                    "description": "Identifies the external table table type. For now, only \"delta\" for Delta Lake table format is supported.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ExternalTableTag:ExternalTableTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "requiredInputs": [
                "columns",
                "database",
                "fileFormat",
                "location",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalTable resources.\n",
                "properties": {
                    "autoRefresh": {
                        "type": "boolean",
                        "description": "Specifies whether to automatically refresh the external table metadata once, immediately after the external table is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "awsSnsTopic": {
                        "type": "string",
                        "description": "Specifies the aws sns topic for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "columns": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ExternalTableColumn:ExternalTableColumn"
                        },
                        "description": "Definitions of a column to create in the external table. Minimum one required.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "copyGrants": {
                        "type": "boolean",
                        "description": "Specifies to retain the access permissions from the original table when an external table is recreated using the CREATE OR REPLACE TABLE variant\n",
                        "willReplaceOnChanges": true
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "fileFormat": {
                        "type": "string",
                        "description": "Specifies the file format for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "location": {
                        "type": "string",
                        "description": "Specifies a location for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Column name\n",
                        "willReplaceOnChanges": true
                    },
                    "owner": {
                        "type": "string",
                        "description": "Name of the role that owns the external table.\n"
                    },
                    "partitionBies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies any partition columns to evaluate for the external table.\n",
                        "willReplaceOnChanges": true
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Specifies the file names and/or paths on the external stage to match.\n",
                        "willReplaceOnChanges": true
                    },
                    "refreshOnCreate": {
                        "type": "boolean",
                        "description": "Specifies weather to refresh when an external table is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "Name of the schema that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "tableFormat": {
                        "type": "string",
                        "description": "Identifies the external table table type. For now, only \"delta\" for Delta Lake table format is supported.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ExternalTableTag:ExternalTableTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n",
                        "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/externalTableGrant:ExternalTableGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.ExternalTableGrant(\"grant\", {\n    databaseName: \"database\",\n    externalTableName: \"external_table\",\n    onFuture: false,\n    privilege: \"SELECT\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.ExternalTableGrant(\"grant\",\n    database_name=\"database\",\n    external_table_name=\"external_table\",\n    on_future=False,\n    privilege=\"SELECT\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.ExternalTableGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        ExternalTableName = \"external_table\",\n        OnFuture = false,\n        Privilege = \"SELECT\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        Shares = new[]\n        {\n            \"share1\",\n            \"share2\",\n        },\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewExternalTableGrant(ctx, \"grant\", \u0026snowflake.ExternalTableGrantArgs{\n\t\t\tDatabaseName:      pulumi.String(\"database\"),\n\t\t\tExternalTableName: pulumi.String(\"external_table\"),\n\t\t\tOnFuture:          pulumi.Bool(false),\n\t\t\tPrivilege:         pulumi.String(\"SELECT\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ExternalTableGrant;\nimport com.pulumi.snowflake.ExternalTableGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new ExternalTableGrant(\"grant\", ExternalTableGrantArgs.builder()        \n            .databaseName(\"database\")\n            .externalTableName(\"external_table\")\n            .onFuture(false)\n            .privilege(\"SELECT\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:ExternalTableGrant\n    properties:\n      databaseName: database\n      externalTableName: external_table\n      onFuture: false\n      privilege: SELECT\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database|schema|external_table|privilege|with_grant_option|on_future|roles|shares\n\n```sh\n $ pulumi import snowflake:index/externalTableGrant:ExternalTableGrant example \"MY_DATABASE|MY_SCHEMA|MY_TABLE_NAME|SELECT|false|false|role1,role2|share1,share2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future external tables on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "externalTableName": {
                    "type": "string",
                    "description": "The name of the external table on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all external tables in the given schema. When this is true and no schema*name is provided apply this grant on all external tables in the given database. The external*table*name and shares fields must be unset in order to use on*all. Cannot be used together with on*future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future external tables in the given schema. When this is true and no schema*name is provided apply this grant on all future external tables in the given database. The external*table*name and shares fields must be unset in order to use on*future. Cannot be used together with on*all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future external table. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future external tables on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "roles"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future external tables on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "externalTableName": {
                    "type": "string",
                    "description": "The name of the external table on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all external tables in the given schema. When this is true and no schema*name is provided apply this grant on all external tables in the given database. The external*table*name and shares fields must be unset in order to use on*all. Cannot be used together with on*future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future external tables in the given schema. When this is true and no schema*name is provided apply this grant on all future external tables in the given database. The external*table*name and shares fields must be unset in order to use on*future. Cannot be used together with on*all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future external table. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future external tables on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExternalTableGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future external tables on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "externalTableName": {
                        "type": "string",
                        "description": "The name of the external table on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all external tables in the given schema. When this is true and no schema*name is provided apply this grant on all external tables in the given database. The external*table*name and shares fields must be unset in order to use on*all. Cannot be used together with on*future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future external tables in the given schema. When this is true and no schema*name is provided apply this grant on all future external tables in the given database. The external*table*name and shares fields must be unset in order to use on*future. Cannot be used together with on*all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future external table. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future external tables on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/failoverGroup:FailoverGroup": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst db = new snowflake.Database(\"db\", {});\nconst sourceFailoverGroup = new snowflake.FailoverGroup(\"sourceFailoverGroup\", {\n    objectTypes: [\n        \"WAREHOUSES\",\n        \"DATABASES\",\n        \"INTEGRATIONS\",\n        \"ROLES\",\n    ],\n    allowedAccounts: [\n        \"\u003corg_name\u003e.\u003ctarget_account_name1\u003e\",\n        \"\u003corg_name\u003e.\u003ctarget_account_name2\u003e\",\n    ],\n    allowedDatabases: [db.name],\n    allowedIntegrationTypes: [\"SECURITY INTEGRATIONS\"],\n    replicationSchedule: {\n        cron: {\n            expression: \"0 0 10-20 * TUE,THU\",\n            timeZone: \"UTC\",\n        },\n    },\n});\nconst account2 = new snowflake.Provider(\"account2\", {});\nconst targetFailoverGroup = new snowflake.FailoverGroup(\"targetFailoverGroup\", {fromReplica: {\n    organizationName: \"...\",\n    sourceAccountName: \"...\",\n    name: snowflake_failover_group.fg.name,\n}}, {\n    provider: snowflake.account2,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndb = snowflake.Database(\"db\")\nsource_failover_group = snowflake.FailoverGroup(\"sourceFailoverGroup\",\n    object_types=[\n        \"WAREHOUSES\",\n        \"DATABASES\",\n        \"INTEGRATIONS\",\n        \"ROLES\",\n    ],\n    allowed_accounts=[\n        \"\u003corg_name\u003e.\u003ctarget_account_name1\u003e\",\n        \"\u003corg_name\u003e.\u003ctarget_account_name2\u003e\",\n    ],\n    allowed_databases=[db.name],\n    allowed_integration_types=[\"SECURITY INTEGRATIONS\"],\n    replication_schedule=snowflake.FailoverGroupReplicationScheduleArgs(\n        cron=snowflake.FailoverGroupReplicationScheduleCronArgs(\n            expression=\"0 0 10-20 * TUE,THU\",\n            time_zone=\"UTC\",\n        ),\n    ))\naccount2 = snowflake.Provider(\"account2\")\ntarget_failover_group = snowflake.FailoverGroup(\"targetFailoverGroup\", from_replica=snowflake.FailoverGroupFromReplicaArgs(\n    organization_name=\"...\",\n    source_account_name=\"...\",\n    name=snowflake_failover_group[\"fg\"][\"name\"],\n),\nopts=pulumi.ResourceOptions(provider=snowflake[\"account2\"]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var db = new Snowflake.Database(\"db\");\n\n    var sourceFailoverGroup = new Snowflake.FailoverGroup(\"sourceFailoverGroup\", new()\n    {\n        ObjectTypes = new[]\n        {\n            \"WAREHOUSES\",\n            \"DATABASES\",\n            \"INTEGRATIONS\",\n            \"ROLES\",\n        },\n        AllowedAccounts = new[]\n        {\n            \"\u003corg_name\u003e.\u003ctarget_account_name1\u003e\",\n            \"\u003corg_name\u003e.\u003ctarget_account_name2\u003e\",\n        },\n        AllowedDatabases = new[]\n        {\n            db.Name,\n        },\n        AllowedIntegrationTypes = new[]\n        {\n            \"SECURITY INTEGRATIONS\",\n        },\n        ReplicationSchedule = new Snowflake.Inputs.FailoverGroupReplicationScheduleArgs\n        {\n            Cron = new Snowflake.Inputs.FailoverGroupReplicationScheduleCronArgs\n            {\n                Expression = \"0 0 10-20 * TUE,THU\",\n                TimeZone = \"UTC\",\n            },\n        },\n    });\n\n    var account2 = new Snowflake.Provider(\"account2\");\n\n    var targetFailoverGroup = new Snowflake.FailoverGroup(\"targetFailoverGroup\", new()\n    {\n        FromReplica = new Snowflake.Inputs.FailoverGroupFromReplicaArgs\n        {\n            OrganizationName = \"...\",\n            SourceAccountName = \"...\",\n            Name = snowflake_failover_group.Fg.Name,\n        },\n    }, new CustomResourceOptions\n    {\n        Provider = snowflake.Account2,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdb, err := snowflake.NewDatabase(ctx, \"db\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewFailoverGroup(ctx, \"sourceFailoverGroup\", \u0026snowflake.FailoverGroupArgs{\n\t\t\tObjectTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"WAREHOUSES\"),\n\t\t\t\tpulumi.String(\"DATABASES\"),\n\t\t\t\tpulumi.String(\"INTEGRATIONS\"),\n\t\t\t\tpulumi.String(\"ROLES\"),\n\t\t\t},\n\t\t\tAllowedAccounts: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"\u003corg_name\u003e.\u003ctarget_account_name1\u003e\"),\n\t\t\t\tpulumi.String(\"\u003corg_name\u003e.\u003ctarget_account_name2\u003e\"),\n\t\t\t},\n\t\t\tAllowedDatabases: pulumi.StringArray{\n\t\t\t\tdb.Name,\n\t\t\t},\n\t\t\tAllowedIntegrationTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"SECURITY INTEGRATIONS\"),\n\t\t\t},\n\t\t\tReplicationSchedule: \u0026snowflake.FailoverGroupReplicationScheduleArgs{\n\t\t\t\tCron: \u0026snowflake.FailoverGroupReplicationScheduleCronArgs{\n\t\t\t\t\tExpression: pulumi.String(\"0 0 10-20 * TUE,THU\"),\n\t\t\t\t\tTimeZone:   pulumi.String(\"UTC\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewProvider(ctx, \"account2\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewFailoverGroup(ctx, \"targetFailoverGroup\", \u0026snowflake.FailoverGroupArgs{\n\t\t\tFromReplica: \u0026snowflake.FailoverGroupFromReplicaArgs{\n\t\t\t\tOrganizationName:  pulumi.String(\"...\"),\n\t\t\t\tSourceAccountName: pulumi.String(\"...\"),\n\t\t\t\tName:              pulumi.Any(snowflake_failover_group.Fg.Name),\n\t\t\t},\n\t\t}, pulumi.Provider(snowflake.Account2))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.FailoverGroup;\nimport com.pulumi.snowflake.FailoverGroupArgs;\nimport com.pulumi.snowflake.inputs.FailoverGroupReplicationScheduleArgs;\nimport com.pulumi.snowflake.inputs.FailoverGroupReplicationScheduleCronArgs;\nimport com.pulumi.snowflake.Provider;\nimport com.pulumi.snowflake.inputs.FailoverGroupFromReplicaArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var db = new Database(\"db\");\n\n        var sourceFailoverGroup = new FailoverGroup(\"sourceFailoverGroup\", FailoverGroupArgs.builder()        \n            .objectTypes(            \n                \"WAREHOUSES\",\n                \"DATABASES\",\n                \"INTEGRATIONS\",\n                \"ROLES\")\n            .allowedAccounts(            \n                \"\u003corg_name\u003e.\u003ctarget_account_name1\u003e\",\n                \"\u003corg_name\u003e.\u003ctarget_account_name2\u003e\")\n            .allowedDatabases(db.name())\n            .allowedIntegrationTypes(\"SECURITY INTEGRATIONS\")\n            .replicationSchedule(FailoverGroupReplicationScheduleArgs.builder()\n                .cron(FailoverGroupReplicationScheduleCronArgs.builder()\n                    .expression(\"0 0 10-20 * TUE,THU\")\n                    .timeZone(\"UTC\")\n                    .build())\n                .build())\n            .build());\n\n        var account2 = new Provider(\"account2\");\n\n        var targetFailoverGroup = new FailoverGroup(\"targetFailoverGroup\", FailoverGroupArgs.builder()        \n            .fromReplica(FailoverGroupFromReplicaArgs.builder()\n                .organizationName(\"...\")\n                .sourceAccountName(\"...\")\n                .name(snowflake_failover_group.fg().name())\n                .build())\n            .build(), CustomResourceOptions.builder()\n                .provider(snowflake.account2())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  db:\n    type: snowflake:Database\n  sourceFailoverGroup:\n    type: snowflake:FailoverGroup\n    properties:\n      objectTypes:\n        - WAREHOUSES\n        - DATABASES\n        - INTEGRATIONS\n        - ROLES\n      allowedAccounts:\n        - \u003corg_name\u003e.\u003ctarget_account_name1\u003e\n        - \u003corg_name\u003e.\u003ctarget_account_name2\u003e\n      allowedDatabases:\n        - ${db.name}\n      allowedIntegrationTypes:\n        - SECURITY INTEGRATIONS\n      replicationSchedule:\n        cron:\n          expression: 0 0 10-20 * TUE,THU\n          timeZone: UTC\n  account2:\n    type: pulumi:providers:snowflake\n  targetFailoverGroup:\n    type: snowflake:FailoverGroup\n    properties:\n      fromReplica:\n        organizationName: '...'\n        sourceAccountName: '...'\n        name: ${snowflake_failover_group.fg.name}\n    options:\n      provider: ${snowflake.account2}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/failoverGroup:FailoverGroup example 'fg1'\n```\n\n ",
            "properties": {
                "allowedAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the target account or list of target accounts to which replication and failover of specified objects from the source account is enabled. Secondary failover groups in the target accounts in this list can be promoted to serve as the primary failover group in case of failover. Expected in the form \\n\\n.\\n\\n\n"
                },
                "allowedDatabases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the database or list of databases for which you are enabling replication and failover from the source account to the target account. The OBJECT_TYPES list must include DATABASES to set this parameter.\n"
                },
                "allowedIntegrationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Type(s) of integrations for which you are enabling replication and failover from the source account to the target account. This property requires that the OBJECT_TYPES list include INTEGRATIONS to set this parameter. The following integration types are supported: \"SECURITY INTEGRATIONS\", \"API INTEGRATIONS\"\n"
                },
                "allowedShares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the share or list of shares for which you are enabling replication and failover from the source account to the target account. The OBJECT_TYPES list must include SHARES to set this parameter.\n"
                },
                "fromReplica": {
                    "$ref": "#/types/snowflake:index/FailoverGroupFromReplica:FailoverGroupFromReplica",
                    "description": "Specifies the name of the replica to use as the source for the failover group.\n"
                },
                "ignoreEditionCheck": {
                    "type": "boolean",
                    "description": "Allows replicating objects to accounts on lower editions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the primary failover group in the source account.\n"
                },
                "objectTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Type(s) of objects for which you are enabling replication and failover from the source account to the target account. The following object types are supported: \"ACCOUNT PARAMETERS\", \"DATABASES\", \"INTEGRATIONS\", \"NETWORK POLICIES\", \"RESOURCE MONITORS\", \"ROLES\", \"SHARES\", \"USERS\", \"WAREHOUSES\"\n"
                },
                "replicationSchedule": {
                    "$ref": "#/types/snowflake:index/FailoverGroupReplicationSchedule:FailoverGroupReplicationSchedule",
                    "description": "Specifies the schedule for refreshing secondary failover groups.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "allowedAccounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the target account or list of target accounts to which replication and failover of specified objects from the source account is enabled. Secondary failover groups in the target accounts in this list can be promoted to serve as the primary failover group in case of failover. Expected in the form \\n\\n.\\n\\n\n"
                },
                "allowedDatabases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the database or list of databases for which you are enabling replication and failover from the source account to the target account. The OBJECT_TYPES list must include DATABASES to set this parameter.\n"
                },
                "allowedIntegrationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Type(s) of integrations for which you are enabling replication and failover from the source account to the target account. This property requires that the OBJECT_TYPES list include INTEGRATIONS to set this parameter. The following integration types are supported: \"SECURITY INTEGRATIONS\", \"API INTEGRATIONS\"\n"
                },
                "allowedShares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the share or list of shares for which you are enabling replication and failover from the source account to the target account. The OBJECT_TYPES list must include SHARES to set this parameter.\n"
                },
                "fromReplica": {
                    "$ref": "#/types/snowflake:index/FailoverGroupFromReplica:FailoverGroupFromReplica",
                    "description": "Specifies the name of the replica to use as the source for the failover group.\n",
                    "willReplaceOnChanges": true
                },
                "ignoreEditionCheck": {
                    "type": "boolean",
                    "description": "Allows replicating objects to accounts on lower editions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the primary failover group in the source account.\n",
                    "willReplaceOnChanges": true
                },
                "objectTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Type(s) of objects for which you are enabling replication and failover from the source account to the target account. The following object types are supported: \"ACCOUNT PARAMETERS\", \"DATABASES\", \"INTEGRATIONS\", \"NETWORK POLICIES\", \"RESOURCE MONITORS\", \"ROLES\", \"SHARES\", \"USERS\", \"WAREHOUSES\"\n"
                },
                "replicationSchedule": {
                    "$ref": "#/types/snowflake:index/FailoverGroupReplicationSchedule:FailoverGroupReplicationSchedule",
                    "description": "Specifies the schedule for refreshing secondary failover groups.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FailoverGroup resources.\n",
                "properties": {
                    "allowedAccounts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the target account or list of target accounts to which replication and failover of specified objects from the source account is enabled. Secondary failover groups in the target accounts in this list can be promoted to serve as the primary failover group in case of failover. Expected in the form \\n\\n.\\n\\n\n"
                    },
                    "allowedDatabases": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the database or list of databases for which you are enabling replication and failover from the source account to the target account. The OBJECT_TYPES list must include DATABASES to set this parameter.\n"
                    },
                    "allowedIntegrationTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Type(s) of integrations for which you are enabling replication and failover from the source account to the target account. This property requires that the OBJECT_TYPES list include INTEGRATIONS to set this parameter. The following integration types are supported: \"SECURITY INTEGRATIONS\", \"API INTEGRATIONS\"\n"
                    },
                    "allowedShares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the share or list of shares for which you are enabling replication and failover from the source account to the target account. The OBJECT_TYPES list must include SHARES to set this parameter.\n"
                    },
                    "fromReplica": {
                        "$ref": "#/types/snowflake:index/FailoverGroupFromReplica:FailoverGroupFromReplica",
                        "description": "Specifies the name of the replica to use as the source for the failover group.\n",
                        "willReplaceOnChanges": true
                    },
                    "ignoreEditionCheck": {
                        "type": "boolean",
                        "description": "Allows replicating objects to accounts on lower editions.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Identifier for the primary failover group in the source account.\n",
                        "willReplaceOnChanges": true
                    },
                    "objectTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Type(s) of objects for which you are enabling replication and failover from the source account to the target account. The following object types are supported: \"ACCOUNT PARAMETERS\", \"DATABASES\", \"INTEGRATIONS\", \"NETWORK POLICIES\", \"RESOURCE MONITORS\", \"ROLES\", \"SHARES\", \"USERS\", \"WAREHOUSES\"\n"
                    },
                    "replicationSchedule": {
                        "$ref": "#/types/snowflake:index/FailoverGroupReplicationSchedule:FailoverGroupReplicationSchedule",
                        "description": "Specifies the schedule for refreshing secondary failover groups.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/failoverGroupGrant:FailoverGroupGrant": {
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "failoverGroupName": {
                    "type": "string",
                    "description": "The name of the failover group on which to grant privileges.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the failover group. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "roles"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "failoverGroupName": {
                    "type": "string",
                    "description": "The name of the failover group on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the failover group. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FailoverGroupGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "failoverGroupName": {
                        "type": "string",
                        "description": "The name of the failover group on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the failover group. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/fileFormat:FileFormat": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst exampleFileFormat = new snowflake.FileFormat(\"exampleFileFormat\", {\n    database: \"EXAMPLE_DB\",\n    formatType: \"CSV\",\n    schema: \"EXAMPLE_SCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexample_file_format = snowflake.FileFormat(\"exampleFileFormat\",\n    database=\"EXAMPLE_DB\",\n    format_type=\"CSV\",\n    schema=\"EXAMPLE_SCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleFileFormat = new Snowflake.FileFormat(\"exampleFileFormat\", new()\n    {\n        Database = \"EXAMPLE_DB\",\n        FormatType = \"CSV\",\n        Schema = \"EXAMPLE_SCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewFileFormat(ctx, \"exampleFileFormat\", \u0026snowflake.FileFormatArgs{\n\t\t\tDatabase:   pulumi.String(\"EXAMPLE_DB\"),\n\t\t\tFormatType: pulumi.String(\"CSV\"),\n\t\t\tSchema:     pulumi.String(\"EXAMPLE_SCHEMA\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.FileFormat;\nimport com.pulumi.snowflake.FileFormatArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleFileFormat = new FileFormat(\"exampleFileFormat\", FileFormatArgs.builder()        \n            .database(\"EXAMPLE_DB\")\n            .formatType(\"CSV\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleFileFormat:\n    type: snowflake:FileFormat\n    properties:\n      database: EXAMPLE_DB\n      formatType: CSV\n      schema: EXAMPLE_SCHEMA\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | file format name\n\n```sh\n $ pulumi import snowflake:index/fileFormat:FileFormat example 'dbName|schemaName|fileFormatName'\n```\n\n ",
            "properties": {
                "allowDuplicate": {
                    "type": "boolean",
                    "description": "Boolean that specifies to allow duplicate object field names (only the last one will be preserved).\n"
                },
                "binaryAsText": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.\n"
                },
                "binaryFormat": {
                    "type": "string",
                    "description": "Defines the encoding format for binary input or output.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the file format.\n"
                },
                "compression": {
                    "type": "string",
                    "description": "Specifies the current compression algorithm for the data file.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the file format.\n"
                },
                "dateFormat": {
                    "type": "string",
                    "description": "Defines the format of date values in the data files (data loading) or table (data unloading).\n"
                },
                "disableAutoConvert": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.\n"
                },
                "disableSnowflakeData": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.\n"
                },
                "emptyFieldAsNull": {
                    "type": "boolean",
                    "description": "Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.\n"
                },
                "enableOctal": {
                    "type": "boolean",
                    "description": "Boolean that enables parsing of octal numbers.\n"
                },
                "encoding": {
                    "type": "string",
                    "description": "String (constant) that specifies the character set of the source data when loading data into a table.\n"
                },
                "errorOnColumnCountMismatch": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.\n"
                },
                "escape": {
                    "type": "string",
                    "description": "Single character string used as the escape character for field values.\n"
                },
                "escapeUnenclosedField": {
                    "type": "string",
                    "description": "Single character string used as the escape character for unenclosed field values only.\n"
                },
                "fieldDelimiter": {
                    "type": "string",
                    "description": "Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).\n"
                },
                "fieldOptionallyEnclosedBy": {
                    "type": "string",
                    "description": "Character used to enclose strings.\n"
                },
                "fileExtension": {
                    "type": "string",
                    "description": "Specifies the extension for files unloaded to a stage.\n"
                },
                "formatType": {
                    "type": "string",
                    "description": "Specifies the format of the input files (for data loading) or output files (for data unloading).\n"
                },
                "ignoreUtf8Errors": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether UTF-8 encoding errors produce error conditions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.\n"
                },
                "nullIfs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String used to convert to and from SQL NULL.\n"
                },
                "parseHeader": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to use the first row headers in the data files to determine column names.\n"
                },
                "preserveSpace": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.\n"
                },
                "recordDelimiter": {
                    "type": "string",
                    "description": "Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).\n"
                },
                "replaceInvalidCharacters": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (�).\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the file format.\n"
                },
                "skipBlankLines": {
                    "type": "boolean",
                    "description": "Boolean that specifies to skip any blank lines encountered in the data files.\n"
                },
                "skipByteOrderMark": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.\n"
                },
                "skipHeader": {
                    "type": "integer",
                    "description": "Number of lines at the start of the file to skip.\n"
                },
                "stripNullValues": {
                    "type": "boolean",
                    "description": "Boolean that instructs the JSON parser to remove object fields or array elements containing null values.\n"
                },
                "stripOuterArray": {
                    "type": "boolean",
                    "description": "Boolean that instructs the JSON parser to remove outer brackets.\n"
                },
                "stripOuterElement": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.\n"
                },
                "timeFormat": {
                    "type": "string",
                    "description": "Defines the format of time values in the data files (data loading) or table (data unloading).\n"
                },
                "timestampFormat": {
                    "type": "string",
                    "description": "Defines the format of timestamp values in the data files (data loading) or table (data unloading).\n"
                },
                "trimSpace": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to remove white space from fields.\n"
                }
            },
            "required": [
                "binaryFormat",
                "compression",
                "database",
                "dateFormat",
                "encoding",
                "escape",
                "escapeUnenclosedField",
                "fieldDelimiter",
                "fieldOptionallyEnclosedBy",
                "formatType",
                "name",
                "nullIfs",
                "recordDelimiter",
                "schema",
                "timeFormat",
                "timestampFormat"
            ],
            "inputProperties": {
                "allowDuplicate": {
                    "type": "boolean",
                    "description": "Boolean that specifies to allow duplicate object field names (only the last one will be preserved).\n"
                },
                "binaryAsText": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.\n"
                },
                "binaryFormat": {
                    "type": "string",
                    "description": "Defines the encoding format for binary input or output.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the file format.\n"
                },
                "compression": {
                    "type": "string",
                    "description": "Specifies the current compression algorithm for the data file.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the file format.\n",
                    "willReplaceOnChanges": true
                },
                "dateFormat": {
                    "type": "string",
                    "description": "Defines the format of date values in the data files (data loading) or table (data unloading).\n"
                },
                "disableAutoConvert": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.\n"
                },
                "disableSnowflakeData": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.\n"
                },
                "emptyFieldAsNull": {
                    "type": "boolean",
                    "description": "Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.\n"
                },
                "enableOctal": {
                    "type": "boolean",
                    "description": "Boolean that enables parsing of octal numbers.\n"
                },
                "encoding": {
                    "type": "string",
                    "description": "String (constant) that specifies the character set of the source data when loading data into a table.\n"
                },
                "errorOnColumnCountMismatch": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.\n"
                },
                "escape": {
                    "type": "string",
                    "description": "Single character string used as the escape character for field values.\n"
                },
                "escapeUnenclosedField": {
                    "type": "string",
                    "description": "Single character string used as the escape character for unenclosed field values only.\n"
                },
                "fieldDelimiter": {
                    "type": "string",
                    "description": "Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).\n"
                },
                "fieldOptionallyEnclosedBy": {
                    "type": "string",
                    "description": "Character used to enclose strings.\n"
                },
                "fileExtension": {
                    "type": "string",
                    "description": "Specifies the extension for files unloaded to a stage.\n"
                },
                "formatType": {
                    "type": "string",
                    "description": "Specifies the format of the input files (for data loading) or output files (for data unloading).\n",
                    "willReplaceOnChanges": true
                },
                "ignoreUtf8Errors": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether UTF-8 encoding errors produce error conditions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.\n",
                    "willReplaceOnChanges": true
                },
                "nullIfs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "String used to convert to and from SQL NULL.\n"
                },
                "parseHeader": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to use the first row headers in the data files to determine column names.\n"
                },
                "preserveSpace": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.\n"
                },
                "recordDelimiter": {
                    "type": "string",
                    "description": "Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).\n"
                },
                "replaceInvalidCharacters": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (�).\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the file format.\n",
                    "willReplaceOnChanges": true
                },
                "skipBlankLines": {
                    "type": "boolean",
                    "description": "Boolean that specifies to skip any blank lines encountered in the data files.\n"
                },
                "skipByteOrderMark": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.\n"
                },
                "skipHeader": {
                    "type": "integer",
                    "description": "Number of lines at the start of the file to skip.\n"
                },
                "stripNullValues": {
                    "type": "boolean",
                    "description": "Boolean that instructs the JSON parser to remove object fields or array elements containing null values.\n"
                },
                "stripOuterArray": {
                    "type": "boolean",
                    "description": "Boolean that instructs the JSON parser to remove outer brackets.\n"
                },
                "stripOuterElement": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.\n"
                },
                "timeFormat": {
                    "type": "string",
                    "description": "Defines the format of time values in the data files (data loading) or table (data unloading).\n"
                },
                "timestampFormat": {
                    "type": "string",
                    "description": "Defines the format of timestamp values in the data files (data loading) or table (data unloading).\n"
                },
                "trimSpace": {
                    "type": "boolean",
                    "description": "Boolean that specifies whether to remove white space from fields.\n"
                }
            },
            "requiredInputs": [
                "database",
                "formatType",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FileFormat resources.\n",
                "properties": {
                    "allowDuplicate": {
                        "type": "boolean",
                        "description": "Boolean that specifies to allow duplicate object field names (only the last one will be preserved).\n"
                    },
                    "binaryAsText": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to interpret columns with no defined logical data type as UTF-8 text.\n"
                    },
                    "binaryFormat": {
                        "type": "string",
                        "description": "Defines the encoding format for binary input or output.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the file format.\n"
                    },
                    "compression": {
                        "type": "string",
                        "description": "Specifies the current compression algorithm for the data file.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the file format.\n",
                        "willReplaceOnChanges": true
                    },
                    "dateFormat": {
                        "type": "string",
                        "description": "Defines the format of date values in the data files (data loading) or table (data unloading).\n"
                    },
                    "disableAutoConvert": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether the XML parser disables automatic conversion of numeric and Boolean values from text to native representation.\n"
                    },
                    "disableSnowflakeData": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether the XML parser disables recognition of Snowflake semi-structured data tags.\n"
                    },
                    "emptyFieldAsNull": {
                        "type": "boolean",
                        "description": "Specifies whether to insert SQL NULL for empty fields in an input file, which are represented by two successive delimiters.\n"
                    },
                    "enableOctal": {
                        "type": "boolean",
                        "description": "Boolean that enables parsing of octal numbers.\n"
                    },
                    "encoding": {
                        "type": "string",
                        "description": "String (constant) that specifies the character set of the source data when loading data into a table.\n"
                    },
                    "errorOnColumnCountMismatch": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to generate a parsing error if the number of delimited columns (i.e. fields) in an input file does not match the number of columns in the corresponding table.\n"
                    },
                    "escape": {
                        "type": "string",
                        "description": "Single character string used as the escape character for field values.\n"
                    },
                    "escapeUnenclosedField": {
                        "type": "string",
                        "description": "Single character string used as the escape character for unenclosed field values only.\n"
                    },
                    "fieldDelimiter": {
                        "type": "string",
                        "description": "Specifies one or more singlebyte or multibyte characters that separate fields in an input file (data loading) or unloaded file (data unloading).\n"
                    },
                    "fieldOptionallyEnclosedBy": {
                        "type": "string",
                        "description": "Character used to enclose strings.\n"
                    },
                    "fileExtension": {
                        "type": "string",
                        "description": "Specifies the extension for files unloaded to a stage.\n"
                    },
                    "formatType": {
                        "type": "string",
                        "description": "Specifies the format of the input files (for data loading) or output files (for data unloading).\n",
                        "willReplaceOnChanges": true
                    },
                    "ignoreUtf8Errors": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether UTF-8 encoding errors produce error conditions.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the file format; must be unique for the database and schema in which the file format is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "nullIfs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "String used to convert to and from SQL NULL.\n"
                    },
                    "parseHeader": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to use the first row headers in the data files to determine column names.\n"
                    },
                    "preserveSpace": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether the XML parser preserves leading and trailing spaces in element content.\n"
                    },
                    "recordDelimiter": {
                        "type": "string",
                        "description": "Specifies one or more singlebyte or multibyte characters that separate records in an input file (data loading) or unloaded file (data unloading).\n"
                    },
                    "replaceInvalidCharacters": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to replace invalid UTF-8 characters with the Unicode replacement character (�).\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the file format.\n",
                        "willReplaceOnChanges": true
                    },
                    "skipBlankLines": {
                        "type": "boolean",
                        "description": "Boolean that specifies to skip any blank lines encountered in the data files.\n"
                    },
                    "skipByteOrderMark": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to skip the BOM (byte order mark), if present in a data file.\n"
                    },
                    "skipHeader": {
                        "type": "integer",
                        "description": "Number of lines at the start of the file to skip.\n"
                    },
                    "stripNullValues": {
                        "type": "boolean",
                        "description": "Boolean that instructs the JSON parser to remove object fields or array elements containing null values.\n"
                    },
                    "stripOuterArray": {
                        "type": "boolean",
                        "description": "Boolean that instructs the JSON parser to remove outer brackets.\n"
                    },
                    "stripOuterElement": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether the XML parser strips out the outer XML element, exposing 2nd level elements as separate documents.\n"
                    },
                    "timeFormat": {
                        "type": "string",
                        "description": "Defines the format of time values in the data files (data loading) or table (data unloading).\n"
                    },
                    "timestampFormat": {
                        "type": "string",
                        "description": "Defines the format of timestamp values in the data files (data loading) or table (data unloading).\n"
                    },
                    "trimSpace": {
                        "type": "boolean",
                        "description": "Boolean that specifies whether to remove white space from fields.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/fileFormatGrant:FileFormatGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.FileFormatGrant(\"grant\", {\n    databaseName: \"database\",\n    fileFormatName: \"file_format\",\n    onFuture: false,\n    privilege: \"SELECT\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.FileFormatGrant(\"grant\",\n    database_name=\"database\",\n    file_format_name=\"file_format\",\n    on_future=False,\n    privilege=\"SELECT\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.FileFormatGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        FileFormatName = \"file_format\",\n        OnFuture = false,\n        Privilege = \"SELECT\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewFileFormatGrant(ctx, \"grant\", \u0026snowflake.FileFormatGrantArgs{\n\t\t\tDatabaseName:   pulumi.String(\"database\"),\n\t\t\tFileFormatName: pulumi.String(\"file_format\"),\n\t\t\tOnFuture:       pulumi.Bool(false),\n\t\t\tPrivilege:      pulumi.String(\"SELECT\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.FileFormatGrant;\nimport com.pulumi.snowflake.FileFormatGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new FileFormatGrant(\"grant\", FileFormatGrantArgs.builder()        \n            .databaseName(\"database\")\n            .fileFormatName(\"file_format\")\n            .onFuture(false)\n            .privilege(\"SELECT\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:FileFormatGrant\n    properties:\n      databaseName: database\n      fileFormatName: file_format\n      onFuture: false\n      privilege: SELECT\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|file_format_name|privilege|with_grant_option|on_future|roles\n\n```sh\n $ pulumi import snowflake:index/fileFormatGrant:FileFormatGrant example \"MY_DATABASE|MY_SCHEMA|MY_FILE_FORMAT|USAGE|false|false|role1,role2'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future file formats on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "fileFormatName": {
                    "type": "string",
                    "description": "The name of the file format on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all file formats in the given schema. When this is true and no schema*name is provided apply this grant on all file formats in the given database. The file*format*name field must be unset in order to use on*all. Cannot be used together with on*future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future file formats in the given schema. When this is true and no schema*name is provided apply this grant on all future file formats in the given database. The file*format*name field must be unset in order to use on*future. Cannot be used together with on*all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future file format. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future file formats on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "roles"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future file formats on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "fileFormatName": {
                    "type": "string",
                    "description": "The name of the file format on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all file formats in the given schema. When this is true and no schema*name is provided apply this grant on all file formats in the given database. The file*format*name field must be unset in order to use on*all. Cannot be used together with on*future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future file formats in the given schema. When this is true and no schema*name is provided apply this grant on all future file formats in the given database. The file*format*name field must be unset in order to use on*future. Cannot be used together with on*all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future file format. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future file formats on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FileFormatGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future file formats on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "fileFormatName": {
                        "type": "string",
                        "description": "The name of the file format on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all file formats in the given schema. When this is true and no schema*name is provided apply this grant on all file formats in the given database. The file*format*name field must be unset in order to use on*all. Cannot be used together with on*future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future file formats in the given schema. When this is true and no schema*name is provided apply this grant on all future file formats in the given database. The file*format*name field must be unset in order to use on*future. Cannot be used together with on*all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future file format. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future file formats on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/function:Function": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.DatabaseArgs;\nimport com.pulumi.snowflake.Schema;\nimport com.pulumi.snowflake.SchemaArgs;\nimport com.pulumi.snowflake.Function;\nimport com.pulumi.snowflake.FunctionArgs;\nimport com.pulumi.snowflake.inputs.FunctionArgumentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var db = new Database(\"db\", DatabaseArgs.builder()        \n            .dataRetentionDays(1)\n            .build());\n\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .database(db.name())\n            .dataRetentionDays(1)\n            .build());\n\n        var testFunctJava = new Function(\"testFunctJava\", FunctionArgs.builder()        \n            .database(\"MY_DB\")\n            .schema(\"MY_SCHEMA\")\n            .arguments(FunctionArgumentArgs.builder()\n                .name(\"arg1\")\n                .type(\"number\")\n                .build())\n            .comment(\"Example for java language\")\n            .returnType(\"varchar\")\n            .language(\"java\")\n            .handler(\"CoolFunc.test\")\n            .statement(\"class CoolFunc {public static String test(int n) {return \\\"hello!\\\";}}\")\n            .build());\n\n        var pythonTest = new Function(\"pythonTest\", FunctionArgs.builder()        \n            .database(\"MY_DB\")\n            .schema(\"MY_SCHEMA\")\n            .arguments(FunctionArgumentArgs.builder()\n                .name(\"arg1\")\n                .type(\"number\")\n                .build())\n            .comment(\"Example for Python language\")\n            .returnType(\"NUMBER(38,0)\")\n            .nullInputBehavior(\"CALLED ON NULL INPUT\")\n            .returnBehavior(\"VOLATILE\")\n            .language(\"python\")\n            .runtimeVersion(\"3.8\")\n            .handler(\"add_py\")\n            .statement(\"def add_py(i): return i+1\")\n            .build());\n\n        var sqlTest = new Function(\"sqlTest\", FunctionArgs.builder()        \n            .database(\"MY_DB\")\n            .schema(\"MY_SCHEMA\")\n            .arguments(FunctionArgumentArgs.builder()\n                .name(\"arg1\")\n                .type(\"number\")\n                .build())\n            .comment(\"Example for SQL language\")\n            .returnType(\"NUMBER(38,0)\")\n            .nullInputBehavior(\"CALLED ON NULL INPUT\")\n            .returnBehavior(\"VOLATILE\")\n            .statement(\"select arg1 + 1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create database\n  db:\n    type: snowflake:Database\n    properties:\n      dataRetentionDays: 1\n  # Create schema\n  schema:\n    type: snowflake:Schema\n    properties:\n      database: ${db.name}\n      dataRetentionDays: 1\n  # Example for Java language\n  testFunctJava:\n    type: snowflake:Function\n    properties:\n      database: MY_DB\n      schema: MY_SCHEMA\n      arguments:\n        - name: arg1\n          type: number\n      comment: Example for java language\n      returnType: varchar\n      language: java\n      handler: CoolFunc.test\n      statement: class CoolFunc {public static String test(int n) {return \"hello!\";}}\n  # Example for Python language\n  pythonTest:\n    type: snowflake:Function\n    properties:\n      database: MY_DB\n      schema: MY_SCHEMA\n      arguments:\n        - name: arg1\n          type: number\n      comment: Example for Python language\n      returnType: NUMBER(38,0)\n      nullInputBehavior: CALLED ON NULL INPUT\n      returnBehavior: VOLATILE\n      language: python\n      runtimeVersion: '3.8'\n      handler: add_py\n      statement: 'def add_py(i): return i+1'\n  # Example SQL language\n  sqlTest:\n    type: snowflake:Function\n    properties:\n      database: MY_DB\n      schema: MY_SCHEMA\n      arguments:\n        - name: arg1\n          type: number\n      comment: Example for SQL language\n      returnType: NUMBER(38,0)\n      nullInputBehavior: CALLED ON NULL INPUT\n      returnBehavior: VOLATILE\n      statement: select arg1 + 1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | function name | \u003clist of arg types, separated with '-'\u003e\n\n```sh\n $ pulumi import snowflake:index/function:Function example 'dbName|schemaName|functionName|varchar-varchar-varchar'\n```\n\n ",
            "properties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/FunctionArgument:FunctionArgument"
                    },
                    "description": "List of the arguments for the function\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the function.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the function. Don't use the | character.\n"
                },
                "handler": {
                    "type": "string",
                    "description": "The handler method for Java / Python function.\n"
                },
                "imports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Imports for Java / Python functions. For Java this a list of jar files, for Python this is a list of Python files.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the function is secure.\n"
                },
                "language": {
                    "type": "string",
                    "description": "The language of the statement\n"
                },
                "name": {
                    "type": "string",
                    "description": "The argument name\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when called with null inputs.\n"
                },
                "packages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of package imports to use for Java / Python functions. For Java, package imports should be of the form: package*name:version*number, where package*name is snowflake*domain:package. For Python use it should be: ('numpy','pandas','xgboost==1.5.0').\n"
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n"
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the function\n"
                },
                "runtimeVersion": {
                    "type": "string",
                    "description": "Required for Python functions. Specifies Python runtime version.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the function. Don't use the | character.\n"
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the javascript / java / sql / python code used to create the function.\n"
                },
                "targetPath": {
                    "type": "string",
                    "description": "The target path for the Java / Python functions. For Java, it is the path of compiled jar files and for the Python it is the path of the Python files.\n"
                }
            },
            "required": [
                "database",
                "name",
                "returnType",
                "schema",
                "statement"
            ],
            "inputProperties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/FunctionArgument:FunctionArgument"
                    },
                    "description": "List of the arguments for the function\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the function.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the function. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "handler": {
                    "type": "string",
                    "description": "The handler method for Java / Python function.\n",
                    "willReplaceOnChanges": true
                },
                "imports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Imports for Java / Python functions. For Java this a list of jar files, for Python this is a list of Python files.\n",
                    "willReplaceOnChanges": true
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the function is secure.\n"
                },
                "language": {
                    "type": "string",
                    "description": "The language of the statement\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The argument name\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when called with null inputs.\n",
                    "willReplaceOnChanges": true
                },
                "packages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of package imports to use for Java / Python functions. For Java, package imports should be of the form: package*name:version*number, where package*name is snowflake*domain:package. For Python use it should be: ('numpy','pandas','xgboost==1.5.0').\n",
                    "willReplaceOnChanges": true
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n",
                    "willReplaceOnChanges": true
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the function\n",
                    "willReplaceOnChanges": true
                },
                "runtimeVersion": {
                    "type": "string",
                    "description": "Required for Python functions. Specifies Python runtime version.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the function. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the javascript / java / sql / python code used to create the function.\n",
                    "willReplaceOnChanges": true
                },
                "targetPath": {
                    "type": "string",
                    "description": "The target path for the Java / Python functions. For Java, it is the path of compiled jar files and for the Python it is the path of the Python files.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "returnType",
                "schema",
                "statement"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Function resources.\n",
                "properties": {
                    "arguments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/FunctionArgument:FunctionArgument"
                        },
                        "description": "List of the arguments for the function\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the function.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the function. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "handler": {
                        "type": "string",
                        "description": "The handler method for Java / Python function.\n",
                        "willReplaceOnChanges": true
                    },
                    "imports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Imports for Java / Python functions. For Java this a list of jar files, for Python this is a list of Python files.\n",
                        "willReplaceOnChanges": true
                    },
                    "isSecure": {
                        "type": "boolean",
                        "description": "Specifies that the function is secure.\n"
                    },
                    "language": {
                        "type": "string",
                        "description": "The language of the statement\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The argument name\n"
                    },
                    "nullInputBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the function when called with null inputs.\n",
                        "willReplaceOnChanges": true
                    },
                    "packages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of package imports to use for Java / Python functions. For Java, package imports should be of the form: package*name:version*number, where package*name is snowflake*domain:package. For Python use it should be: ('numpy','pandas','xgboost==1.5.0').\n",
                        "willReplaceOnChanges": true
                    },
                    "returnBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the function when returning results\n",
                        "willReplaceOnChanges": true
                    },
                    "returnType": {
                        "type": "string",
                        "description": "The return type of the function\n",
                        "willReplaceOnChanges": true
                    },
                    "runtimeVersion": {
                        "type": "string",
                        "description": "Required for Python functions. Specifies Python runtime version.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the function. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "statement": {
                        "type": "string",
                        "description": "Specifies the javascript / java / sql / python code used to create the function.\n",
                        "willReplaceOnChanges": true
                    },
                    "targetPath": {
                        "type": "string",
                        "description": "The target path for the Java / Python functions. For Java, it is the path of compiled jar files and for the Python it is the path of the Python files.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/functionGrant:FunctionGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.FunctionGrant(\"grant\", {\n    argumentDataTypes: [\n        \"array\",\n        \"string\",\n    ],\n    databaseName: \"database\",\n    functionName: \"function\",\n    onFuture: false,\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.FunctionGrant(\"grant\",\n    argument_data_types=[\n        \"array\",\n        \"string\",\n    ],\n    database_name=\"database\",\n    function_name=\"function\",\n    on_future=False,\n    privilege=\"USAGE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.FunctionGrant(\"grant\", new()\n    {\n        ArgumentDataTypes = new[]\n        {\n            \"array\",\n            \"string\",\n        },\n        DatabaseName = \"database\",\n        FunctionName = \"function\",\n        OnFuture = false,\n        Privilege = \"USAGE\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        Shares = new[]\n        {\n            \"share1\",\n            \"share2\",\n        },\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewFunctionGrant(ctx, \"grant\", \u0026snowflake.FunctionGrantArgs{\n\t\t\tArgumentDataTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"array\"),\n\t\t\t\tpulumi.String(\"string\"),\n\t\t\t},\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tFunctionName: pulumi.String(\"function\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"USAGE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.FunctionGrant;\nimport com.pulumi.snowflake.FunctionGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new FunctionGrant(\"grant\", FunctionGrantArgs.builder()        \n            .argumentDataTypes(            \n                \"array\",\n                \"string\")\n            .databaseName(\"database\")\n            .functionName(\"function\")\n            .onFuture(false)\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:FunctionGrant\n    properties:\n      argumentDataTypes:\n        - array\n        - string\n      databaseName: database\n      functionName: function\n      onFuture: false\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|function_name|argument_data_types|privilege|with_grant_option|on_future|roles|shares\n\n```sh\n $ pulumi import snowflake:index/functionGrant:FunctionGrant example \"MY_DATABASE|MY_SCHEMA|MY_FUNCTION|ARG1TYPE,ARG2TYPE|USAGE|false|false|role1,role2|share1,share2\"\n```\n\n ",
            "properties": {
                "argumentDataTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of the argument data types for the function (must be present if function has arguments and function_name is present)\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future functions on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "functionName": {
                    "type": "string",
                    "description": "The name of the function on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all functions in the given schema. When this is true and no schema*name is provided apply this grant on all functions in the given database. The function*name, arguments, return*type, and shares fields must be unset in order to use on*all. Cannot be used together with on*future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future functions in the given schema. When this is true and no schema*name is provided apply this grant on all future functions in the given database. The function*name, arguments, return*type, and shares fields must be unset in order to use on*future. Cannot be used together with on*all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future function. Must be one of `USAGE` or `OWNERSHIP`. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future functions on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "roles"
            ],
            "inputProperties": {
                "argumentDataTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of the argument data types for the function (must be present if function has arguments and function_name is present)\n",
                    "willReplaceOnChanges": true
                },
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future functions on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "functionName": {
                    "type": "string",
                    "description": "The name of the function on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all functions in the given schema. When this is true and no schema*name is provided apply this grant on all functions in the given database. The function*name, arguments, return*type, and shares fields must be unset in order to use on*all. Cannot be used together with on*future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future functions in the given schema. When this is true and no schema*name is provided apply this grant on all future functions in the given database. The function*name, arguments, return*type, and shares fields must be unset in order to use on*future. Cannot be used together with on*all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future function. Must be one of `USAGE` or `OWNERSHIP`. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future functions on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FunctionGrant resources.\n",
                "properties": {
                    "argumentDataTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of the argument data types for the function (must be present if function has arguments and function_name is present)\n",
                        "willReplaceOnChanges": true
                    },
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future functions on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "functionName": {
                        "type": "string",
                        "description": "The name of the function on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all functions in the given schema. When this is true and no schema*name is provided apply this grant on all functions in the given database. The function*name, arguments, return*type, and shares fields must be unset in order to use on*all. Cannot be used together with on*future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future functions in the given schema. When this is true and no schema*name is provided apply this grant on all future functions in the given database. The function*name, arguments, return*type, and shares fields must be unset in order to use on*future. Cannot be used together with on*all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future function. Must be one of `USAGE` or `OWNERSHIP`. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future functions on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/grantPrivilegesToDatabaseRole:GrantPrivilegesToDatabaseRole": {
            "description": "!\u003e **Warning** Be careful when using `always_apply` field. It will always produce a plan (even when no changes were made) and can be harmful in some setups. For more details why we decided to introduce it to go our document explaining those design decisions (coming soon).\n\n{{% examples %}}\n## Example Usage\n### on database privileges\n##################################\n\n# list of privileges\nresource \"snowflake_grant_privileges_to_database_role\" \"example\" {\n  privileges         = [\"CREATE\", \"MONITOR\"]\n  database_role_name = \"\\\"${snowflake_database_role.db_role.database}\\\".\\\"${snowflake_database_role.db_role.name}\\\"\"\n  on_database        = snowflake_database_role.db_role.database\n}\n\n# all privileges + grant option\nresource \"snowflake_grant_privileges_to_database_role\" \"example\" {\n  database_role_name = \"\\\"${snowflake_database_role.db_role.database}\\\".\\\"${snowflake_database_role.db_role.name}\\\"\"\n  on_database        = snowflake_database_role.db_role.database\n  all_privileges     = true\n  with_grant_option  = true\n}\n\n# all privileges + grant option + always apply\nresource \"snowflake_grant_privileges_to_database_role\" \"example\" {\n  database_role_name = \"\\\"${snowflake_database_role.db_role.database}\\\".\\\"${snowflake_database_role.db_role.name}\\\"\"\n  on_database        = snowflake_database_role.db_role.database\n  always_apply       = true\n  all_privileges     = true\n  with_grant_option  = true\n}\n\n##################################\n### schema privileges\n##################################\n\n# list of privileges\nresource \"snowflake_grant_privileges_to_database_role\" \"example\" {\n  privileges         = [\"MODIFY\", \"CREATE TABLE\"]\n  database_role_name = \"\\\"${snowflake_database_role.db_role.database}\\\".\\\"${snowflake_database_role.db_role.name}\\\"\"\n  on_schema {\n    schema_name = \"\\\"${snowflake_database_role.db_role.database}\\\".\\\"my_schema\\\"\" # note this is a fully qualified name!\n  }\n}\n\n# all privileges + grant option\nresource \"snowflake_grant_privileges_to_database_role\" \"example\" {\n  database_role_name = \"\\\"${snowflake_database_role.db_role.database}\\\".\\\"${snowflake_database_role.db_role.name}\\\"\"\n  on_schema {\n    schema_name = \"\\\"${snowflake_database_role.db_role.database}\\\".\\\"my_schema\\\"\" # note this is a fully qualified name!\n  }\n  all_privileges    = true\n  with_grant_option = true\n}\n\n# all schemas in database\nresource \"snowflake_grant_privileges_to_database_role\" \"example\" {\n  privileges         = [\"MODIFY\", \"CREATE TABLE\"]\n  database_role_name = \"\\\"${snowflake_database_role.db_role.database}\\\".\\\"${snowflake_database_role.db_role.name}\\\"\"\n  on_schema {\n    all_schemas_in_database = snowflake_database_role.db_role.database\n  }\n}\n\n# future schemas in database\nresource \"snowflake_grant_privileges_to_database_role\" \"example\" {\n  privileges         = [\"MODIFY\", \"CREATE TABLE\"]\n  database_role_name = \"\\\"${snowflake_database_role.db_role.database}\\\".\\\"${snowflake_database_role.db_role.name}\\\"\"\n  on_schema {\n    future_schemas_in_database = snowflake_database_role.db_role.database\n  }\n}\n\n##################################\n{{% /examples %}}\n\n## Import\n\n### Import examples #### Grant all privileges OnDatabase\n\n```sh\n $ pulumi import snowflake:index/grantPrivilegesToDatabaseRole:GrantPrivilegesToDatabaseRole \\\"test_db_role\\\"|false|false|ALL|OnDatabase|\\\"test_db\\\"\"`\n```\n\n #### Grant list of privileges OnAllSchemasInDatabase\n\n```sh\n $ pulumi import snowflake:index/grantPrivilegesToDatabaseRole:GrantPrivilegesToDatabaseRole \\\"test_db_role\\\"|false|false|CREATE TAG,CREATE TABLE|OnSchema|OnAllSchemasInDatabase|\\\"test_db\\\"\"`\n```\n\n #### Grant list of privileges on table\n\n```sh\n $ pulumi import snowflake:index/grantPrivilegesToDatabaseRole:GrantPrivilegesToDatabaseRole \\\"test_table\\\"\"`\n```\n\n #### Grant list of privileges OnAll tables in schema\n\n```sh\n $ pulumi import snowflake:index/grantPrivilegesToDatabaseRole:GrantPrivilegesToDatabaseRole \\\"test_schema\\\"\"`\n```\n\n ",
            "properties": {
                "allPrivileges": {
                    "type": "boolean",
                    "description": "Grant all privileges on the database role.\n"
                },
                "alwaysApply": {
                    "type": "boolean",
                    "description": "If true, the resource will always produce a “plan” and on “apply” it will re-grant defined privileges. It is\nsupposed to be used only in “grant privileges on all X’s in database / schema Y” or “grant all privileges to\nX” scenarios to make sure that every new object in a given database / schema is granted by the account role and every\nnew privilege is granted to the database role. Important note: this flag is not compliant with the Terraform assumptions\nof the config being eventually convergent (producing an empty plan).\n"
                },
                "alwaysApplyTrigger": {
                    "type": "string",
                    "description": "This field should not be set and its main purpose is to achieve the functionality described by always_apply field. This is value will be flipped to the opposite value on every pulumi up, thus creating a new plan that will re-apply grants.\n"
                },
                "databaseRoleName": {
                    "type": "string",
                    "description": "The fully qualified name of the database role to which privileges will be granted.\n"
                },
                "onDatabase": {
                    "type": "string",
                    "description": "The fully qualified name of the database on which privileges will be granted.\n"
                },
                "onSchema": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToDatabaseRoleOnSchema:GrantPrivilegesToDatabaseRoleOnSchema",
                    "description": "Specifies the schema on which privileges will be granted.\n"
                },
                "onSchemaObject": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToDatabaseRoleOnSchemaObject:GrantPrivilegesToDatabaseRoleOnSchemaObject",
                    "description": "Specifies the schema object on which privileges will be granted.\n"
                },
                "privileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to grant on the database role.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "If specified, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseRoleName"
            ],
            "inputProperties": {
                "allPrivileges": {
                    "type": "boolean",
                    "description": "Grant all privileges on the database role.\n"
                },
                "alwaysApply": {
                    "type": "boolean",
                    "description": "If true, the resource will always produce a “plan” and on “apply” it will re-grant defined privileges. It is\nsupposed to be used only in “grant privileges on all X’s in database / schema Y” or “grant all privileges to\nX” scenarios to make sure that every new object in a given database / schema is granted by the account role and every\nnew privilege is granted to the database role. Important note: this flag is not compliant with the Terraform assumptions\nof the config being eventually convergent (producing an empty plan).\n"
                },
                "alwaysApplyTrigger": {
                    "type": "string",
                    "description": "This field should not be set and its main purpose is to achieve the functionality described by always_apply field. This is value will be flipped to the opposite value on every pulumi up, thus creating a new plan that will re-apply grants.\n"
                },
                "databaseRoleName": {
                    "type": "string",
                    "description": "The fully qualified name of the database role to which privileges will be granted.\n",
                    "willReplaceOnChanges": true
                },
                "onDatabase": {
                    "type": "string",
                    "description": "The fully qualified name of the database on which privileges will be granted.\n",
                    "willReplaceOnChanges": true
                },
                "onSchema": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToDatabaseRoleOnSchema:GrantPrivilegesToDatabaseRoleOnSchema",
                    "description": "Specifies the schema on which privileges will be granted.\n",
                    "willReplaceOnChanges": true
                },
                "onSchemaObject": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToDatabaseRoleOnSchemaObject:GrantPrivilegesToDatabaseRoleOnSchemaObject",
                    "description": "Specifies the schema object on which privileges will be granted.\n",
                    "willReplaceOnChanges": true
                },
                "privileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to grant on the database role.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "If specified, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseRoleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GrantPrivilegesToDatabaseRole resources.\n",
                "properties": {
                    "allPrivileges": {
                        "type": "boolean",
                        "description": "Grant all privileges on the database role.\n"
                    },
                    "alwaysApply": {
                        "type": "boolean",
                        "description": "If true, the resource will always produce a “plan” and on “apply” it will re-grant defined privileges. It is\nsupposed to be used only in “grant privileges on all X’s in database / schema Y” or “grant all privileges to\nX” scenarios to make sure that every new object in a given database / schema is granted by the account role and every\nnew privilege is granted to the database role. Important note: this flag is not compliant with the Terraform assumptions\nof the config being eventually convergent (producing an empty plan).\n"
                    },
                    "alwaysApplyTrigger": {
                        "type": "string",
                        "description": "This field should not be set and its main purpose is to achieve the functionality described by always_apply field. This is value will be flipped to the opposite value on every pulumi up, thus creating a new plan that will re-apply grants.\n"
                    },
                    "databaseRoleName": {
                        "type": "string",
                        "description": "The fully qualified name of the database role to which privileges will be granted.\n",
                        "willReplaceOnChanges": true
                    },
                    "onDatabase": {
                        "type": "string",
                        "description": "The fully qualified name of the database on which privileges will be granted.\n",
                        "willReplaceOnChanges": true
                    },
                    "onSchema": {
                        "$ref": "#/types/snowflake:index/GrantPrivilegesToDatabaseRoleOnSchema:GrantPrivilegesToDatabaseRoleOnSchema",
                        "description": "Specifies the schema on which privileges will be granted.\n",
                        "willReplaceOnChanges": true
                    },
                    "onSchemaObject": {
                        "$ref": "#/types/snowflake:index/GrantPrivilegesToDatabaseRoleOnSchemaObject:GrantPrivilegesToDatabaseRoleOnSchemaObject",
                        "description": "Specifies the schema object on which privileges will be granted.\n",
                        "willReplaceOnChanges": true
                    },
                    "privileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges to grant on the database role.\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "If specified, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/grantPrivilegesToRole:GrantPrivilegesToRole": {
            "description": "{{% examples %}}\n## Example Usage\n### global privileges\n##################################\n\n# list of privileges\nresource \"snowflake_grant_privileges_to_role\" \"g1\" {\n  privileges = [\"MODIFY\", \"USAGE\"]\n  role_name  = snowflake_role.r.name\n  on_account = true\n}\n\n# all privileges + grant option\nresource \"snowflake_grant_privileges_to_role\" \"g2\" {\n  role_name         = snowflake_role.r.name\n  on_account        = true\n  all_privileges    = true\n  with_grant_option = true\n}\n\n##################################\n### account object privileges\n##################################\n\n# list of privileges\nresource \"snowflake_grant_privileges_to_role\" \"g3\" {\n  privileges = [\"CREATE\", \"MONITOR\"]\n  role_name  = snowflake_role.r.name\n  on_account_object {\n    object_type = \"DATABASE\"\n    object_name = snowflake_database.d.name\n  }\n}\n\n# all privileges + grant option\nresource \"snowflake_grant_privileges_to_role\" \"g4\" {\n  role_name = snowflake_role.r.name\n  on_account_object {\n    object_type = \"DATABASE\"\n    object_name = snowflake_database.d.name\n  }\n  all_privileges    = true\n  with_grant_option = true\n}\n\n##################################\n### schema privileges\n##################################\n\n# list of privileges\nresource \"snowflake_grant_privileges_to_role\" \"g5\" {\n  privileges = [\"MODIFY\", \"CREATE TABLE\"]\n  role_name  = snowflake_role.r.name\n  on_schema {\n    schema_name = \"\\\"my_db\\\".\\\"my_schema\\\"\" # note this is a fully qualified name!\n  }\n}\n\n# all privileges + grant option\nresource \"snowflake_grant_privileges_to_role\" \"g6\" {\n  role_name = snowflake_role.r.name\n  on_schema {\n    schema_name = \"\\\"my_db\\\".\\\"my_schema\\\"\" # note this is a fully qualified name!\n  }\n  all_privileges    = true\n  with_grant_option = true\n}\n\n# all schemas in database\nresource \"snowflake_grant_privileges_to_role\" \"g7\" {\n  privileges = [\"MODIFY\", \"CREATE TABLE\"]\n  role_name  = snowflake_role.r.name\n  on_schema {\n    all_schemas_in_database = snowflake_database.d.name\n  }\n}\n\n# future schemas in database\nresource \"snowflake_grant_privileges_to_role\" \"g8\" {\n  privileges = [\"MODIFY\", \"CREATE TABLE\"]\n  role_name  = snowflake_role.r.name\n  on_schema {\n    future_schemas_in_database = snowflake_database.d.name\n  }\n}\n\n##################################\n{{% /examples %}}\n\n## Import\n\nformat is role_name (string) | privileges (comma-delimited string) | all_privileges (bool) |with_grant_option (bool) | on_account (bool) | on_account_object (bool) | on_schema (bool) | on_schema_object (bool) | all (bool) | future (bool) | object_type (string) | object_name (string) | object_type_plural (string) | in_schema (bool) | schema_name (string) | in_database (bool) | database_name (string)\n\n```sh\n $ pulumi import snowflake:index/grantPrivilegesToRole:GrantPrivilegesToRole \"test_role|MANAGE GRANTS,MONITOR USAGE|false|false|true|false|false|false|false|false||||false||false|\"\n```\n\n ",
            "properties": {
                "allPrivileges": {
                    "type": "boolean",
                    "description": "Grant all privileges on the account role.\n"
                },
                "onAccount": {
                    "type": "boolean",
                    "description": "If true, the privileges will be granted on the account.\n"
                },
                "onAccountObject": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnAccountObject:GrantPrivilegesToRoleOnAccountObject",
                    "description": "Specifies the account object on which privileges will be granted\n"
                },
                "onSchema": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnSchema:GrantPrivilegesToRoleOnSchema",
                    "description": "Specifies the schema on which privileges will be granted.\n"
                },
                "onSchemaObject": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnSchemaObject:GrantPrivilegesToRoleOnSchemaObject",
                    "description": "Specifies the schema object on which privileges will be granted.\n"
                },
                "privileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to grant on the account role.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The fully qualified name of the role to which privileges will be granted.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "Specifies whether the grantee can grant the privileges to other users.\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "allPrivileges": {
                    "type": "boolean",
                    "description": "Grant all privileges on the account role.\n"
                },
                "onAccount": {
                    "type": "boolean",
                    "description": "If true, the privileges will be granted on the account.\n",
                    "willReplaceOnChanges": true
                },
                "onAccountObject": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnAccountObject:GrantPrivilegesToRoleOnAccountObject",
                    "description": "Specifies the account object on which privileges will be granted\n",
                    "willReplaceOnChanges": true
                },
                "onSchema": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnSchema:GrantPrivilegesToRoleOnSchema",
                    "description": "Specifies the schema on which privileges will be granted.\n",
                    "willReplaceOnChanges": true
                },
                "onSchemaObject": {
                    "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnSchemaObject:GrantPrivilegesToRoleOnSchemaObject",
                    "description": "Specifies the schema object on which privileges will be granted.\n",
                    "willReplaceOnChanges": true
                },
                "privileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to grant on the account role.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The fully qualified name of the role to which privileges will be granted.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "Specifies whether the grantee can grant the privileges to other users.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GrantPrivilegesToRole resources.\n",
                "properties": {
                    "allPrivileges": {
                        "type": "boolean",
                        "description": "Grant all privileges on the account role.\n"
                    },
                    "onAccount": {
                        "type": "boolean",
                        "description": "If true, the privileges will be granted on the account.\n",
                        "willReplaceOnChanges": true
                    },
                    "onAccountObject": {
                        "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnAccountObject:GrantPrivilegesToRoleOnAccountObject",
                        "description": "Specifies the account object on which privileges will be granted\n",
                        "willReplaceOnChanges": true
                    },
                    "onSchema": {
                        "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnSchema:GrantPrivilegesToRoleOnSchema",
                        "description": "Specifies the schema on which privileges will be granted.\n",
                        "willReplaceOnChanges": true
                    },
                    "onSchemaObject": {
                        "$ref": "#/types/snowflake:index/GrantPrivilegesToRoleOnSchemaObject:GrantPrivilegesToRoleOnSchemaObject",
                        "description": "Specifies the schema object on which privileges will be granted.\n",
                        "willReplaceOnChanges": true
                    },
                    "privileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges to grant on the account role.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The fully qualified name of the role to which privileges will be granted.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "Specifies whether the grantee can grant the privileges to other users.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/integrationGrant:IntegrationGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.IntegrationGrant(\"grant\", {\n    integrationName: \"integration\",\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.IntegrationGrant(\"grant\",\n    integration_name=\"integration\",\n    privilege=\"USAGE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.IntegrationGrant(\"grant\", new()\n    {\n        IntegrationName = \"integration\",\n        Privilege = \"USAGE\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewIntegrationGrant(ctx, \"grant\", \u0026snowflake.IntegrationGrantArgs{\n\t\t\tIntegrationName: pulumi.String(\"integration\"),\n\t\t\tPrivilege:       pulumi.String(\"USAGE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.IntegrationGrant;\nimport com.pulumi.snowflake.IntegrationGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new IntegrationGrant(\"grant\", IntegrationGrantArgs.builder()        \n            .integrationName(\"integration\")\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:IntegrationGrant\n    properties:\n      integrationName: integration\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is integration_name|privilege|with_grant_option|roles\n\n```sh\n $ pulumi import snowflake:index/integrationGrant:IntegrationGrant example \"MY_INTEGRATION|USAGE|false|role1,role2\"\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "integrationName": {
                    "type": "string",
                    "description": "Identifier for the integration; must be unique for your account.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the integration. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "integrationName"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "integrationName": {
                    "type": "string",
                    "description": "Identifier for the integration; must be unique for your account.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the integration. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "integrationName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "integrationName": {
                        "type": "string",
                        "description": "Identifier for the integration; must be unique for your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the integration. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/managedAccount:ManagedAccount": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ManagedAccount;\nimport com.pulumi.snowflake.ManagedAccountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var account = new ManagedAccount(\"account\", ManagedAccountArgs.builder()        \n            .adminName(\"admin\")\n            .adminPassword(\"secret\")\n            .cloud(\"aws\")\n            .comment(\"A managed account.\")\n            .locator(\"managed-account\")\n            .region(\"us-west-2\")\n            .type(\"READER\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  account:\n    type: snowflake:ManagedAccount\n    properties:\n      adminName: admin\n      adminPassword: secret\n      cloud: aws\n      comment: A managed account.\n      locator: managed-account\n      region: us-west-2\n      type: READER\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/managedAccount:ManagedAccount example name\n```\n\n ",
            "properties": {
                "adminName": {
                    "type": "string",
                    "description": "Identifier, as well as login name, for the initial user in the managed account. This user serves as the account administrator for the account.\n"
                },
                "adminPassword": {
                    "type": "string",
                    "description": "Password for the initial user in the managed account.\n",
                    "secret": true
                },
                "cloud": {
                    "type": "string",
                    "description": "Cloud in which the managed account is located.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the managed account.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the managed account was created.\n"
                },
                "locator": {
                    "type": "string",
                    "description": "Display name of the managed account.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the managed account; must be unique for your account.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Snowflake Region in which the managed account is located.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of managed account.\n"
                },
                "url": {
                    "type": "string",
                    "description": "URL for accessing the managed account, particularly through the web interface.\n"
                }
            },
            "required": [
                "adminName",
                "adminPassword",
                "cloud",
                "createdOn",
                "locator",
                "name",
                "region",
                "url"
            ],
            "inputProperties": {
                "adminName": {
                    "type": "string",
                    "description": "Identifier, as well as login name, for the initial user in the managed account. This user serves as the account administrator for the account.\n",
                    "willReplaceOnChanges": true
                },
                "adminPassword": {
                    "type": "string",
                    "description": "Password for the initial user in the managed account.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the managed account.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the managed account; must be unique for your account.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of managed account.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "adminName",
                "adminPassword"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedAccount resources.\n",
                "properties": {
                    "adminName": {
                        "type": "string",
                        "description": "Identifier, as well as login name, for the initial user in the managed account. This user serves as the account administrator for the account.\n",
                        "willReplaceOnChanges": true
                    },
                    "adminPassword": {
                        "type": "string",
                        "description": "Password for the initial user in the managed account.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "cloud": {
                        "type": "string",
                        "description": "Cloud in which the managed account is located.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the managed account.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the managed account was created.\n"
                    },
                    "locator": {
                        "type": "string",
                        "description": "Display name of the managed account.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Identifier for the managed account; must be unique for your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "region": {
                        "type": "string",
                        "description": "Snowflake Region in which the managed account is located.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of managed account.\n",
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "type": "string",
                        "description": "URL for accessing the managed account, particularly through the web interface.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/maskingPolicy:MaskingPolicy": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst test = new snowflake.MaskingPolicy(\"test\", {\n    database: \"EXAMPLE_DB\",\n    maskingExpression: `  case \n    when current_role() in ('ROLE_A') then \n      val \n    when is_role_in_session( 'ROLE_B' ) then \n      'ABC123'\n    else\n      '******'\n  end\n\n`,\n    returnDataType: \"VARCHAR\",\n    schema: \"EXAMPLE_SCHEMA\",\n    signature: {\n        columns: [{\n            name: \"val\",\n            type: \"VARCHAR\",\n        }],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntest = snowflake.MaskingPolicy(\"test\",\n    database=\"EXAMPLE_DB\",\n    masking_expression=\"\"\"  case \n    when current_role() in ('ROLE_A') then \n      val \n    when is_role_in_session( 'ROLE_B' ) then \n      'ABC123'\n    else\n      '******'\n  end\n\n\"\"\",\n    return_data_type=\"VARCHAR\",\n    schema=\"EXAMPLE_SCHEMA\",\n    signature=snowflake.MaskingPolicySignatureArgs(\n        columns=[snowflake.MaskingPolicySignatureColumnArgs(\n            name=\"val\",\n            type=\"VARCHAR\",\n        )],\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Snowflake.MaskingPolicy(\"test\", new()\n    {\n        Database = \"EXAMPLE_DB\",\n        MaskingExpression = @\"  case \n    when current_role() in ('ROLE_A') then \n      val \n    when is_role_in_session( 'ROLE_B' ) then \n      'ABC123'\n    else\n      '******'\n  end\n\n\",\n        ReturnDataType = \"VARCHAR\",\n        Schema = \"EXAMPLE_SCHEMA\",\n        Signature = new Snowflake.Inputs.MaskingPolicySignatureArgs\n        {\n            Columns = new[]\n            {\n                new Snowflake.Inputs.MaskingPolicySignatureColumnArgs\n                {\n                    Name = \"val\",\n                    Type = \"VARCHAR\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewMaskingPolicy(ctx, \"test\", \u0026snowflake.MaskingPolicyArgs{\n\t\t\tDatabase: pulumi.String(\"EXAMPLE_DB\"),\n\t\t\tMaskingExpression: pulumi.String(`  case \n    when current_role() in ('ROLE_A') then \n      val \n    when is_role_in_session( 'ROLE_B' ) then \n      'ABC123'\n    else\n      '******'\n  end\n\n`),\n\t\t\tReturnDataType: pulumi.String(\"VARCHAR\"),\n\t\t\tSchema:         pulumi.String(\"EXAMPLE_SCHEMA\"),\n\t\t\tSignature: \u0026snowflake.MaskingPolicySignatureArgs{\n\t\t\t\tColumns: snowflake.MaskingPolicySignatureColumnArray{\n\t\t\t\t\t\u0026snowflake.MaskingPolicySignatureColumnArgs{\n\t\t\t\t\t\tName: pulumi.String(\"val\"),\n\t\t\t\t\t\tType: pulumi.String(\"VARCHAR\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.MaskingPolicy;\nimport com.pulumi.snowflake.MaskingPolicyArgs;\nimport com.pulumi.snowflake.inputs.MaskingPolicySignatureArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new MaskingPolicy(\"test\", MaskingPolicyArgs.builder()        \n            .database(\"EXAMPLE_DB\")\n            .maskingExpression(\"\"\"\n  case \n    when current_role() in ('ROLE_A') then \n      val \n    when is_role_in_session( 'ROLE_B' ) then \n      'ABC123'\n    else\n      '******'\n  end\n\n            \"\"\")\n            .returnDataType(\"VARCHAR\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .signature(MaskingPolicySignatureArgs.builder()\n                .columns(MaskingPolicySignatureColumnArgs.builder()\n                    .name(\"val\")\n                    .type(\"VARCHAR\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: snowflake:MaskingPolicy\n    properties:\n      database: EXAMPLE_DB\n      maskingExpression: \"  case \\n    when current_role() in ('ROLE_A') then \\n      val \\n    when is_role_in_session( 'ROLE_B' ) then \\n      'ABC123'\\n    else\\n      '******'\\n  end\\n\\n\"\n      returnDataType: VARCHAR\n      schema: EXAMPLE_SCHEMA\n      signature:\n        columns:\n          - name: val\n            type: VARCHAR\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | policy name\n\n```sh\n $ pulumi import snowflake:index/maskingPolicy:MaskingPolicy example 'dbName|schemaName|policyName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the masking policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the masking policy.\n"
                },
                "exemptOtherPolicies": {
                    "type": "boolean",
                    "description": "Specifies whether the row access policy or conditional masking policy can reference a column that is already protected by a masking policy.\n"
                },
                "ifNotExists": {
                    "type": "boolean",
                    "description": "Prevent overwriting a previous masking policy with the same name.\n"
                },
                "maskingExpression": {
                    "type": "string",
                    "description": "Specifies the SQL expression that transforms the data.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the column name to mask.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Whether to override a previous masking policy with the same name.\n"
                },
                "qualifiedName": {
                    "type": "string",
                    "description": "Specifies the qualified identifier for the masking policy.\n"
                },
                "returnDataType": {
                    "type": "string",
                    "description": "Specifies the data type to return.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the masking policy.\n"
                },
                "signature": {
                    "$ref": "#/types/snowflake:index/MaskingPolicySignature:MaskingPolicySignature",
                    "description": "The signature for the masking policy; specifies the input columns and data types to evaluate at query runtime.\n"
                }
            },
            "required": [
                "database",
                "maskingExpression",
                "name",
                "qualifiedName",
                "returnDataType",
                "schema",
                "signature"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the masking policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the masking policy.\n",
                    "willReplaceOnChanges": true
                },
                "exemptOtherPolicies": {
                    "type": "boolean",
                    "description": "Specifies whether the row access policy or conditional masking policy can reference a column that is already protected by a masking policy.\n"
                },
                "ifNotExists": {
                    "type": "boolean",
                    "description": "Prevent overwriting a previous masking policy with the same name.\n"
                },
                "maskingExpression": {
                    "type": "string",
                    "description": "Specifies the SQL expression that transforms the data.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the column name to mask.\n",
                    "willReplaceOnChanges": true
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Whether to override a previous masking policy with the same name.\n"
                },
                "returnDataType": {
                    "type": "string",
                    "description": "Specifies the data type to return.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the masking policy.\n",
                    "willReplaceOnChanges": true
                },
                "signature": {
                    "$ref": "#/types/snowflake:index/MaskingPolicySignature:MaskingPolicySignature",
                    "description": "The signature for the masking policy; specifies the input columns and data types to evaluate at query runtime.\n"
                }
            },
            "requiredInputs": [
                "database",
                "maskingExpression",
                "returnDataType",
                "schema",
                "signature"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaskingPolicy resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the masking policy.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the masking policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "exemptOtherPolicies": {
                        "type": "boolean",
                        "description": "Specifies whether the row access policy or conditional masking policy can reference a column that is already protected by a masking policy.\n"
                    },
                    "ifNotExists": {
                        "type": "boolean",
                        "description": "Prevent overwriting a previous masking policy with the same name.\n"
                    },
                    "maskingExpression": {
                        "type": "string",
                        "description": "Specifies the SQL expression that transforms the data.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the column name to mask.\n",
                        "willReplaceOnChanges": true
                    },
                    "orReplace": {
                        "type": "boolean",
                        "description": "Whether to override a previous masking policy with the same name.\n"
                    },
                    "qualifiedName": {
                        "type": "string",
                        "description": "Specifies the qualified identifier for the masking policy.\n"
                    },
                    "returnDataType": {
                        "type": "string",
                        "description": "Specifies the data type to return.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the masking policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "signature": {
                        "$ref": "#/types/snowflake:index/MaskingPolicySignature:MaskingPolicySignature",
                        "description": "The signature for the masking policy; specifies the input columns and data types to evaluate at query runtime.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/maskingPolicyGrant:MaskingPolicyGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst example = new snowflake.MaskingPolicyGrant(\"example\", {\n    databaseName: \"EXAMPLE_DB_NAME\",\n    enableMultipleGrants: true,\n    maskingPolicyName: \"EXAMPLE_MASKING_POLICY_NAME\",\n    privilege: \"APPLY\",\n    roles: [\n        \"ROLE1_NAME\",\n        \"ROLE2_NAME\",\n    ],\n    schemaName: \"EXAMPLE_SCHEMA_NAME\",\n    withGrantOption: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexample = snowflake.MaskingPolicyGrant(\"example\",\n    database_name=\"EXAMPLE_DB_NAME\",\n    enable_multiple_grants=True,\n    masking_policy_name=\"EXAMPLE_MASKING_POLICY_NAME\",\n    privilege=\"APPLY\",\n    roles=[\n        \"ROLE1_NAME\",\n        \"ROLE2_NAME\",\n    ],\n    schema_name=\"EXAMPLE_SCHEMA_NAME\",\n    with_grant_option=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Snowflake.MaskingPolicyGrant(\"example\", new()\n    {\n        DatabaseName = \"EXAMPLE_DB_NAME\",\n        EnableMultipleGrants = true,\n        MaskingPolicyName = \"EXAMPLE_MASKING_POLICY_NAME\",\n        Privilege = \"APPLY\",\n        Roles = new[]\n        {\n            \"ROLE1_NAME\",\n            \"ROLE2_NAME\",\n        },\n        SchemaName = \"EXAMPLE_SCHEMA_NAME\",\n        WithGrantOption = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewMaskingPolicyGrant(ctx, \"example\", \u0026snowflake.MaskingPolicyGrantArgs{\n\t\t\tDatabaseName:         pulumi.String(\"EXAMPLE_DB_NAME\"),\n\t\t\tEnableMultipleGrants: pulumi.Bool(true),\n\t\t\tMaskingPolicyName:    pulumi.String(\"EXAMPLE_MASKING_POLICY_NAME\"),\n\t\t\tPrivilege:            pulumi.String(\"APPLY\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ROLE1_NAME\"),\n\t\t\t\tpulumi.String(\"ROLE2_NAME\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"EXAMPLE_SCHEMA_NAME\"),\n\t\t\tWithGrantOption: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.MaskingPolicyGrant;\nimport com.pulumi.snowflake.MaskingPolicyGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new MaskingPolicyGrant(\"example\", MaskingPolicyGrantArgs.builder()        \n            .databaseName(\"EXAMPLE_DB_NAME\")\n            .enableMultipleGrants(true)\n            .maskingPolicyName(\"EXAMPLE_MASKING_POLICY_NAME\")\n            .privilege(\"APPLY\")\n            .roles(            \n                \"ROLE1_NAME\",\n                \"ROLE2_NAME\")\n            .schemaName(\"EXAMPLE_SCHEMA_NAME\")\n            .withGrantOption(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: snowflake:MaskingPolicyGrant\n    properties:\n      databaseName: EXAMPLE_DB_NAME\n      enableMultipleGrants: true\n      maskingPolicyName: EXAMPLE_MASKING_POLICY_NAME\n      privilege: APPLY\n      roles:\n        - ROLE1_NAME\n        - ROLE2_NAME\n      schemaName: EXAMPLE_SCHEMA_NAME\n      withGrantOption: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|masking_policy_name|privilege|with_grant_option|roles\n\n```sh\n $ pulumi import snowflake:index/maskingPolicyGrant:MaskingPolicyGrant example \"dbName|schemaName|maskingPolicyName|USAGE|false|role1,role2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the masking policy on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "maskingPolicyName": {
                    "type": "string",
                    "description": "The name of the masking policy on which to grant privileges immediately.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the masking policy. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the masking policy on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "maskingPolicyName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the masking policy on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "maskingPolicyName": {
                    "type": "string",
                    "description": "The name of the masking policy on which to grant privileges immediately.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the masking policy. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the masking policy on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "maskingPolicyName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaskingPolicyGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the masking policy on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "maskingPolicyName": {
                        "type": "string",
                        "description": "The name of the masking policy on which to grant privileges immediately.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the masking policy. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the masking policy on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/materializedView:MaterializedView": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst view = new snowflake.MaterializedView(\"view\", {\n    database: \"db\",\n    schema: \"schema\",\n    warehouse: \"warehouse\",\n    comment: \"comment\",\n    statement: \"select * from foo;\\n\",\n    orReplace: false,\n    isSecure: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nview = snowflake.MaterializedView(\"view\",\n    database=\"db\",\n    schema=\"schema\",\n    warehouse=\"warehouse\",\n    comment=\"comment\",\n    statement=\"select * from foo;\\n\",\n    or_replace=False,\n    is_secure=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var view = new Snowflake.MaterializedView(\"view\", new()\n    {\n        Database = \"db\",\n        Schema = \"schema\",\n        Warehouse = \"warehouse\",\n        Comment = \"comment\",\n        Statement = @\"select * from foo;\n\",\n        OrReplace = false,\n        IsSecure = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewMaterializedView(ctx, \"view\", \u0026snowflake.MaterializedViewArgs{\n\t\t\tDatabase:  pulumi.String(\"db\"),\n\t\t\tSchema:    pulumi.String(\"schema\"),\n\t\t\tWarehouse: pulumi.String(\"warehouse\"),\n\t\t\tComment:   pulumi.String(\"comment\"),\n\t\t\tStatement: pulumi.String(\"select * from foo;\\n\"),\n\t\t\tOrReplace: pulumi.Bool(false),\n\t\t\tIsSecure:  pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.MaterializedView;\nimport com.pulumi.snowflake.MaterializedViewArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var view = new MaterializedView(\"view\", MaterializedViewArgs.builder()        \n            .database(\"db\")\n            .schema(\"schema\")\n            .warehouse(\"warehouse\")\n            .comment(\"comment\")\n            .statement(\"\"\"\nselect * from foo;\n            \"\"\")\n            .orReplace(false)\n            .isSecure(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  view:\n    type: snowflake:MaterializedView\n    properties:\n      database: db\n      schema: schema\n      warehouse: warehouse\n      comment: comment\n      statement: |\n        select * from foo;\n      orReplace: false\n      isSecure: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | view name\n\n```sh\n $ pulumi import snowflake:index/materializedView:MaterializedView example 'dbName|schemaName|viewName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the view.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the view is secure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Overwrites the View if it exists.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the query used to create the view.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/MaterializedViewTag:MaterializedViewTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse name.\n"
                }
            },
            "required": [
                "database",
                "name",
                "schema",
                "statement",
                "warehouse"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the view.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the view is secure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Overwrites the View if it exists.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the query used to create the view.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/MaterializedViewTag:MaterializedViewTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse name.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "schema",
                "statement",
                "warehouse"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaterializedView resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the view.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "isSecure": {
                        "type": "boolean",
                        "description": "Specifies that the view is secure.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Tag name, e.g. department.\n"
                    },
                    "orReplace": {
                        "type": "boolean",
                        "description": "Overwrites the View if it exists.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "Name of the schema that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "statement": {
                        "type": "string",
                        "description": "Specifies the query used to create the view.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/MaterializedViewTag:MaterializedViewTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n",
                        "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                    },
                    "warehouse": {
                        "type": "string",
                        "description": "The warehouse name.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/materializedViewGrant:MaterializedViewGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.MaterializedViewGrant(\"grant\", {\n    databaseName: \"database\",\n    materializedViewName: \"materialized_view\",\n    onFuture: false,\n    privilege: \"SELECT\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.MaterializedViewGrant(\"grant\",\n    database_name=\"database\",\n    materialized_view_name=\"materialized_view\",\n    on_future=False,\n    privilege=\"SELECT\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.MaterializedViewGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        MaterializedViewName = \"materialized_view\",\n        OnFuture = false,\n        Privilege = \"SELECT\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        Shares = new[]\n        {\n            \"share1\",\n            \"share2\",\n        },\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewMaterializedViewGrant(ctx, \"grant\", \u0026snowflake.MaterializedViewGrantArgs{\n\t\t\tDatabaseName:         pulumi.String(\"database\"),\n\t\t\tMaterializedViewName: pulumi.String(\"materialized_view\"),\n\t\t\tOnFuture:             pulumi.Bool(false),\n\t\t\tPrivilege:            pulumi.String(\"SELECT\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.MaterializedViewGrant;\nimport com.pulumi.snowflake.MaterializedViewGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new MaterializedViewGrant(\"grant\", MaterializedViewGrantArgs.builder()        \n            .databaseName(\"database\")\n            .materializedViewName(\"materialized_view\")\n            .onFuture(false)\n            .privilege(\"SELECT\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:MaterializedViewGrant\n    properties:\n      databaseName: database\n      materializedViewName: materialized_view\n      onFuture: false\n      privilege: SELECT\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|materialized_view_name|privilege|with_grant_option|on_future|on_all|roles|shares\n\n```sh\n $ pulumi import snowflake:index/materializedViewGrant:MaterializedViewGrant example \"MY_DATABASE|MY_SCHEMA|MY_MV_NAME|SELECT|false|false|role1,role2|share1,share2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future materialized views on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "materializedViewName": {
                    "type": "string",
                    "description": "The name of the materialized view on which to grant privileges immediately (only valid if on*future and on*all are false).\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all materialized views in the given schema. When this is true and no schema*name is provided apply this grant on all materialized views in the given database. The materialized*view*name and shares fields must be unset in order to use on*all. Cannot be used together with on*future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future materialized views in the given schema. When this is true and no schema*name is provided apply this grant on all future materialized views in the given database. The materialized*view*name and shares fields must be unset in order to use on*future. Cannot be used together with on*all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future materialized view. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future materialized views on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on*future and on*all are false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future materialized views on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "materializedViewName": {
                    "type": "string",
                    "description": "The name of the materialized view on which to grant privileges immediately (only valid if on*future and on*all are false).\n",
                    "willReplaceOnChanges": true
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all materialized views in the given schema. When this is true and no schema*name is provided apply this grant on all materialized views in the given database. The materialized*view*name and shares fields must be unset in order to use on*all. Cannot be used together with on*future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future materialized views in the given schema. When this is true and no schema*name is provided apply this grant on all future materialized views in the given database. The materialized*view*name and shares fields must be unset in order to use on*future. Cannot be used together with on*all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future materialized view. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future materialized views on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on*future and on*all are false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaterializedViewGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future materialized views on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "materializedViewName": {
                        "type": "string",
                        "description": "The name of the materialized view on which to grant privileges immediately (only valid if on*future and on*all are false).\n",
                        "willReplaceOnChanges": true
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all materialized views in the given schema. When this is true and no schema*name is provided apply this grant on all materialized views in the given database. The materialized*view*name and shares fields must be unset in order to use on*all. Cannot be used together with on*future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future materialized views in the given schema. When this is true and no schema*name is provided apply this grant on all future materialized views in the given database. The materialized*view*name and shares fields must be unset in order to use on*future. Cannot be used together with on*all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future materialized view. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future materialized views on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on*future and on*all are false).\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/networkPolicy:NetworkPolicy": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst policy = new snowflake.NetworkPolicy(\"policy\", {\n    allowedIpLists: [\"192.168.0.100/24\"],\n    blockedIpLists: [\"192.168.0.101\"],\n    comment: \"A policy.\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\npolicy = snowflake.NetworkPolicy(\"policy\",\n    allowed_ip_lists=[\"192.168.0.100/24\"],\n    blocked_ip_lists=[\"192.168.0.101\"],\n    comment=\"A policy.\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var policy = new Snowflake.NetworkPolicy(\"policy\", new()\n    {\n        AllowedIpLists = new[]\n        {\n            \"192.168.0.100/24\",\n        },\n        BlockedIpLists = new[]\n        {\n            \"192.168.0.101\",\n        },\n        Comment = \"A policy.\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewNetworkPolicy(ctx, \"policy\", \u0026snowflake.NetworkPolicyArgs{\n\t\t\tAllowedIpLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.168.0.100/24\"),\n\t\t\t},\n\t\t\tBlockedIpLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.168.0.101\"),\n\t\t\t},\n\t\t\tComment: pulumi.String(\"A policy.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.NetworkPolicy;\nimport com.pulumi.snowflake.NetworkPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var policy = new NetworkPolicy(\"policy\", NetworkPolicyArgs.builder()        \n            .allowedIpLists(\"192.168.0.100/24\")\n            .blockedIpLists(\"192.168.0.101\")\n            .comment(\"A policy.\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  policy:\n    type: snowflake:NetworkPolicy\n    properties:\n      allowedIpLists:\n        - 192.168.0.100/24\n      blockedIpLists:\n        - 192.168.0.101\n      comment: A policy.\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/networkPolicy:NetworkPolicy example policyname\n```\n\n ",
            "properties": {
                "allowedIpLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more IPv4 addresses (CIDR notation) that are allowed access to your Snowflake account\n"
                },
                "blockedIpLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more IPv4 addresses (CIDR notation) that are denied access to your Snowflake account\\n\\n\\n\\n**Do not** add `0.0.0.0/0` to `blocked_ip_list`\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the network policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n"
                }
            },
            "required": [
                "allowedIpLists",
                "name"
            ],
            "inputProperties": {
                "allowedIpLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more IPv4 addresses (CIDR notation) that are allowed access to your Snowflake account\n"
                },
                "blockedIpLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more IPv4 addresses (CIDR notation) that are denied access to your Snowflake account\\n\\n\\n\\n**Do not** add `0.0.0.0/0` to `blocked_ip_list`\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the network policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "allowedIpLists"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkPolicy resources.\n",
                "properties": {
                    "allowedIpLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies one or more IPv4 addresses (CIDR notation) that are allowed access to your Snowflake account\n"
                    },
                    "blockedIpLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies one or more IPv4 addresses (CIDR notation) that are denied access to your Snowflake account\\n\\n\\n\\n**Do not** add `0.0.0.0/0` to `blocked_ip_list`\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the network policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/networkPolicyAttachment:NetworkPolicyAttachment": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst attach = new snowflake.NetworkPolicyAttachment(\"attach\", {\n    networkPolicyName: \"policy\",\n    setForAccount: false,\n    users: [\n        \"user1\",\n        \"user2\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nattach = snowflake.NetworkPolicyAttachment(\"attach\",\n    network_policy_name=\"policy\",\n    set_for_account=False,\n    users=[\n        \"user1\",\n        \"user2\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attach = new Snowflake.NetworkPolicyAttachment(\"attach\", new()\n    {\n        NetworkPolicyName = \"policy\",\n        SetForAccount = false,\n        Users = new[]\n        {\n            \"user1\",\n            \"user2\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewNetworkPolicyAttachment(ctx, \"attach\", \u0026snowflake.NetworkPolicyAttachmentArgs{\n\t\t\tNetworkPolicyName: pulumi.String(\"policy\"),\n\t\t\tSetForAccount:     pulumi.Bool(false),\n\t\t\tUsers: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user1\"),\n\t\t\t\tpulumi.String(\"user2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.NetworkPolicyAttachment;\nimport com.pulumi.snowflake.NetworkPolicyAttachmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var attach = new NetworkPolicyAttachment(\"attach\", NetworkPolicyAttachmentArgs.builder()        \n            .networkPolicyName(\"policy\")\n            .setForAccount(false)\n            .users(            \n                \"user1\",\n                \"user2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attach:\n    type: snowflake:NetworkPolicyAttachment\n    properties:\n      networkPolicyName: policy\n      setForAccount: false\n      users:\n        - user1\n        - user2\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/networkPolicyAttachment:NetworkPolicyAttachment example attachment_policyname\n```\n\n ",
            "properties": {
                "networkPolicyName": {
                    "type": "string",
                    "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n"
                },
                "setForAccount": {
                    "type": "boolean",
                    "description": "Specifies whether the network policy should be applied globally to your Snowflake account\\n\\n\\n\\n**Note:** The Snowflake user running `pulumi up` must be on an IP address allowed by the network policy to set that policy globally on the Snowflake account.\\n\\n\\n\\nAdditionally, a Snowflake account can only have one network policy set globally at any given time. This resource does not enforce one-policy-per-account, it is the user's responsibility to enforce this. If multiple network policy resources have `set_for_account: true`, the final policy set on the account will be non-deterministic.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies which users the network policy should be attached to\n"
                }
            },
            "required": [
                "networkPolicyName"
            ],
            "inputProperties": {
                "networkPolicyName": {
                    "type": "string",
                    "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n",
                    "willReplaceOnChanges": true
                },
                "setForAccount": {
                    "type": "boolean",
                    "description": "Specifies whether the network policy should be applied globally to your Snowflake account\\n\\n\\n\\n**Note:** The Snowflake user running `pulumi up` must be on an IP address allowed by the network policy to set that policy globally on the Snowflake account.\\n\\n\\n\\nAdditionally, a Snowflake account can only have one network policy set globally at any given time. This resource does not enforce one-policy-per-account, it is the user's responsibility to enforce this. If multiple network policy resources have `set_for_account: true`, the final policy set on the account will be non-deterministic.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies which users the network policy should be attached to\n"
                }
            },
            "requiredInputs": [
                "networkPolicyName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkPolicyAttachment resources.\n",
                "properties": {
                    "networkPolicyName": {
                        "type": "string",
                        "description": "Specifies the identifier for the network policy; must be unique for the account in which the network policy is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "setForAccount": {
                        "type": "boolean",
                        "description": "Specifies whether the network policy should be applied globally to your Snowflake account\\n\\n\\n\\n**Note:** The Snowflake user running `pulumi up` must be on an IP address allowed by the network policy to set that policy globally on the Snowflake account.\\n\\n\\n\\nAdditionally, a Snowflake account can only have one network policy set globally at any given time. This resource does not enforce one-policy-per-account, it is the user's responsibility to enforce this. If multiple network policy resources have `set_for_account: true`, the final policy set on the account will be non-deterministic.\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies which users the network policy should be attached to\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/notificationIntegration:NotificationIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst integration = new snowflake.NotificationIntegration(\"integration\", {\n    azureStorageQueuePrimaryUri: \"...\",\n    azureTenantId: \"...\",\n    comment: \"A notification integration.\",\n    direction: \"OUTBOUND\",\n    enabled: true,\n    notificationProvider: \"AZURE_STORAGE_QUEUE\",\n    type: \"QUEUE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nintegration = snowflake.NotificationIntegration(\"integration\",\n    azure_storage_queue_primary_uri=\"...\",\n    azure_tenant_id=\"...\",\n    comment=\"A notification integration.\",\n    direction=\"OUTBOUND\",\n    enabled=True,\n    notification_provider=\"AZURE_STORAGE_QUEUE\",\n    type=\"QUEUE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var integration = new Snowflake.NotificationIntegration(\"integration\", new()\n    {\n        AzureStorageQueuePrimaryUri = \"...\",\n        AzureTenantId = \"...\",\n        Comment = \"A notification integration.\",\n        Direction = \"OUTBOUND\",\n        Enabled = true,\n        NotificationProvider = \"AZURE_STORAGE_QUEUE\",\n        Type = \"QUEUE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewNotificationIntegration(ctx, \"integration\", \u0026snowflake.NotificationIntegrationArgs{\n\t\t\tAzureStorageQueuePrimaryUri: pulumi.String(\"...\"),\n\t\t\tAzureTenantId:               pulumi.String(\"...\"),\n\t\t\tComment:                     pulumi.String(\"A notification integration.\"),\n\t\t\tDirection:                   pulumi.String(\"OUTBOUND\"),\n\t\t\tEnabled:                     pulumi.Bool(true),\n\t\t\tNotificationProvider:        pulumi.String(\"AZURE_STORAGE_QUEUE\"),\n\t\t\tType:                        pulumi.String(\"QUEUE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.NotificationIntegration;\nimport com.pulumi.snowflake.NotificationIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var integration = new NotificationIntegration(\"integration\", NotificationIntegrationArgs.builder()        \n            .azureStorageQueuePrimaryUri(\"...\")\n            .azureTenantId(\"...\")\n            .comment(\"A notification integration.\")\n            .direction(\"OUTBOUND\")\n            .enabled(true)\n            .notificationProvider(\"AZURE_STORAGE_QUEUE\")\n            .type(\"QUEUE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  integration:\n    type: snowflake:NotificationIntegration\n    properties:\n      azureStorageQueuePrimaryUri: '...'\n      azureTenantId: '...'\n      comment: A notification integration.\n      direction: OUTBOUND\n      enabled: true\n      # AZURE_STORAGE_QUEUE\n      notificationProvider: AZURE_STORAGE_QUEUE\n      type: QUEUE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/notificationIntegration:NotificationIntegration example name\n```\n\n ",
            "properties": {
                "awsSnsExternalId": {
                    "type": "string",
                    "description": "The external ID that Snowflake will use when assuming the AWS role\n"
                },
                "awsSnsIamUserArn": {
                    "type": "string",
                    "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                },
                "awsSnsRoleArn": {
                    "type": "string",
                    "description": "AWS IAM role ARN for notification integration to assume\n"
                },
                "awsSnsTopicArn": {
                    "type": "string",
                    "description": "AWS SNS Topic ARN for notification integration to connect to\n"
                },
                "awsSqsArn": {
                    "type": "string",
                    "description": "AWS SQS queue ARN for notification integration to connect to\n"
                },
                "awsSqsExternalId": {
                    "type": "string",
                    "description": "The external ID that Snowflake will use when assuming the AWS role\n"
                },
                "awsSqsIamUserArn": {
                    "type": "string",
                    "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                },
                "awsSqsRoleArn": {
                    "type": "string",
                    "description": "AWS IAM role ARN for notification integration to assume\n"
                },
                "azureStorageQueuePrimaryUri": {
                    "type": "string",
                    "description": "The queue ID for the Azure Queue Storage queue created for Event Grid notifications\n"
                },
                "azureTenantId": {
                    "type": "string",
                    "description": "The ID of the Azure Active Directory tenant used for identity management\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A comment for the integration\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the notification integration was created.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction of the cloud messaging with respect to Snowflake (required only for error notifications)\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "gcpPubsubServiceAccount": {
                    "type": "string",
                    "description": "The GCP service account identifier that Snowflake will use when assuming the GCP role\n"
                },
                "gcpPubsubSubscriptionName": {
                    "type": "string",
                    "description": "The subscription id that Snowflake will listen to when using the GCP_PUBSUB provider.\n"
                },
                "gcpPubsubTopicName": {
                    "type": "string",
                    "description": "The topic id that Snowflake will use to push notifications.\n"
                },
                "name": {
                    "type": "string"
                },
                "notificationProvider": {
                    "type": "string",
                    "description": "The third-party cloud message queuing service (e.g. AZURE*STORAGE*QUEUE, AWS*SQS, AWS*SNS)\n"
                },
                "type": {
                    "type": "string",
                    "description": "A type of integration\n"
                }
            },
            "required": [
                "awsSnsExternalId",
                "awsSnsIamUserArn",
                "awsSqsExternalId",
                "awsSqsIamUserArn",
                "createdOn",
                "gcpPubsubServiceAccount",
                "name"
            ],
            "inputProperties": {
                "awsSnsRoleArn": {
                    "type": "string",
                    "description": "AWS IAM role ARN for notification integration to assume\n"
                },
                "awsSnsTopicArn": {
                    "type": "string",
                    "description": "AWS SNS Topic ARN for notification integration to connect to\n"
                },
                "awsSqsArn": {
                    "type": "string",
                    "description": "AWS SQS queue ARN for notification integration to connect to\n"
                },
                "awsSqsRoleArn": {
                    "type": "string",
                    "description": "AWS IAM role ARN for notification integration to assume\n"
                },
                "azureStorageQueuePrimaryUri": {
                    "type": "string",
                    "description": "The queue ID for the Azure Queue Storage queue created for Event Grid notifications\n"
                },
                "azureTenantId": {
                    "type": "string",
                    "description": "The ID of the Azure Active Directory tenant used for identity management\n"
                },
                "comment": {
                    "type": "string",
                    "description": "A comment for the integration\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction of the cloud messaging with respect to Snowflake (required only for error notifications)\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean"
                },
                "gcpPubsubSubscriptionName": {
                    "type": "string",
                    "description": "The subscription id that Snowflake will listen to when using the GCP_PUBSUB provider.\n"
                },
                "gcpPubsubTopicName": {
                    "type": "string",
                    "description": "The topic id that Snowflake will use to push notifications.\n"
                },
                "name": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "notificationProvider": {
                    "type": "string",
                    "description": "The third-party cloud message queuing service (e.g. AZURE*STORAGE*QUEUE, AWS*SQS, AWS*SNS)\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "A type of integration\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NotificationIntegration resources.\n",
                "properties": {
                    "awsSnsExternalId": {
                        "type": "string",
                        "description": "The external ID that Snowflake will use when assuming the AWS role\n"
                    },
                    "awsSnsIamUserArn": {
                        "type": "string",
                        "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                    },
                    "awsSnsRoleArn": {
                        "type": "string",
                        "description": "AWS IAM role ARN for notification integration to assume\n"
                    },
                    "awsSnsTopicArn": {
                        "type": "string",
                        "description": "AWS SNS Topic ARN for notification integration to connect to\n"
                    },
                    "awsSqsArn": {
                        "type": "string",
                        "description": "AWS SQS queue ARN for notification integration to connect to\n"
                    },
                    "awsSqsExternalId": {
                        "type": "string",
                        "description": "The external ID that Snowflake will use when assuming the AWS role\n"
                    },
                    "awsSqsIamUserArn": {
                        "type": "string",
                        "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                    },
                    "awsSqsRoleArn": {
                        "type": "string",
                        "description": "AWS IAM role ARN for notification integration to assume\n"
                    },
                    "azureStorageQueuePrimaryUri": {
                        "type": "string",
                        "description": "The queue ID for the Azure Queue Storage queue created for Event Grid notifications\n"
                    },
                    "azureTenantId": {
                        "type": "string",
                        "description": "The ID of the Azure Active Directory tenant used for identity management\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "A comment for the integration\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the notification integration was created.\n"
                    },
                    "direction": {
                        "type": "string",
                        "description": "Direction of the cloud messaging with respect to Snowflake (required only for error notifications)\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "gcpPubsubServiceAccount": {
                        "type": "string",
                        "description": "The GCP service account identifier that Snowflake will use when assuming the GCP role\n"
                    },
                    "gcpPubsubSubscriptionName": {
                        "type": "string",
                        "description": "The subscription id that Snowflake will listen to when using the GCP_PUBSUB provider.\n"
                    },
                    "gcpPubsubTopicName": {
                        "type": "string",
                        "description": "The topic id that Snowflake will use to push notifications.\n"
                    },
                    "name": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "notificationProvider": {
                        "type": "string",
                        "description": "The third-party cloud message queuing service (e.g. AZURE*STORAGE*QUEUE, AWS*SQS, AWS*SNS)\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "A type of integration\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/oauthIntegration:OauthIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst tableauDesktop = new snowflake.OauthIntegration(\"tableauDesktop\", {\n    blockedRolesLists: [\"SYSADMIN\"],\n    enabled: true,\n    oauthClient: \"TABLEAU_DESKTOP\",\n    oauthIssueRefreshTokens: true,\n    oauthRefreshTokenValidity: 3600,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntableau_desktop = snowflake.OauthIntegration(\"tableauDesktop\",\n    blocked_roles_lists=[\"SYSADMIN\"],\n    enabled=True,\n    oauth_client=\"TABLEAU_DESKTOP\",\n    oauth_issue_refresh_tokens=True,\n    oauth_refresh_token_validity=3600)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tableauDesktop = new Snowflake.OauthIntegration(\"tableauDesktop\", new()\n    {\n        BlockedRolesLists = new[]\n        {\n            \"SYSADMIN\",\n        },\n        Enabled = true,\n        OauthClient = \"TABLEAU_DESKTOP\",\n        OauthIssueRefreshTokens = true,\n        OauthRefreshTokenValidity = 3600,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewOauthIntegration(ctx, \"tableauDesktop\", \u0026snowflake.OauthIntegrationArgs{\n\t\t\tBlockedRolesLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"SYSADMIN\"),\n\t\t\t},\n\t\t\tEnabled:                   pulumi.Bool(true),\n\t\t\tOauthClient:               pulumi.String(\"TABLEAU_DESKTOP\"),\n\t\t\tOauthIssueRefreshTokens:   pulumi.Bool(true),\n\t\t\tOauthRefreshTokenValidity: pulumi.Int(3600),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.OauthIntegration;\nimport com.pulumi.snowflake.OauthIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var tableauDesktop = new OauthIntegration(\"tableauDesktop\", OauthIntegrationArgs.builder()        \n            .blockedRolesLists(\"SYSADMIN\")\n            .enabled(true)\n            .oauthClient(\"TABLEAU_DESKTOP\")\n            .oauthIssueRefreshTokens(true)\n            .oauthRefreshTokenValidity(3600)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  tableauDesktop:\n    type: snowflake:OauthIntegration\n    properties:\n      blockedRolesLists:\n        - SYSADMIN\n      enabled: true\n      oauthClient: TABLEAU_DESKTOP\n      oauthIssueRefreshTokens: true\n      oauthRefreshTokenValidity: 3600\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/oauthIntegration:OauthIntegration example name\n```\n\n ",
            "properties": {
                "blockedRolesLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of roles that a user cannot explicitly consent to using after authenticating. Do not include ACCOUNTADMIN, ORGADMIN or SECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the OAuth integration.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the OAuth integration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this OAuth integration is enabled or disabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the OAuth integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n"
                },
                "oauthClient": {
                    "type": "string",
                    "description": "Specifies the OAuth client type.\n"
                },
                "oauthClientType": {
                    "type": "string",
                    "description": "Specifies the type of client being registered. Snowflake supports both confidential and public clients.\n"
                },
                "oauthIssueRefreshTokens": {
                    "type": "boolean",
                    "description": "Specifies whether to allow the client to exchange a refresh token for an access token when the current access token has expired.\n"
                },
                "oauthRedirectUri": {
                    "type": "string",
                    "description": "Specifies the client URI. After a user is authenticated, the web browser is redirected to this URI.\n"
                },
                "oauthRefreshTokenValidity": {
                    "type": "integer",
                    "description": "Specifies how long refresh tokens should be valid (in seconds). OAUTH*ISSUE*REFRESH_TOKENS must be set to TRUE.\n"
                },
                "oauthUseSecondaryRoles": {
                    "type": "string",
                    "description": "Specifies whether default secondary roles set in the user properties are activated by default in the session being opened.\n"
                }
            },
            "required": [
                "createdOn",
                "name",
                "oauthClient"
            ],
            "inputProperties": {
                "blockedRolesLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of roles that a user cannot explicitly consent to using after authenticating. Do not include ACCOUNTADMIN, ORGADMIN or SECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the OAuth integration.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this OAuth integration is enabled or disabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the OAuth integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n",
                    "willReplaceOnChanges": true
                },
                "oauthClient": {
                    "type": "string",
                    "description": "Specifies the OAuth client type.\n"
                },
                "oauthClientType": {
                    "type": "string",
                    "description": "Specifies the type of client being registered. Snowflake supports both confidential and public clients.\n"
                },
                "oauthIssueRefreshTokens": {
                    "type": "boolean",
                    "description": "Specifies whether to allow the client to exchange a refresh token for an access token when the current access token has expired.\n"
                },
                "oauthRedirectUri": {
                    "type": "string",
                    "description": "Specifies the client URI. After a user is authenticated, the web browser is redirected to this URI.\n"
                },
                "oauthRefreshTokenValidity": {
                    "type": "integer",
                    "description": "Specifies how long refresh tokens should be valid (in seconds). OAUTH*ISSUE*REFRESH_TOKENS must be set to TRUE.\n"
                },
                "oauthUseSecondaryRoles": {
                    "type": "string",
                    "description": "Specifies whether default secondary roles set in the user properties are activated by default in the session being opened.\n"
                }
            },
            "requiredInputs": [
                "oauthClient"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OauthIntegration resources.\n",
                "properties": {
                    "blockedRolesLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of roles that a user cannot explicitly consent to using after authenticating. Do not include ACCOUNTADMIN, ORGADMIN or SECURITYADMIN as they are already implicitly enforced and will cause in-place updates.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the OAuth integration.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the OAuth integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether this OAuth integration is enabled or disabled.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the OAuth integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "oauthClient": {
                        "type": "string",
                        "description": "Specifies the OAuth client type.\n"
                    },
                    "oauthClientType": {
                        "type": "string",
                        "description": "Specifies the type of client being registered. Snowflake supports both confidential and public clients.\n"
                    },
                    "oauthIssueRefreshTokens": {
                        "type": "boolean",
                        "description": "Specifies whether to allow the client to exchange a refresh token for an access token when the current access token has expired.\n"
                    },
                    "oauthRedirectUri": {
                        "type": "string",
                        "description": "Specifies the client URI. After a user is authenticated, the web browser is redirected to this URI.\n"
                    },
                    "oauthRefreshTokenValidity": {
                        "type": "integer",
                        "description": "Specifies how long refresh tokens should be valid (in seconds). OAUTH*ISSUE*REFRESH_TOKENS must be set to TRUE.\n"
                    },
                    "oauthUseSecondaryRoles": {
                        "type": "string",
                        "description": "Specifies whether default secondary roles set in the user properties are activated by default in the session being opened.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/objectParameter:ObjectParameter": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst database = new snowflake.Database(\"database\", {});\nconst objectParameter = new snowflake.ObjectParameter(\"objectParameter\", {\n    key: \"SUSPEND_TASK_AFTER_NUM_FAILURES\",\n    value: \"33\",\n    objectType: \"DATABASE\",\n    objectIdentifiers: [{\n        name: database.name,\n    }],\n});\nconst schema = new snowflake.Schema(\"schema\", {database: database.name});\nconst o2 = new snowflake.ObjectParameter(\"o2\", {\n    key: \"USER_TASK_TIMEOUT_MS\",\n    value: \"500\",\n    objectType: \"SCHEMA\",\n    objectIdentifiers: [{\n        database: database.name,\n        name: schema.name,\n    }],\n});\nconst table = new snowflake.Table(\"table\", {\n    database: database.name,\n    schema: schema.name,\n    columns: [{\n        name: \"id\",\n        type: \"NUMBER\",\n    }],\n});\nconst o3 = new snowflake.ObjectParameter(\"o3\", {\n    key: \"DATA_RETENTION_TIME_IN_DAYS\",\n    value: \"89\",\n    objectType: \"TABLE\",\n    objectIdentifiers: [{\n        database: database.name,\n        schema: schema.name,\n        name: table.name,\n    }],\n});\n// Setting object parameter at account level\nconst o4 = new snowflake.ObjectParameter(\"o4\", {\n    key: \"DATA_RETENTION_TIME_IN_DAYS\",\n    value: \"89\",\n    onAccount: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndatabase = snowflake.Database(\"database\")\nobject_parameter = snowflake.ObjectParameter(\"objectParameter\",\n    key=\"SUSPEND_TASK_AFTER_NUM_FAILURES\",\n    value=\"33\",\n    object_type=\"DATABASE\",\n    object_identifiers=[snowflake.ObjectParameterObjectIdentifierArgs(\n        name=database.name,\n    )])\nschema = snowflake.Schema(\"schema\", database=database.name)\no2 = snowflake.ObjectParameter(\"o2\",\n    key=\"USER_TASK_TIMEOUT_MS\",\n    value=\"500\",\n    object_type=\"SCHEMA\",\n    object_identifiers=[snowflake.ObjectParameterObjectIdentifierArgs(\n        database=database.name,\n        name=schema.name,\n    )])\ntable = snowflake.Table(\"table\",\n    database=database.name,\n    schema=schema.name,\n    columns=[snowflake.TableColumnArgs(\n        name=\"id\",\n        type=\"NUMBER\",\n    )])\no3 = snowflake.ObjectParameter(\"o3\",\n    key=\"DATA_RETENTION_TIME_IN_DAYS\",\n    value=\"89\",\n    object_type=\"TABLE\",\n    object_identifiers=[snowflake.ObjectParameterObjectIdentifierArgs(\n        database=database.name,\n        schema=schema.name,\n        name=table.name,\n    )])\n# Setting object parameter at account level\no4 = snowflake.ObjectParameter(\"o4\",\n    key=\"DATA_RETENTION_TIME_IN_DAYS\",\n    value=\"89\",\n    on_account=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var database = new Snowflake.Database(\"database\");\n\n    var objectParameter = new Snowflake.ObjectParameter(\"objectParameter\", new()\n    {\n        Key = \"SUSPEND_TASK_AFTER_NUM_FAILURES\",\n        Value = \"33\",\n        ObjectType = \"DATABASE\",\n        ObjectIdentifiers = new[]\n        {\n            new Snowflake.Inputs.ObjectParameterObjectIdentifierArgs\n            {\n                Name = database.Name,\n            },\n        },\n    });\n\n    var schema = new Snowflake.Schema(\"schema\", new()\n    {\n        Database = database.Name,\n    });\n\n    var o2 = new Snowflake.ObjectParameter(\"o2\", new()\n    {\n        Key = \"USER_TASK_TIMEOUT_MS\",\n        Value = \"500\",\n        ObjectType = \"SCHEMA\",\n        ObjectIdentifiers = new[]\n        {\n            new Snowflake.Inputs.ObjectParameterObjectIdentifierArgs\n            {\n                Database = database.Name,\n                Name = schema.Name,\n            },\n        },\n    });\n\n    var table = new Snowflake.Table(\"table\", new()\n    {\n        Database = database.Name,\n        Schema = schema.Name,\n        Columns = new[]\n        {\n            new Snowflake.Inputs.TableColumnArgs\n            {\n                Name = \"id\",\n                Type = \"NUMBER\",\n            },\n        },\n    });\n\n    var o3 = new Snowflake.ObjectParameter(\"o3\", new()\n    {\n        Key = \"DATA_RETENTION_TIME_IN_DAYS\",\n        Value = \"89\",\n        ObjectType = \"TABLE\",\n        ObjectIdentifiers = new[]\n        {\n            new Snowflake.Inputs.ObjectParameterObjectIdentifierArgs\n            {\n                Database = database.Name,\n                Schema = schema.Name,\n                Name = table.Name,\n            },\n        },\n    });\n\n    // Setting object parameter at account level\n    var o4 = new Snowflake.ObjectParameter(\"o4\", new()\n    {\n        Key = \"DATA_RETENTION_TIME_IN_DAYS\",\n        Value = \"89\",\n        OnAccount = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatabase, err := snowflake.NewDatabase(ctx, \"database\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewObjectParameter(ctx, \"objectParameter\", \u0026snowflake.ObjectParameterArgs{\n\t\t\tKey:        pulumi.String(\"SUSPEND_TASK_AFTER_NUM_FAILURES\"),\n\t\t\tValue:      pulumi.String(\"33\"),\n\t\t\tObjectType: pulumi.String(\"DATABASE\"),\n\t\t\tObjectIdentifiers: snowflake.ObjectParameterObjectIdentifierArray{\n\t\t\t\t\u0026snowflake.ObjectParameterObjectIdentifierArgs{\n\t\t\t\t\tName: database.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tschema, err := snowflake.NewSchema(ctx, \"schema\", \u0026snowflake.SchemaArgs{\n\t\t\tDatabase: database.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewObjectParameter(ctx, \"o2\", \u0026snowflake.ObjectParameterArgs{\n\t\t\tKey:        pulumi.String(\"USER_TASK_TIMEOUT_MS\"),\n\t\t\tValue:      pulumi.String(\"500\"),\n\t\t\tObjectType: pulumi.String(\"SCHEMA\"),\n\t\t\tObjectIdentifiers: snowflake.ObjectParameterObjectIdentifierArray{\n\t\t\t\t\u0026snowflake.ObjectParameterObjectIdentifierArgs{\n\t\t\t\t\tDatabase: database.Name,\n\t\t\t\t\tName:     schema.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttable, err := snowflake.NewTable(ctx, \"table\", \u0026snowflake.TableArgs{\n\t\t\tDatabase: database.Name,\n\t\t\tSchema:   schema.Name,\n\t\t\tColumns: snowflake.TableColumnArray{\n\t\t\t\t\u0026snowflake.TableColumnArgs{\n\t\t\t\t\tName: pulumi.String(\"id\"),\n\t\t\t\t\tType: pulumi.String(\"NUMBER\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewObjectParameter(ctx, \"o3\", \u0026snowflake.ObjectParameterArgs{\n\t\t\tKey:        pulumi.String(\"DATA_RETENTION_TIME_IN_DAYS\"),\n\t\t\tValue:      pulumi.String(\"89\"),\n\t\t\tObjectType: pulumi.String(\"TABLE\"),\n\t\t\tObjectIdentifiers: snowflake.ObjectParameterObjectIdentifierArray{\n\t\t\t\t\u0026snowflake.ObjectParameterObjectIdentifierArgs{\n\t\t\t\t\tDatabase: database.Name,\n\t\t\t\t\tSchema:   schema.Name,\n\t\t\t\t\tName:     table.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewObjectParameter(ctx, \"o4\", \u0026snowflake.ObjectParameterArgs{\n\t\t\tKey:       pulumi.String(\"DATA_RETENTION_TIME_IN_DAYS\"),\n\t\t\tValue:     pulumi.String(\"89\"),\n\t\t\tOnAccount: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.ObjectParameter;\nimport com.pulumi.snowflake.ObjectParameterArgs;\nimport com.pulumi.snowflake.inputs.ObjectParameterObjectIdentifierArgs;\nimport com.pulumi.snowflake.Schema;\nimport com.pulumi.snowflake.SchemaArgs;\nimport com.pulumi.snowflake.Table;\nimport com.pulumi.snowflake.TableArgs;\nimport com.pulumi.snowflake.inputs.TableColumnArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var database = new Database(\"database\");\n\n        var objectParameter = new ObjectParameter(\"objectParameter\", ObjectParameterArgs.builder()        \n            .key(\"SUSPEND_TASK_AFTER_NUM_FAILURES\")\n            .value(\"33\")\n            .objectType(\"DATABASE\")\n            .objectIdentifiers(ObjectParameterObjectIdentifierArgs.builder()\n                .name(database.name())\n                .build())\n            .build());\n\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .database(database.name())\n            .build());\n\n        var o2 = new ObjectParameter(\"o2\", ObjectParameterArgs.builder()        \n            .key(\"USER_TASK_TIMEOUT_MS\")\n            .value(\"500\")\n            .objectType(\"SCHEMA\")\n            .objectIdentifiers(ObjectParameterObjectIdentifierArgs.builder()\n                .database(database.name())\n                .name(schema.name())\n                .build())\n            .build());\n\n        var table = new Table(\"table\", TableArgs.builder()        \n            .database(database.name())\n            .schema(schema.name())\n            .columns(TableColumnArgs.builder()\n                .name(\"id\")\n                .type(\"NUMBER\")\n                .build())\n            .build());\n\n        var o3 = new ObjectParameter(\"o3\", ObjectParameterArgs.builder()        \n            .key(\"DATA_RETENTION_TIME_IN_DAYS\")\n            .value(\"89\")\n            .objectType(\"TABLE\")\n            .objectIdentifiers(ObjectParameterObjectIdentifierArgs.builder()\n                .database(database.name())\n                .schema(schema.name())\n                .name(table.name())\n                .build())\n            .build());\n\n        var o4 = new ObjectParameter(\"o4\", ObjectParameterArgs.builder()        \n            .key(\"DATA_RETENTION_TIME_IN_DAYS\")\n            .value(\"89\")\n            .onAccount(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  database:\n    type: snowflake:Database\n  objectParameter:\n    type: snowflake:ObjectParameter\n    properties:\n      key: SUSPEND_TASK_AFTER_NUM_FAILURES\n      value: '33'\n      objectType: DATABASE\n      objectIdentifiers:\n        - name: ${database.name}\n  schema:\n    type: snowflake:Schema\n    properties:\n      database: ${database.name}\n  o2:\n    type: snowflake:ObjectParameter\n    properties:\n      key: USER_TASK_TIMEOUT_MS\n      value: '500'\n      objectType: SCHEMA\n      objectIdentifiers:\n        - database: ${database.name}\n          name: ${schema.name}\n  table:\n    type: snowflake:Table\n    properties:\n      database: ${database.name}\n      schema: ${schema.name}\n      columns:\n        - name: id\n          type: NUMBER\n  o3:\n    type: snowflake:ObjectParameter\n    properties:\n      key: DATA_RETENTION_TIME_IN_DAYS\n      value: '89'\n      objectType: TABLE\n      objectIdentifiers:\n        - database: ${database.name}\n          schema: ${schema.name}\n          name: ${table.name}\n  # Setting object parameter at account level\n  o4:\n    type: snowflake:ObjectParameter\n    properties:\n      key: DATA_RETENTION_TIME_IN_DAYS\n      value: '89'\n      onAccount: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/objectParameter:ObjectParameter s \u003ckey\u003e❄️\u003cobject_type\u003e❄️\u003cobject_identifier\u003e\n```\n\n ",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Name of object parameter. Valid values are those in [object parameters](https://docs.snowflake.com/en/sql-reference/parameters.html#object-parameters).\n"
                },
                "objectIdentifiers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ObjectParameterObjectIdentifier:ObjectParameterObjectIdentifier"
                    },
                    "description": "Specifies the object identifier for the object parameter. If no value is provided, then the resource will default to setting the object parameter at account level.\n"
                },
                "objectType": {
                    "type": "string",
                    "description": "Type of object to which the parameter applies. Valid values are those in [object types](https://docs.snowflake.com/en/sql-reference/parameters.html#object-types). If no value is provided, then the resource will default to setting the object parameter at account level.\n"
                },
                "onAccount": {
                    "type": "boolean",
                    "description": "If true, the object parameter will be set on the account level.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of object parameter, as a string. Constraints are the same as those for the parameters in Snowflake documentation.\n"
                }
            },
            "required": [
                "key",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "Name of object parameter. Valid values are those in [object parameters](https://docs.snowflake.com/en/sql-reference/parameters.html#object-parameters).\n",
                    "willReplaceOnChanges": true
                },
                "objectIdentifiers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ObjectParameterObjectIdentifier:ObjectParameterObjectIdentifier"
                    },
                    "description": "Specifies the object identifier for the object parameter. If no value is provided, then the resource will default to setting the object parameter at account level.\n"
                },
                "objectType": {
                    "type": "string",
                    "description": "Type of object to which the parameter applies. Valid values are those in [object types](https://docs.snowflake.com/en/sql-reference/parameters.html#object-types). If no value is provided, then the resource will default to setting the object parameter at account level.\n",
                    "willReplaceOnChanges": true
                },
                "onAccount": {
                    "type": "boolean",
                    "description": "If true, the object parameter will be set on the account level.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of object parameter, as a string. Constraints are the same as those for the parameters in Snowflake documentation.\n"
                }
            },
            "requiredInputs": [
                "key",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ObjectParameter resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Name of object parameter. Valid values are those in [object parameters](https://docs.snowflake.com/en/sql-reference/parameters.html#object-parameters).\n",
                        "willReplaceOnChanges": true
                    },
                    "objectIdentifiers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ObjectParameterObjectIdentifier:ObjectParameterObjectIdentifier"
                        },
                        "description": "Specifies the object identifier for the object parameter. If no value is provided, then the resource will default to setting the object parameter at account level.\n"
                    },
                    "objectType": {
                        "type": "string",
                        "description": "Type of object to which the parameter applies. Valid values are those in [object types](https://docs.snowflake.com/en/sql-reference/parameters.html#object-types). If no value is provided, then the resource will default to setting the object parameter at account level.\n",
                        "willReplaceOnChanges": true
                    },
                    "onAccount": {
                        "type": "boolean",
                        "description": "If true, the object parameter will be set on the account level.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "Value of object parameter, as a string. Constraints are the same as those for the parameters in Snowflake documentation.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/passwordPolicy:PasswordPolicy": {
            "description": "A password policy specifies the requirements that must be met to create and reset a password to authenticate to Snowflake.\n",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Adds a comment or overwrites an existing comment for the password policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database this password policy belongs to.\n"
                },
                "history": {
                    "type": "integer",
                    "description": "Specifies the number of the most recent passwords that Snowflake stores. These stored passwords cannot be repeated when a user updates their password value. The current password value does not count towards the history. When you increase the history value, Snowflake saves the previous values. When you decrease the value, Snowflake saves the stored values up to that value that is set. For example, if the history value is 8 and you change the history value to 3, Snowflake stores the most recent 3 passwords and deletes the 5 older password values from the history. Default: 0 Max: 24\n"
                },
                "ifNotExists": {
                    "type": "boolean",
                    "description": "Prevent overwriting a previous password policy with the same name.\n"
                },
                "lockoutTimeMins": {
                    "type": "integer",
                    "description": "Specifies the number of minutes the user account will be locked after exhausting the designated number of password retries (i.e. PASSWORD*MAX*RETRIES). Supported range: 1 to 999, inclusive. Default: 15\n"
                },
                "maxAgeDays": {
                    "type": "integer",
                    "description": "Specifies the maximum number of days before the password must be changed. Supported range: 0 to 999, inclusive. A value of zero (i.e. 0) indicates that the password does not need to be changed. Snowflake does not recommend choosing this value for a default account-level password policy or for any user-level policy. Instead, choose a value that meets your internal security guidelines. Default: 90, which means the password must be changed every 90 days.\n"
                },
                "maxLength": {
                    "type": "integer",
                    "description": "Specifies the maximum number of characters the password must contain. This number must be greater than or equal to the sum of PASSWORD*MIN*LENGTH, PASSWORD*MIN*UPPER*CASE*CHARS, and PASSWORD*MIN*LOWER*CASE*CHARS. Supported range: 8 to 256, inclusive. Default: 256\n"
                },
                "maxRetries": {
                    "type": "integer",
                    "description": "Specifies the maximum number of attempts to enter a password before being locked out. Supported range: 1 to 10, inclusive. Default: 5\n"
                },
                "minAgeDays": {
                    "type": "integer",
                    "description": "Specifies the number of days the user must wait before a recently changed password can be changed again. Supported range: 0 to 999, inclusive. Default: 0\n"
                },
                "minLength": {
                    "type": "integer",
                    "description": "Specifies the minimum number of characters the password must contain. Supported range: 8 to 256, inclusive. Default: 8\n"
                },
                "minLowerCaseChars": {
                    "type": "integer",
                    "description": "Specifies the minimum number of lowercase characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                },
                "minNumericChars": {
                    "type": "integer",
                    "description": "Specifies the minimum number of numeric characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                },
                "minSpecialChars": {
                    "type": "integer",
                    "description": "Specifies the minimum number of special characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                },
                "minUpperCaseChars": {
                    "type": "integer",
                    "description": "Specifies the minimum number of uppercase characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the password policy; must be unique for your account.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Whether to override a previous password policy with the same name.\n"
                },
                "qualifiedName": {
                    "type": "string",
                    "description": "The qualified name for the password policy.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema this password policy belongs to.\n"
                }
            },
            "required": [
                "database",
                "name",
                "qualifiedName",
                "schema"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Adds a comment or overwrites an existing comment for the password policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database this password policy belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "history": {
                    "type": "integer",
                    "description": "Specifies the number of the most recent passwords that Snowflake stores. These stored passwords cannot be repeated when a user updates their password value. The current password value does not count towards the history. When you increase the history value, Snowflake saves the previous values. When you decrease the value, Snowflake saves the stored values up to that value that is set. For example, if the history value is 8 and you change the history value to 3, Snowflake stores the most recent 3 passwords and deletes the 5 older password values from the history. Default: 0 Max: 24\n"
                },
                "ifNotExists": {
                    "type": "boolean",
                    "description": "Prevent overwriting a previous password policy with the same name.\n"
                },
                "lockoutTimeMins": {
                    "type": "integer",
                    "description": "Specifies the number of minutes the user account will be locked after exhausting the designated number of password retries (i.e. PASSWORD*MAX*RETRIES). Supported range: 1 to 999, inclusive. Default: 15\n"
                },
                "maxAgeDays": {
                    "type": "integer",
                    "description": "Specifies the maximum number of days before the password must be changed. Supported range: 0 to 999, inclusive. A value of zero (i.e. 0) indicates that the password does not need to be changed. Snowflake does not recommend choosing this value for a default account-level password policy or for any user-level policy. Instead, choose a value that meets your internal security guidelines. Default: 90, which means the password must be changed every 90 days.\n"
                },
                "maxLength": {
                    "type": "integer",
                    "description": "Specifies the maximum number of characters the password must contain. This number must be greater than or equal to the sum of PASSWORD*MIN*LENGTH, PASSWORD*MIN*UPPER*CASE*CHARS, and PASSWORD*MIN*LOWER*CASE*CHARS. Supported range: 8 to 256, inclusive. Default: 256\n"
                },
                "maxRetries": {
                    "type": "integer",
                    "description": "Specifies the maximum number of attempts to enter a password before being locked out. Supported range: 1 to 10, inclusive. Default: 5\n"
                },
                "minAgeDays": {
                    "type": "integer",
                    "description": "Specifies the number of days the user must wait before a recently changed password can be changed again. Supported range: 0 to 999, inclusive. Default: 0\n"
                },
                "minLength": {
                    "type": "integer",
                    "description": "Specifies the minimum number of characters the password must contain. Supported range: 8 to 256, inclusive. Default: 8\n"
                },
                "minLowerCaseChars": {
                    "type": "integer",
                    "description": "Specifies the minimum number of lowercase characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                },
                "minNumericChars": {
                    "type": "integer",
                    "description": "Specifies the minimum number of numeric characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                },
                "minSpecialChars": {
                    "type": "integer",
                    "description": "Specifies the minimum number of special characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                },
                "minUpperCaseChars": {
                    "type": "integer",
                    "description": "Specifies the minimum number of uppercase characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the password policy; must be unique for your account.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Whether to override a previous password policy with the same name.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema this password policy belongs to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PasswordPolicy resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Adds a comment or overwrites an existing comment for the password policy.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database this password policy belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "history": {
                        "type": "integer",
                        "description": "Specifies the number of the most recent passwords that Snowflake stores. These stored passwords cannot be repeated when a user updates their password value. The current password value does not count towards the history. When you increase the history value, Snowflake saves the previous values. When you decrease the value, Snowflake saves the stored values up to that value that is set. For example, if the history value is 8 and you change the history value to 3, Snowflake stores the most recent 3 passwords and deletes the 5 older password values from the history. Default: 0 Max: 24\n"
                    },
                    "ifNotExists": {
                        "type": "boolean",
                        "description": "Prevent overwriting a previous password policy with the same name.\n"
                    },
                    "lockoutTimeMins": {
                        "type": "integer",
                        "description": "Specifies the number of minutes the user account will be locked after exhausting the designated number of password retries (i.e. PASSWORD*MAX*RETRIES). Supported range: 1 to 999, inclusive. Default: 15\n"
                    },
                    "maxAgeDays": {
                        "type": "integer",
                        "description": "Specifies the maximum number of days before the password must be changed. Supported range: 0 to 999, inclusive. A value of zero (i.e. 0) indicates that the password does not need to be changed. Snowflake does not recommend choosing this value for a default account-level password policy or for any user-level policy. Instead, choose a value that meets your internal security guidelines. Default: 90, which means the password must be changed every 90 days.\n"
                    },
                    "maxLength": {
                        "type": "integer",
                        "description": "Specifies the maximum number of characters the password must contain. This number must be greater than or equal to the sum of PASSWORD*MIN*LENGTH, PASSWORD*MIN*UPPER*CASE*CHARS, and PASSWORD*MIN*LOWER*CASE*CHARS. Supported range: 8 to 256, inclusive. Default: 256\n"
                    },
                    "maxRetries": {
                        "type": "integer",
                        "description": "Specifies the maximum number of attempts to enter a password before being locked out. Supported range: 1 to 10, inclusive. Default: 5\n"
                    },
                    "minAgeDays": {
                        "type": "integer",
                        "description": "Specifies the number of days the user must wait before a recently changed password can be changed again. Supported range: 0 to 999, inclusive. Default: 0\n"
                    },
                    "minLength": {
                        "type": "integer",
                        "description": "Specifies the minimum number of characters the password must contain. Supported range: 8 to 256, inclusive. Default: 8\n"
                    },
                    "minLowerCaseChars": {
                        "type": "integer",
                        "description": "Specifies the minimum number of lowercase characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                    },
                    "minNumericChars": {
                        "type": "integer",
                        "description": "Specifies the minimum number of numeric characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                    },
                    "minSpecialChars": {
                        "type": "integer",
                        "description": "Specifies the minimum number of special characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                    },
                    "minUpperCaseChars": {
                        "type": "integer",
                        "description": "Specifies the minimum number of uppercase characters the password must contain. Supported range: 0 to 256, inclusive. Default: 1\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Identifier for the password policy; must be unique for your account.\n"
                    },
                    "orReplace": {
                        "type": "boolean",
                        "description": "Whether to override a previous password policy with the same name.\n"
                    },
                    "qualifiedName": {
                        "type": "string",
                        "description": "The qualified name for the password policy.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema this password policy belongs to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/pipe:Pipe": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Pipe;\nimport com.pulumi.snowflake.PipeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var pipe = new Pipe(\"pipe\", PipeArgs.builder()        \n            .autoIngest(false)\n            .awsSnsTopicArn(\"...\")\n            .comment(\"A pipe.\")\n            .copyStatement(\"copy into mytable from @mystage\")\n            .database(\"db\")\n            .notificationChannel(\"...\")\n            .schema(\"schema\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pipe:\n    type: snowflake:Pipe\n    properties:\n      autoIngest: false\n      awsSnsTopicArn: '...'\n      comment: A pipe.\n      copyStatement: copy into mytable from @mystage\n      database: db\n      notificationChannel: '...'\n      schema: schema\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | pipe name\n\n```sh\n $ pulumi import snowflake:index/pipe:Pipe example 'dbName|schemaName|pipeName'\n```\n\n ",
            "properties": {
                "autoIngest": {
                    "type": "boolean",
                    "description": "Specifies a auto_ingest param for the pipe.\n"
                },
                "awsSnsTopicArn": {
                    "type": "string",
                    "description": "Specifies the Amazon Resource Name (ARN) for the SNS topic for your S3 bucket.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the pipe.\n"
                },
                "copyStatement": {
                    "type": "string",
                    "description": "Specifies the copy statement for the pipe.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the pipe.\n"
                },
                "errorIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the notification integration used for error notifications.\n"
                },
                "integration": {
                    "type": "string",
                    "description": "Specifies an integration for the pipe.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the pipe; must be unique for the database and schema in which the pipe is created.\n"
                },
                "notificationChannel": {
                    "type": "string",
                    "description": "Amazon Resource Name of the Amazon SQS queue for the stage named in the DEFINITION column.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Name of the role that owns the pipe.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the pipe.\n"
                }
            },
            "required": [
                "copyStatement",
                "database",
                "name",
                "notificationChannel",
                "owner",
                "schema"
            ],
            "inputProperties": {
                "autoIngest": {
                    "type": "boolean",
                    "description": "Specifies a auto_ingest param for the pipe.\n",
                    "willReplaceOnChanges": true
                },
                "awsSnsTopicArn": {
                    "type": "string",
                    "description": "Specifies the Amazon Resource Name (ARN) for the SNS topic for your S3 bucket.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the pipe.\n"
                },
                "copyStatement": {
                    "type": "string",
                    "description": "Specifies the copy statement for the pipe.\n",
                    "willReplaceOnChanges": true
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the pipe.\n",
                    "willReplaceOnChanges": true
                },
                "errorIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the notification integration used for error notifications.\n"
                },
                "integration": {
                    "type": "string",
                    "description": "Specifies an integration for the pipe.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the pipe; must be unique for the database and schema in which the pipe is created.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the pipe.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "copyStatement",
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Pipe resources.\n",
                "properties": {
                    "autoIngest": {
                        "type": "boolean",
                        "description": "Specifies a auto_ingest param for the pipe.\n",
                        "willReplaceOnChanges": true
                    },
                    "awsSnsTopicArn": {
                        "type": "string",
                        "description": "Specifies the Amazon Resource Name (ARN) for the SNS topic for your S3 bucket.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the pipe.\n"
                    },
                    "copyStatement": {
                        "type": "string",
                        "description": "Specifies the copy statement for the pipe.\n",
                        "willReplaceOnChanges": true
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the pipe.\n",
                        "willReplaceOnChanges": true
                    },
                    "errorIntegration": {
                        "type": "string",
                        "description": "Specifies the name of the notification integration used for error notifications.\n"
                    },
                    "integration": {
                        "type": "string",
                        "description": "Specifies an integration for the pipe.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the pipe; must be unique for the database and schema in which the pipe is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "notificationChannel": {
                        "type": "string",
                        "description": "Amazon Resource Name of the Amazon SQS queue for the stage named in the DEFINITION column.\n"
                    },
                    "owner": {
                        "type": "string",
                        "description": "Name of the role that owns the pipe.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the pipe.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/pipeGrant:PipeGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.PipeGrant(\"grant\", {\n    databaseName: \"database\",\n    onFuture: false,\n    pipeName: \"pipe\",\n    privilege: \"OPERATE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.PipeGrant(\"grant\",\n    database_name=\"database\",\n    on_future=False,\n    pipe_name=\"pipe\",\n    privilege=\"OPERATE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.PipeGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        OnFuture = false,\n        PipeName = \"pipe\",\n        Privilege = \"OPERATE\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewPipeGrant(ctx, \"grant\", \u0026snowflake.PipeGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPipeName:     pulumi.String(\"pipe\"),\n\t\t\tPrivilege:    pulumi.String(\"OPERATE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.PipeGrant;\nimport com.pulumi.snowflake.PipeGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new PipeGrant(\"grant\", PipeGrantArgs.builder()        \n            .databaseName(\"database\")\n            .onFuture(false)\n            .pipeName(\"pipe\")\n            .privilege(\"OPERATE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:PipeGrant\n    properties:\n      databaseName: database\n      onFuture: false\n      pipeName: pipe\n      privilege: OPERATE\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|pipe_name|privilege|with_grant_option|on_future|roles\n\n```sh\n $ pulumi import snowflake:index/pipeGrant:PipeGrant example \"MY_DATABASE|MY_SCHEMA|MY_PIPE_NAME|OPERATE|false|false|role1,role2'\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future pipes on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future pipes in the given schema. When this is true and no schema*name is provided apply this grant on all future pipes in the given database. The pipe*name field must be unset in order to use on*future.\n"
                },
                "pipeName": {
                    "type": "string",
                    "description": "The name of the pipe on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future pipe. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future pipes on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future pipes on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future pipes in the given schema. When this is true and no schema*name is provided apply this grant on all future pipes in the given database. The pipe*name field must be unset in order to use on*future.\n"
                },
                "pipeName": {
                    "type": "string",
                    "description": "The name of the pipe on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future pipe. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future pipes on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PipeGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future pipes on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future pipes in the given schema. When this is true and no schema*name is provided apply this grant on all future pipes in the given database. The pipe*name field must be unset in order to use on*future.\n"
                    },
                    "pipeName": {
                        "type": "string",
                        "description": "The name of the pipe on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future pipe. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future pipes on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/procedure:Procedure": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.DatabaseArgs;\nimport com.pulumi.snowflake.Schema;\nimport com.pulumi.snowflake.SchemaArgs;\nimport com.pulumi.snowflake.Procedure;\nimport com.pulumi.snowflake.ProcedureArgs;\nimport com.pulumi.snowflake.inputs.ProcedureArgumentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var db = new Database(\"db\", DatabaseArgs.builder()        \n            .dataRetentionDays(1)\n            .build());\n\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .database(db.name())\n            .dataRetentionDays(1)\n            .build());\n\n        var proc = new Procedure(\"proc\", ProcedureArgs.builder()        \n            .database(db.name())\n            .schema(schema.name())\n            .language(\"JAVASCRIPT\")\n            .arguments(            \n                ProcedureArgumentArgs.builder()\n                    .name(\"arg1\")\n                    .type(\"varchar\")\n                    .build(),\n                ProcedureArgumentArgs.builder()\n                    .name(\"arg2\")\n                    .type(\"DATE\")\n                    .build())\n            .comment(\"Procedure with 2 arguments\")\n            .returnType(\"VARCHAR\")\n            .executeAs(\"CALLER\")\n            .returnBehavior(\"IMMUTABLE\")\n            .nullInputBehavior(\"RETURNS NULL ON NULL INPUT\")\n            .statement(\"\"\"\nvar X=1\nreturn X\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  db:\n    type: snowflake:Database\n    properties:\n      dataRetentionDays: 1\n  schema:\n    type: snowflake:Schema\n    properties:\n      database: ${db.name}\n      dataRetentionDays: 1\n  proc:\n    type: snowflake:Procedure\n    properties:\n      database: ${db.name}\n      schema: ${schema.name}\n      language: JAVASCRIPT\n      arguments:\n        - name: arg1\n          type: varchar\n        - name: arg2\n          type: DATE\n      comment: Procedure with 2 arguments\n      returnType: VARCHAR\n      executeAs: CALLER\n      returnBehavior: IMMUTABLE\n      nullInputBehavior: RETURNS NULL ON NULL INPUT\n      statement: |\n        var X=1\n        return X\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | stored procedure name | \u003clist of arg types, separated with '-'\u003e\n\n```sh\n $ pulumi import snowflake:index/procedure:Procedure example 'dbName|schemaName|procedureName|varchar-varchar-varchar'\n```\n\n ",
            "properties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ProcedureArgument:ProcedureArgument"
                    },
                    "description": "List of the arguments for the procedure\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the procedure.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the procedure. Don't use the | character.\n"
                },
                "executeAs": {
                    "type": "string",
                    "description": "Sets execute context - see caller's rights and owner's rights\n"
                },
                "handler": {
                    "type": "string",
                    "description": "The handler method for Java / Python procedures.\n"
                },
                "imports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Imports for Java / Python procedures. For Java this a list of jar files, for Python this is a list of Python files.\n"
                },
                "language": {
                    "type": "string",
                    "description": "Specifies the language of the stored procedure code.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The argument name\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the procedure when called with null inputs.\n"
                },
                "packages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of package imports to use for Java / Python procedures. For Java, package imports should be of the form: package*name:version*number, where package*name is snowflake*domain:package. For Python use it should be: ('numpy','pandas','xgboost==1.5.0').\n"
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n"
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the procedure\n"
                },
                "runtimeVersion": {
                    "type": "string",
                    "description": "Required for Python procedures. Specifies Python runtime version.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the procedure. Don't use the | character.\n"
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the code used to create the procedure.\n"
                }
            },
            "required": [
                "database",
                "name",
                "returnType",
                "schema",
                "statement"
            ],
            "inputProperties": {
                "arguments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ProcedureArgument:ProcedureArgument"
                    },
                    "description": "List of the arguments for the procedure\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the procedure.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the procedure. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "executeAs": {
                    "type": "string",
                    "description": "Sets execute context - see caller's rights and owner's rights\n"
                },
                "handler": {
                    "type": "string",
                    "description": "The handler method for Java / Python procedures.\n",
                    "willReplaceOnChanges": true
                },
                "imports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Imports for Java / Python procedures. For Java this a list of jar files, for Python this is a list of Python files.\n",
                    "willReplaceOnChanges": true
                },
                "language": {
                    "type": "string",
                    "description": "Specifies the language of the stored procedure code.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The argument name\n"
                },
                "nullInputBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the procedure when called with null inputs.\n",
                    "willReplaceOnChanges": true
                },
                "packages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of package imports to use for Java / Python procedures. For Java, package imports should be of the form: package*name:version*number, where package*name is snowflake*domain:package. For Python use it should be: ('numpy','pandas','xgboost==1.5.0').\n",
                    "willReplaceOnChanges": true
                },
                "returnBehavior": {
                    "type": "string",
                    "description": "Specifies the behavior of the function when returning results\n",
                    "willReplaceOnChanges": true
                },
                "returnType": {
                    "type": "string",
                    "description": "The return type of the procedure\n",
                    "willReplaceOnChanges": true
                },
                "runtimeVersion": {
                    "type": "string",
                    "description": "Required for Python procedures. Specifies Python runtime version.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the procedure. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the code used to create the procedure.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "returnType",
                "schema",
                "statement"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Procedure resources.\n",
                "properties": {
                    "arguments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ProcedureArgument:ProcedureArgument"
                        },
                        "description": "List of the arguments for the procedure\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the procedure.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the procedure. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "executeAs": {
                        "type": "string",
                        "description": "Sets execute context - see caller's rights and owner's rights\n"
                    },
                    "handler": {
                        "type": "string",
                        "description": "The handler method for Java / Python procedures.\n",
                        "willReplaceOnChanges": true
                    },
                    "imports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Imports for Java / Python procedures. For Java this a list of jar files, for Python this is a list of Python files.\n",
                        "willReplaceOnChanges": true
                    },
                    "language": {
                        "type": "string",
                        "description": "Specifies the language of the stored procedure code.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The argument name\n"
                    },
                    "nullInputBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the procedure when called with null inputs.\n",
                        "willReplaceOnChanges": true
                    },
                    "packages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of package imports to use for Java / Python procedures. For Java, package imports should be of the form: package*name:version*number, where package*name is snowflake*domain:package. For Python use it should be: ('numpy','pandas','xgboost==1.5.0').\n",
                        "willReplaceOnChanges": true
                    },
                    "returnBehavior": {
                        "type": "string",
                        "description": "Specifies the behavior of the function when returning results\n",
                        "willReplaceOnChanges": true
                    },
                    "returnType": {
                        "type": "string",
                        "description": "The return type of the procedure\n",
                        "willReplaceOnChanges": true
                    },
                    "runtimeVersion": {
                        "type": "string",
                        "description": "Required for Python procedures. Specifies Python runtime version.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the procedure. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "statement": {
                        "type": "string",
                        "description": "Specifies the code used to create the procedure.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/procedureGrant:ProcedureGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.ProcedureGrant(\"grant\", {\n    argumentDataTypes: [\n        \"array\",\n        \"string\",\n    ],\n    databaseName: \"database\",\n    onFuture: false,\n    privilege: \"USAGE\",\n    procedureName: \"procedure\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.ProcedureGrant(\"grant\",\n    argument_data_types=[\n        \"array\",\n        \"string\",\n    ],\n    database_name=\"database\",\n    on_future=False,\n    privilege=\"USAGE\",\n    procedure_name=\"procedure\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.ProcedureGrant(\"grant\", new()\n    {\n        ArgumentDataTypes = new[]\n        {\n            \"array\",\n            \"string\",\n        },\n        DatabaseName = \"database\",\n        OnFuture = false,\n        Privilege = \"USAGE\",\n        ProcedureName = \"procedure\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        Shares = new[]\n        {\n            \"share1\",\n            \"share2\",\n        },\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewProcedureGrant(ctx, \"grant\", \u0026snowflake.ProcedureGrantArgs{\n\t\t\tArgumentDataTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"array\"),\n\t\t\t\tpulumi.String(\"string\"),\n\t\t\t},\n\t\t\tDatabaseName:  pulumi.String(\"database\"),\n\t\t\tOnFuture:      pulumi.Bool(false),\n\t\t\tPrivilege:     pulumi.String(\"USAGE\"),\n\t\t\tProcedureName: pulumi.String(\"procedure\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ProcedureGrant;\nimport com.pulumi.snowflake.ProcedureGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new ProcedureGrant(\"grant\", ProcedureGrantArgs.builder()        \n            .argumentDataTypes(            \n                \"array\",\n                \"string\")\n            .databaseName(\"database\")\n            .onFuture(false)\n            .privilege(\"USAGE\")\n            .procedureName(\"procedure\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:ProcedureGrant\n    properties:\n      argumentDataTypes:\n        - array\n        - string\n      databaseName: database\n      onFuture: false\n      privilege: USAGE\n      procedureName: procedure\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|procedure_name|argument_data_types|privilege|with_grant_option|on_future|roles|shares\n\n```sh\n $ pulumi import snowflake:index/procedureGrant:ProcedureGrant example \"MY_DATABASE|MY_SCHEMA|MY_PROCEDURE|ARG1TYPE,ARG2TYPE|USAGE|false|false|role1,role2|share1,share2\"\n```\n\n ",
            "properties": {
                "argumentDataTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of the argument data types for the procedure (must be present if procedure has arguments and procedure_name is present)\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future procedures on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all procedures in the given schema. When this is true and no schema*name is provided apply this grant on all procedures in the given database. The procedure*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future procedures in the given schema. When this is true and no schema*name is provided apply this grant on all future procedures in the given database. The procedure*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future procedure. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "procedureName": {
                    "type": "string",
                    "description": "The name of the procedure on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future procedures on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "roles"
            ],
            "inputProperties": {
                "argumentDataTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of the argument data types for the procedure (must be present if procedure has arguments and procedure_name is present)\n",
                    "willReplaceOnChanges": true
                },
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future procedures on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all procedures in the given schema. When this is true and no schema*name is provided apply this grant on all procedures in the given database. The procedure*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future procedures in the given schema. When this is true and no schema*name is provided apply this grant on all future procedures in the given database. The procedure*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future procedure. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "procedureName": {
                    "type": "string",
                    "description": "The name of the procedure on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future procedures on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProcedureGrant resources.\n",
                "properties": {
                    "argumentDataTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of the argument data types for the procedure (must be present if procedure has arguments and procedure_name is present)\n",
                        "willReplaceOnChanges": true
                    },
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future procedures on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all procedures in the given schema. When this is true and no schema*name is provided apply this grant on all procedures in the given database. The procedure*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future procedures in the given schema. When this is true and no schema*name is provided apply this grant on all future procedures in the given database. The procedure*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future procedure. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "procedureName": {
                        "type": "string",
                        "description": "The name of the procedure on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future procedures on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on_future is false).\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/resourceMonitor:ResourceMonitor": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst monitor = new snowflake.ResourceMonitor(\"monitor\", {\n    creditQuota: 100,\n    endTimestamp: \"2021-12-07 00:00\",\n    frequency: \"DAILY\",\n    notifyTriggers: [\n        40,\n        50,\n    ],\n    notifyUsers: [\n        \"USERONE\",\n        \"USERTWO\",\n    ],\n    startTimestamp: \"2020-12-07 00:00\",\n    suspendImmediateTriggers: 90,\n    suspendTriggers: 50,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nmonitor = snowflake.ResourceMonitor(\"monitor\",\n    credit_quota=100,\n    end_timestamp=\"2021-12-07 00:00\",\n    frequency=\"DAILY\",\n    notify_triggers=[\n        40,\n        50,\n    ],\n    notify_users=[\n        \"USERONE\",\n        \"USERTWO\",\n    ],\n    start_timestamp=\"2020-12-07 00:00\",\n    suspend_immediate_triggers=90,\n    suspend_triggers=50)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var monitor = new Snowflake.ResourceMonitor(\"monitor\", new()\n    {\n        CreditQuota = 100,\n        EndTimestamp = \"2021-12-07 00:00\",\n        Frequency = \"DAILY\",\n        NotifyTriggers = new[]\n        {\n            40,\n            50,\n        },\n        NotifyUsers = new[]\n        {\n            \"USERONE\",\n            \"USERTWO\",\n        },\n        StartTimestamp = \"2020-12-07 00:00\",\n        SuspendImmediateTriggers = 90,\n        SuspendTriggers = 50,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewResourceMonitor(ctx, \"monitor\", \u0026snowflake.ResourceMonitorArgs{\n\t\t\tCreditQuota:  pulumi.Int(100),\n\t\t\tEndTimestamp: pulumi.String(\"2021-12-07 00:00\"),\n\t\t\tFrequency:    pulumi.String(\"DAILY\"),\n\t\t\tNotifyTriggers: pulumi.IntArray{\n\t\t\t\tpulumi.Int(40),\n\t\t\t\tpulumi.Int(50),\n\t\t\t},\n\t\t\tNotifyUsers: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"USERONE\"),\n\t\t\t\tpulumi.String(\"USERTWO\"),\n\t\t\t},\n\t\t\tStartTimestamp:           pulumi.String(\"2020-12-07 00:00\"),\n\t\t\tSuspendImmediateTriggers: pulumi.IntArray(90),\n\t\t\tSuspendTriggers:          pulumi.IntArray(50),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ResourceMonitor;\nimport com.pulumi.snowflake.ResourceMonitorArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var monitor = new ResourceMonitor(\"monitor\", ResourceMonitorArgs.builder()        \n            .creditQuota(100)\n            .endTimestamp(\"2021-12-07 00:00\")\n            .frequency(\"DAILY\")\n            .notifyTriggers(            \n                40,\n                50)\n            .notifyUsers(            \n                \"USERONE\",\n                \"USERTWO\")\n            .startTimestamp(\"2020-12-07 00:00\")\n            .suspendImmediateTriggers(90)\n            .suspendTriggers(50)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  monitor:\n    type: snowflake:ResourceMonitor\n    properties:\n      creditQuota: 100\n      endTimestamp: 2021-12-07 00:00\n      frequency: DAILY\n      notifyTriggers:\n        - 40\n        - 50\n      notifyUsers:\n        - USERONE\n        - USERTWO\n      startTimestamp: 2020-12-07 00:00\n      suspendImmediateTriggers: 90\n      suspendTriggers: 50\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is the resource monitor name\n\n```sh\n $ pulumi import snowflake:index/resourceMonitor:ResourceMonitor example 'resourceMonitorName'\n```\n\n ",
            "properties": {
                "creditQuota": {
                    "type": "integer",
                    "description": "The number of credits allocated monthly to the resource monitor.\n"
                },
                "endTimestamp": {
                    "type": "string",
                    "description": "The date and time when the resource monitor suspends the assigned warehouses.\n"
                },
                "frequency": {
                    "type": "string",
                    "description": "The frequency interval at which the credit usage resets to 0. If you set a frequency for a resource monitor, you must also set START_TIMESTAMP.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the resource monitor; must be unique for your account.\n"
                },
                "notifyTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to send an alert to subscribed users.\n"
                },
                "notifyUsers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of users to receive email notifications on resource monitors.\n"
                },
                "setForAccount": {
                    "type": "boolean",
                    "description": "Specifies whether the resource monitor should be applied globally to your Snowflake account (defaults to false).\n"
                },
                "startTimestamp": {
                    "type": "string",
                    "description": "The date and time when the resource monitor starts monitoring credit usage for the assigned warehouses.\n"
                },
                "suspendImmediateTrigger": {
                    "type": "integer",
                    "description": "The number that represents the percentage threshold at which to immediately suspend all warehouses.\n"
                },
                "suspendImmediateTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to suspend all warehouses.\n",
                    "deprecationMessage": "Use suspend_immediate_trigger instead"
                },
                "suspendTrigger": {
                    "type": "integer",
                    "description": "The number that represents the percentage threshold at which to suspend all warehouses.\n"
                },
                "suspendTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to suspend all warehouses.\n",
                    "deprecationMessage": "Use suspend_trigger instead"
                },
                "warehouses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of warehouses to apply the resource monitor to.\n"
                }
            },
            "required": [
                "creditQuota",
                "frequency",
                "name",
                "startTimestamp"
            ],
            "inputProperties": {
                "creditQuota": {
                    "type": "integer",
                    "description": "The number of credits allocated monthly to the resource monitor.\n"
                },
                "endTimestamp": {
                    "type": "string",
                    "description": "The date and time when the resource monitor suspends the assigned warehouses.\n"
                },
                "frequency": {
                    "type": "string",
                    "description": "The frequency interval at which the credit usage resets to 0. If you set a frequency for a resource monitor, you must also set START_TIMESTAMP.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the resource monitor; must be unique for your account.\n",
                    "willReplaceOnChanges": true
                },
                "notifyTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to send an alert to subscribed users.\n"
                },
                "notifyUsers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the list of users to receive email notifications on resource monitors.\n"
                },
                "setForAccount": {
                    "type": "boolean",
                    "description": "Specifies whether the resource monitor should be applied globally to your Snowflake account (defaults to false).\n"
                },
                "startTimestamp": {
                    "type": "string",
                    "description": "The date and time when the resource monitor starts monitoring credit usage for the assigned warehouses.\n"
                },
                "suspendImmediateTrigger": {
                    "type": "integer",
                    "description": "The number that represents the percentage threshold at which to immediately suspend all warehouses.\n"
                },
                "suspendImmediateTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to suspend all warehouses.\n",
                    "deprecationMessage": "Use suspend_immediate_trigger instead"
                },
                "suspendTrigger": {
                    "type": "integer",
                    "description": "The number that represents the percentage threshold at which to suspend all warehouses.\n"
                },
                "suspendTriggers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of percentage thresholds at which to suspend all warehouses.\n",
                    "deprecationMessage": "Use suspend_trigger instead"
                },
                "warehouses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of warehouses to apply the resource monitor to.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourceMonitor resources.\n",
                "properties": {
                    "creditQuota": {
                        "type": "integer",
                        "description": "The number of credits allocated monthly to the resource monitor.\n"
                    },
                    "endTimestamp": {
                        "type": "string",
                        "description": "The date and time when the resource monitor suspends the assigned warehouses.\n"
                    },
                    "frequency": {
                        "type": "string",
                        "description": "The frequency interval at which the credit usage resets to 0. If you set a frequency for a resource monitor, you must also set START_TIMESTAMP.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Identifier for the resource monitor; must be unique for your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "notifyTriggers": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of percentage thresholds at which to send an alert to subscribed users.\n"
                    },
                    "notifyUsers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the list of users to receive email notifications on resource monitors.\n"
                    },
                    "setForAccount": {
                        "type": "boolean",
                        "description": "Specifies whether the resource monitor should be applied globally to your Snowflake account (defaults to false).\n"
                    },
                    "startTimestamp": {
                        "type": "string",
                        "description": "The date and time when the resource monitor starts monitoring credit usage for the assigned warehouses.\n"
                    },
                    "suspendImmediateTrigger": {
                        "type": "integer",
                        "description": "The number that represents the percentage threshold at which to immediately suspend all warehouses.\n"
                    },
                    "suspendImmediateTriggers": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of percentage thresholds at which to suspend all warehouses.\n",
                        "deprecationMessage": "Use suspend_immediate_trigger instead"
                    },
                    "suspendTrigger": {
                        "type": "integer",
                        "description": "The number that represents the percentage threshold at which to suspend all warehouses.\n"
                    },
                    "suspendTriggers": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of percentage thresholds at which to suspend all warehouses.\n",
                        "deprecationMessage": "Use suspend_trigger instead"
                    },
                    "warehouses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of warehouses to apply the resource monitor to.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/resourceMonitorGrant:ResourceMonitorGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.ResourceMonitorGrant(\"grant\", {\n    monitorName: \"monitor\",\n    privilege: \"MODIFY\",\n    roles: [\"role1\"],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.ResourceMonitorGrant(\"grant\",\n    monitor_name=\"monitor\",\n    privilege=\"MODIFY\",\n    roles=[\"role1\"],\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.ResourceMonitorGrant(\"grant\", new()\n    {\n        MonitorName = \"monitor\",\n        Privilege = \"MODIFY\",\n        Roles = new[]\n        {\n            \"role1\",\n        },\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewResourceMonitorGrant(ctx, \"grant\", \u0026snowflake.ResourceMonitorGrantArgs{\n\t\t\tMonitorName: pulumi.String(\"monitor\"),\n\t\t\tPrivilege:   pulumi.String(\"MODIFY\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ResourceMonitorGrant;\nimport com.pulumi.snowflake.ResourceMonitorGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new ResourceMonitorGrant(\"grant\", ResourceMonitorGrantArgs.builder()        \n            .monitorName(\"monitor\")\n            .privilege(\"MODIFY\")\n            .roles(\"role1\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:ResourceMonitorGrant\n    properties:\n      monitorName: monitor\n      privilege: MODIFY\n      roles:\n        - role1\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is monitor_name|privilege|with_grant_option|roles\n\n```sh\n $ pulumi import snowflake:index/resourceMonitorGrant:ResourceMonitorGrant example \"MY_RESOURCE_MONITOR|MONITOR|false|role1,role2\"\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "monitorName": {
                    "type": "string",
                    "description": "Identifier for the resource monitor; must be unique for your account.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the resource monitor. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "monitorName"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "monitorName": {
                    "type": "string",
                    "description": "Identifier for the resource monitor; must be unique for your account.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the resource monitor. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "monitorName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourceMonitorGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "monitorName": {
                        "type": "string",
                        "description": "Identifier for the resource monitor; must be unique for your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the resource monitor. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/role:Role": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst role = new snowflake.Role(\"role\", {comment: \"A role.\"});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nrole = snowflake.Role(\"role\", comment=\"A role.\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var role = new Snowflake.Role(\"role\", new()\n    {\n        Comment = \"A role.\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewRole(ctx, \"role\", \u0026snowflake.RoleArgs{\n\t\t\tComment: pulumi.String(\"A role.\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Role;\nimport com.pulumi.snowflake.RoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var role = new Role(\"role\", RoleArgs.builder()        \n            .comment(\"A role.\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  role:\n    type: snowflake:Role\n    properties:\n      comment: A role.\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/role:Role example roleName\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/RoleTag:RoleTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/RoleTag:RoleTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "comment": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Tag name, e.g. department.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/RoleTag:RoleTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n",
                        "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/roleGrants:RoleGrants": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst role = new snowflake.Role(\"role\", {comment: \"for testing\"});\nconst user = new snowflake.User(\"user\", {comment: \"for testing\"});\nconst user2 = new snowflake.User(\"user2\", {comment: \"for testing\"});\nconst otherRole = new snowflake.Role(\"otherRole\", {});\nconst grants = new snowflake.RoleGrants(\"grants\", {\n    roleName: role.name,\n    roles: [otherRole.name],\n    users: [\n        user.name,\n        user2.name,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nrole = snowflake.Role(\"role\", comment=\"for testing\")\nuser = snowflake.User(\"user\", comment=\"for testing\")\nuser2 = snowflake.User(\"user2\", comment=\"for testing\")\nother_role = snowflake.Role(\"otherRole\")\ngrants = snowflake.RoleGrants(\"grants\",\n    role_name=role.name,\n    roles=[other_role.name],\n    users=[\n        user.name,\n        user2.name,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var role = new Snowflake.Role(\"role\", new()\n    {\n        Comment = \"for testing\",\n    });\n\n    var user = new Snowflake.User(\"user\", new()\n    {\n        Comment = \"for testing\",\n    });\n\n    var user2 = new Snowflake.User(\"user2\", new()\n    {\n        Comment = \"for testing\",\n    });\n\n    var otherRole = new Snowflake.Role(\"otherRole\");\n\n    var grants = new Snowflake.RoleGrants(\"grants\", new()\n    {\n        RoleName = role.Name,\n        Roles = new[]\n        {\n            otherRole.Name,\n        },\n        Users = new[]\n        {\n            user.Name,\n            user2.Name,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trole, err := snowflake.NewRole(ctx, \"role\", \u0026snowflake.RoleArgs{\n\t\t\tComment: pulumi.String(\"for testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := snowflake.NewUser(ctx, \"user\", \u0026snowflake.UserArgs{\n\t\t\tComment: pulumi.String(\"for testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser2, err := snowflake.NewUser(ctx, \"user2\", \u0026snowflake.UserArgs{\n\t\t\tComment: pulumi.String(\"for testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\totherRole, err := snowflake.NewRole(ctx, \"otherRole\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewRoleGrants(ctx, \"grants\", \u0026snowflake.RoleGrantsArgs{\n\t\t\tRoleName: role.Name,\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\totherRole.Name,\n\t\t\t},\n\t\t\tUsers: pulumi.StringArray{\n\t\t\t\tuser.Name,\n\t\t\t\tuser2.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Role;\nimport com.pulumi.snowflake.RoleArgs;\nimport com.pulumi.snowflake.User;\nimport com.pulumi.snowflake.UserArgs;\nimport com.pulumi.snowflake.RoleGrants;\nimport com.pulumi.snowflake.RoleGrantsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var role = new Role(\"role\", RoleArgs.builder()        \n            .comment(\"for testing\")\n            .build());\n\n        var user = new User(\"user\", UserArgs.builder()        \n            .comment(\"for testing\")\n            .build());\n\n        var user2 = new User(\"user2\", UserArgs.builder()        \n            .comment(\"for testing\")\n            .build());\n\n        var otherRole = new Role(\"otherRole\");\n\n        var grants = new RoleGrants(\"grants\", RoleGrantsArgs.builder()        \n            .roleName(role.name())\n            .roles(otherRole.name())\n            .users(            \n                user.name(),\n                user2.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  role:\n    type: snowflake:Role\n    properties:\n      comment: for testing\n  user:\n    type: snowflake:User\n    properties:\n      comment: for testing\n  user2:\n    type: snowflake:User\n    properties:\n      comment: for testing\n  otherRole:\n    type: snowflake:Role\n  grants:\n    type: snowflake:RoleGrants\n    properties:\n      roleName: ${role.name}\n      roles:\n        - ${otherRole.name}\n      users:\n        - ${user.name}\n        - ${user2.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is role_name|roles|users\n\n```sh\n $ pulumi import snowflake:index/roleGrants:RoleGrants example \"role_name|role1,role2|user1,user2\"\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role we are granting.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants role to this specified role.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants role to this specified user.\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the role we are granting.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants role to this specified role.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants role to this specified user.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RoleGrants resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the role we are granting.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants role to this specified role.\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants role to this specified user.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/roleOwnershipGrant:RoleOwnershipGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst role = new snowflake.Role(\"role\", {comment: \"for testing\"});\nconst otherRole = new snowflake.Role(\"otherRole\", {});\n// ensure the Terraform user inherits ownership privileges for the rking_test_role role\n// otherwise Terraform will fail to destroy the rking_test_role2 role due to insufficient privileges\nconst grants = new snowflake.RoleGrants(\"grants\", {\n    roleName: role.name,\n    roles: [\"ACCOUNTADMIN\"],\n});\nconst grant = new snowflake.RoleOwnershipGrant(\"grant\", {\n    onRoleName: role.name,\n    toRoleName: otherRole.name,\n    currentGrants: \"COPY\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nrole = snowflake.Role(\"role\", comment=\"for testing\")\nother_role = snowflake.Role(\"otherRole\")\n# ensure the Terraform user inherits ownership privileges for the rking_test_role role\n# otherwise Terraform will fail to destroy the rking_test_role2 role due to insufficient privileges\ngrants = snowflake.RoleGrants(\"grants\",\n    role_name=role.name,\n    roles=[\"ACCOUNTADMIN\"])\ngrant = snowflake.RoleOwnershipGrant(\"grant\",\n    on_role_name=role.name,\n    to_role_name=other_role.name,\n    current_grants=\"COPY\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var role = new Snowflake.Role(\"role\", new()\n    {\n        Comment = \"for testing\",\n    });\n\n    var otherRole = new Snowflake.Role(\"otherRole\");\n\n    // ensure the Terraform user inherits ownership privileges for the rking_test_role role\n    // otherwise Terraform will fail to destroy the rking_test_role2 role due to insufficient privileges\n    var grants = new Snowflake.RoleGrants(\"grants\", new()\n    {\n        RoleName = role.Name,\n        Roles = new[]\n        {\n            \"ACCOUNTADMIN\",\n        },\n    });\n\n    var grant = new Snowflake.RoleOwnershipGrant(\"grant\", new()\n    {\n        OnRoleName = role.Name,\n        ToRoleName = otherRole.Name,\n        CurrentGrants = \"COPY\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trole, err := snowflake.NewRole(ctx, \"role\", \u0026snowflake.RoleArgs{\n\t\t\tComment: pulumi.String(\"for testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\totherRole, err := snowflake.NewRole(ctx, \"otherRole\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewRoleGrants(ctx, \"grants\", \u0026snowflake.RoleGrantsArgs{\n\t\t\tRoleName: role.Name,\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ACCOUNTADMIN\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewRoleOwnershipGrant(ctx, \"grant\", \u0026snowflake.RoleOwnershipGrantArgs{\n\t\t\tOnRoleName:    role.Name,\n\t\t\tToRoleName:    otherRole.Name,\n\t\t\tCurrentGrants: pulumi.String(\"COPY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Role;\nimport com.pulumi.snowflake.RoleArgs;\nimport com.pulumi.snowflake.RoleGrants;\nimport com.pulumi.snowflake.RoleGrantsArgs;\nimport com.pulumi.snowflake.RoleOwnershipGrant;\nimport com.pulumi.snowflake.RoleOwnershipGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var role = new Role(\"role\", RoleArgs.builder()        \n            .comment(\"for testing\")\n            .build());\n\n        var otherRole = new Role(\"otherRole\");\n\n        var grants = new RoleGrants(\"grants\", RoleGrantsArgs.builder()        \n            .roleName(role.name())\n            .roles(\"ACCOUNTADMIN\")\n            .build());\n\n        var grant = new RoleOwnershipGrant(\"grant\", RoleOwnershipGrantArgs.builder()        \n            .onRoleName(role.name())\n            .toRoleName(otherRole.name())\n            .currentGrants(\"COPY\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  role:\n    type: snowflake:Role\n    properties:\n      comment: for testing\n  otherRole:\n    type: snowflake:Role\n  # ensure the Terraform user inherits ownership privileges for the rking_test_role role\n  # otherwise Terraform will fail to destroy the rking_test_role2 role due to insufficient privileges\n  grants:\n    type: snowflake:RoleGrants\n    properties:\n      roleName: ${role.name}\n      roles:\n        - ACCOUNTADMIN\n  grant:\n    type: snowflake:RoleOwnershipGrant\n    properties:\n      onRoleName: ${role.name}\n      toRoleName: ${otherRole.name}\n      currentGrants: COPY\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/roleOwnershipGrant:RoleOwnershipGrant example \"\u003con_role_name\u003e|\u003cto_role_name\u003e|\u003ccurrent_grants\u003e\"\n```\n\n ",
            "properties": {
                "currentGrants": {
                    "type": "string",
                    "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to a new role.\n"
                },
                "onRoleName": {
                    "type": "string",
                    "description": "The name of the role ownership is granted on.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy.\n"
                },
                "toRoleName": {
                    "type": "string",
                    "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                }
            },
            "required": [
                "onRoleName",
                "toRoleName"
            ],
            "inputProperties": {
                "currentGrants": {
                    "type": "string",
                    "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to a new role.\n"
                },
                "onRoleName": {
                    "type": "string",
                    "description": "The name of the role ownership is granted on.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy.\n"
                },
                "toRoleName": {
                    "type": "string",
                    "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                }
            },
            "requiredInputs": [
                "onRoleName",
                "toRoleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RoleOwnershipGrant resources.\n",
                "properties": {
                    "currentGrants": {
                        "type": "string",
                        "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to a new role.\n"
                    },
                    "onRoleName": {
                        "type": "string",
                        "description": "The name of the role ownership is granted on.\n"
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy.\n"
                    },
                    "toRoleName": {
                        "type": "string",
                        "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/rowAccessPolicy:RowAccessPolicy": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst exampleRowAccessPolicy = new snowflake.RowAccessPolicy(\"exampleRowAccessPolicy\", {\n    database: \"EXAMPLE_DB\",\n    rowAccessExpression: \"case when current_role() in ('ANALYST') then true else false end\",\n    schema: \"EXAMPLE_SCHEMA\",\n    signature: {\n        A: \"VARCHAR\",\n        B: \"VARCHAR\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexample_row_access_policy = snowflake.RowAccessPolicy(\"exampleRowAccessPolicy\",\n    database=\"EXAMPLE_DB\",\n    row_access_expression=\"case when current_role() in ('ANALYST') then true else false end\",\n    schema=\"EXAMPLE_SCHEMA\",\n    signature={\n        \"A\": \"VARCHAR\",\n        \"B\": \"VARCHAR\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleRowAccessPolicy = new Snowflake.RowAccessPolicy(\"exampleRowAccessPolicy\", new()\n    {\n        Database = \"EXAMPLE_DB\",\n        RowAccessExpression = \"case when current_role() in ('ANALYST') then true else false end\",\n        Schema = \"EXAMPLE_SCHEMA\",\n        Signature = \n        {\n            { \"A\", \"VARCHAR\" },\n            { \"B\", \"VARCHAR\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewRowAccessPolicy(ctx, \"exampleRowAccessPolicy\", \u0026snowflake.RowAccessPolicyArgs{\n\t\t\tDatabase:            pulumi.String(\"EXAMPLE_DB\"),\n\t\t\tRowAccessExpression: pulumi.String(\"case when current_role() in ('ANALYST') then true else false end\"),\n\t\t\tSchema:              pulumi.String(\"EXAMPLE_SCHEMA\"),\n\t\t\tSignature: pulumi.StringMap{\n\t\t\t\t\"A\": pulumi.String(\"VARCHAR\"),\n\t\t\t\t\"B\": pulumi.String(\"VARCHAR\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.RowAccessPolicy;\nimport com.pulumi.snowflake.RowAccessPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleRowAccessPolicy = new RowAccessPolicy(\"exampleRowAccessPolicy\", RowAccessPolicyArgs.builder()        \n            .database(\"EXAMPLE_DB\")\n            .rowAccessExpression(\"case when current_role() in ('ANALYST') then true else false end\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .signature(Map.ofEntries(\n                Map.entry(\"A\", \"VARCHAR\"),\n                Map.entry(\"B\", \"VARCHAR\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleRowAccessPolicy:\n    type: snowflake:RowAccessPolicy\n    properties:\n      database: EXAMPLE_DB\n      rowAccessExpression: case when current_role() in ('ANALYST') then true else false end\n      schema: EXAMPLE_SCHEMA\n      signature:\n        A: VARCHAR\n        B: VARCHAR\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | policy name\n\n```sh\n $ pulumi import snowflake:index/rowAccessPolicy:RowAccessPolicy example 'dbName|schemaName|policyName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the row access policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the row access policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the row access policy; must be unique for the database and schema in which the row access policy is created.\n"
                },
                "rowAccessExpression": {
                    "type": "string",
                    "description": "Specifies the SQL expression. The expression can be any boolean-valued SQL expression.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the row access policy.\n"
                },
                "signature": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies signature (arguments) for the row access policy (uppercase and sorted to avoid recreation of resource). A signature specifies a set of attributes that must be considered to determine whether the row is accessible. The attribute values come from the database object (e.g. table or view) to be protected by the row access policy.\n"
                }
            },
            "required": [
                "database",
                "name",
                "rowAccessExpression",
                "schema",
                "signature"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the row access policy.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the row access policy.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the row access policy; must be unique for the database and schema in which the row access policy is created.\n",
                    "willReplaceOnChanges": true
                },
                "rowAccessExpression": {
                    "type": "string",
                    "description": "Specifies the SQL expression. The expression can be any boolean-valued SQL expression.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the row access policy.\n",
                    "willReplaceOnChanges": true
                },
                "signature": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies signature (arguments) for the row access policy (uppercase and sorted to avoid recreation of resource). A signature specifies a set of attributes that must be considered to determine whether the row is accessible. The attribute values come from the database object (e.g. table or view) to be protected by the row access policy.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "rowAccessExpression",
                "schema",
                "signature"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RowAccessPolicy resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the row access policy.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the row access policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the row access policy; must be unique for the database and schema in which the row access policy is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "rowAccessExpression": {
                        "type": "string",
                        "description": "Specifies the SQL expression. The expression can be any boolean-valued SQL expression.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the row access policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "signature": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies signature (arguments) for the row access policy (uppercase and sorted to avoid recreation of resource). A signature specifies a set of attributes that must be considered to determine whether the row is accessible. The attribute values come from the database object (e.g. table or view) to be protected by the row access policy.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/rowAccessPolicyGrant:RowAccessPolicyGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.RowAccessPolicyGrant(\"grant\", {\n    databaseName: \"database\",\n    privilege: \"APPLY\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    rowAccessPolicyName: \"row_access_policy\",\n    schemaName: \"schema\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.RowAccessPolicyGrant(\"grant\",\n    database_name=\"database\",\n    privilege=\"APPLY\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    row_access_policy_name=\"row_access_policy\",\n    schema_name=\"schema\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.RowAccessPolicyGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        Privilege = \"APPLY\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        RowAccessPolicyName = \"row_access_policy\",\n        SchemaName = \"schema\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewRowAccessPolicyGrant(ctx, \"grant\", \u0026snowflake.RowAccessPolicyGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tPrivilege:    pulumi.String(\"APPLY\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tRowAccessPolicyName: pulumi.String(\"row_access_policy\"),\n\t\t\tSchemaName:          pulumi.String(\"schema\"),\n\t\t\tWithGrantOption:     pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.RowAccessPolicyGrant;\nimport com.pulumi.snowflake.RowAccessPolicyGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new RowAccessPolicyGrant(\"grant\", RowAccessPolicyGrantArgs.builder()        \n            .databaseName(\"database\")\n            .privilege(\"APPLY\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .rowAccessPolicyName(\"row_access_policy\")\n            .schemaName(\"schema\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:RowAccessPolicyGrant\n    properties:\n      databaseName: database\n      privilege: APPLY\n      roles:\n        - role1\n        - role2\n      rowAccessPolicyName: row_access_policy\n      schemaName: schema\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|row_access_policy_name|privilege|with_grant_option|roles\n\n```sh\n $ pulumi import snowflake:index/rowAccessPolicyGrant:RowAccessPolicyGrant example \"MY_DATABASE|MY_SCHEMA|MY_ROW_ACCESS_POLICY_NAME|SELECT|false|role1,role2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the row access policy on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the row access policy. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "rowAccessPolicyName": {
                    "type": "string",
                    "description": "The name of the row access policy on which to grant privileges immediately.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the row access policy on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "rowAccessPolicyName",
                "schemaName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the row access policy on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the row access policy. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "rowAccessPolicyName": {
                    "type": "string",
                    "description": "The name of the row access policy on which to grant privileges immediately.\n",
                    "willReplaceOnChanges": true
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the row access policy on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "rowAccessPolicyName",
                "schemaName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RowAccessPolicyGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the row access policy on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the row access policy. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "rowAccessPolicyName": {
                        "type": "string",
                        "description": "The name of the row access policy on which to grant privileges immediately.\n",
                        "willReplaceOnChanges": true
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the row access policy on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/samlIntegration:SamlIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst samlIntegration = new snowflake.SamlIntegration(\"samlIntegration\", {\n    enabled: true,\n    saml2Issuer: \"test_issuer\",\n    saml2Provider: \"CUSTOM\",\n    saml2SsoUrl: \"https://testsamlissuer.com\",\n    saml2X509Cert: \"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nsaml_integration = snowflake.SamlIntegration(\"samlIntegration\",\n    enabled=True,\n    saml2_issuer=\"test_issuer\",\n    saml2_provider=\"CUSTOM\",\n    saml2_sso_url=\"https://testsamlissuer.com\",\n    saml2_x509_cert=\"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var samlIntegration = new Snowflake.SamlIntegration(\"samlIntegration\", new()\n    {\n        Enabled = true,\n        Saml2Issuer = \"test_issuer\",\n        Saml2Provider = \"CUSTOM\",\n        Saml2SsoUrl = \"https://testsamlissuer.com\",\n        Saml2X509Cert = \"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewSamlIntegration(ctx, \"samlIntegration\", \u0026snowflake.SamlIntegrationArgs{\n\t\t\tEnabled:       pulumi.Bool(true),\n\t\t\tSaml2Issuer:   pulumi.String(\"test_issuer\"),\n\t\t\tSaml2Provider: pulumi.String(\"CUSTOM\"),\n\t\t\tSaml2SsoUrl:   pulumi.String(\"https://testsamlissuer.com\"),\n\t\t\tSaml2X509Cert: pulumi.String(\"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SamlIntegration;\nimport com.pulumi.snowflake.SamlIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var samlIntegration = new SamlIntegration(\"samlIntegration\", SamlIntegrationArgs.builder()        \n            .enabled(true)\n            .saml2Issuer(\"test_issuer\")\n            .saml2Provider(\"CUSTOM\")\n            .saml2SsoUrl(\"https://testsamlissuer.com\")\n            .saml2X509Cert(\"MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  samlIntegration:\n    type: snowflake:SamlIntegration\n    properties:\n      enabled: true\n      saml2Issuer: test_issuer\n      saml2Provider: CUSTOM\n      saml2SsoUrl: https://testsamlissuer.com\n      saml2X509Cert: MIICYzCCAcygAwIBAgIBADANBgkqhkiG9w0BAQUFADAuMQswCQYDVQQGEwJVUzEMMAoGA1UEChMDSUJNMREwDwYDVQQLEwhMb2NhbCBDQTAeFw05OTEyMjIwNTAwMDBaFw0wMDEyMjMwNDU5NTlaMC4xCzAJBgNVBAYTAlVTMQwwCgYDVQQKEwNJQk0xETAPBgNVBAsTCExvY2FsIENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD2bZEo7xGaX2/0GHkrNFZvlxBou9v1Jmt/PDiTMPve8r9FeJAQ0QdvFST/0JPQYD20rH0bimdDLgNdNynmyRoS2S/IInfpmf69iyc2G0TPyRvmHIiOZbdCd+YBHQi1adkj17NDcWj6S14tVurFX73zx0sNoMS79q3tuXKrDsxeuwIDAQABo4GQMIGNMEsGCVUdDwGG+EIBDQQ+EzxHZW5lcmF0ZWQgYnkgdGhlIFNlY3VyZVdheSBTZWN1cml0eSBTZXJ2ZXIgZm9yIE9TLzM5MCAoUkFDRikwDgYDVR0PAQH/BAQDAgAGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ3+ocRyCTJw067dLSwr/nalx6YMMA0GCSqGSIb3DQEBBQUAA4GBAMaQzt+zaj1GU77yzlr8iiMBXgdQrwsZZWJo5exnAucJAEYQZmOfyLiMD6oYq+ZnfvM0n8G/Y79q8nhwvuxpYOnRSAXFp6xSkrIOeZtJMY1h00LKp/JX3Ng1svZ2agE126JHsQ0bhzN5TKsYfbwfTwfjdWAGy6Vf1nYi/rO+ryMO\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/samlIntegration:SamlIntegration example name\n```\n\n ",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the SAML integration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this security integration is enabled or disabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the SAML2 integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n"
                },
                "saml2DigestMethodsUsed": {
                    "type": "string"
                },
                "saml2EnableSpInitiated": {
                    "type": "boolean",
                    "description": "The Boolean indicating if the Log In With button will be shown on the login page. TRUE: displays the Log in WIth button on the login page.  FALSE: does not display the Log in With button on the login page.\n"
                },
                "saml2ForceAuthn": {
                    "type": "boolean",
                    "description": "The Boolean indicating whether users, during the initial authentication flow, are forced to authenticate again to access Snowflake. When set to TRUE, Snowflake sets the ForceAuthn SAML parameter to TRUE in the outgoing request from Snowflake to the identity provider. TRUE: forces users to authenticate again to access Snowflake, even if a valid session with the identity provider exists. FALSE: does not force users to authenticate again to access Snowflake.\n"
                },
                "saml2Issuer": {
                    "type": "string",
                    "description": "The string containing the IdP EntityID / Issuer.\n"
                },
                "saml2PostLogoutRedirectUrl": {
                    "type": "string",
                    "description": "The endpoint to which Snowflake redirects users after clicking the Log Out button in the classic Snowflake web interface. Snowflake terminates the Snowflake session upon redirecting to the specified endpoint.\n"
                },
                "saml2Provider": {
                    "type": "string",
                    "description": "The string describing the IdP. One of the following: OKTA, ADFS, Custom.\n"
                },
                "saml2RequestedNameidFormat": {
                    "type": "string",
                    "description": "The SAML NameID format allows Snowflake to set an expectation of the identifying attribute of the user (i.e. SAML Subject) in the SAML assertion from the IdP to ensure a valid authentication to Snowflake. If a value is not specified, Snowflake sends the urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress value in the authentication request to the IdP. NameID must be one of the following values: urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified, urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress, urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName, urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName, urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos, urn:oasis:names:tc:SAML:2.0:nameid-format:persistent, urn:oasis:names:tc:SAML:2.0:nameid-format:transient .\n"
                },
                "saml2SignRequest": {
                    "type": "boolean",
                    "description": "The Boolean indicating whether SAML requests are signed. TRUE: allows SAML requests to be signed. FALSE: does not allow SAML requests to be signed.\n"
                },
                "saml2SignatureMethodsUsed": {
                    "type": "string"
                },
                "saml2SnowflakeAcsUrl": {
                    "type": "string",
                    "description": "The string containing the Snowflake Assertion Consumer Service URL to which the IdP will send its SAML authentication response back to Snowflake. This property will be set in the SAML authentication request generated by Snowflake when initiating a SAML SSO operation with the IdP. If an incorrect value is specified, Snowflake returns an error message indicating the acceptable values to use. Default: https://\\n\\n.\\n\\n.snowflakecomputing.com/fed/login\n"
                },
                "saml2SnowflakeIssuerUrl": {
                    "type": "string",
                    "description": "The string containing the EntityID / Issuer for the Snowflake service provider. If an incorrect value is specified, Snowflake returns an error message indicating the acceptable values to use.\n"
                },
                "saml2SnowflakeMetadata": {
                    "type": "string",
                    "description": "Metadata created by Snowflake to provide to SAML2 provider.\n"
                },
                "saml2SnowflakeX509Cert": {
                    "type": "string",
                    "description": "The Base64 encoded self-signed certificate generated by Snowflake for use with Encrypting SAML Assertions and Signed SAML Requests. You must have at least one of these features (encrypted SAML assertions or signed SAML responses) enabled in your Snowflake account to access the certificate value.\n"
                },
                "saml2SpInitiatedLoginPageLabel": {
                    "type": "string",
                    "description": "The string containing the label to display after the Log In With button on the login page.\n"
                },
                "saml2SsoUrl": {
                    "type": "string",
                    "description": "The string containing the IdP SSO URL, where the user should be redirected by Snowflake (the Service Provider) with a SAML AuthnRequest message.\n"
                },
                "saml2X509Cert": {
                    "type": "string",
                    "description": "The Base64 encoded IdP signing certificate on a single line without the leading -----BEGIN CERTIFICATE----- and ending -----END CERTIFICATE----- markers.\n"
                }
            },
            "required": [
                "createdOn",
                "name",
                "saml2DigestMethodsUsed",
                "saml2Issuer",
                "saml2Provider",
                "saml2SignatureMethodsUsed",
                "saml2SnowflakeAcsUrl",
                "saml2SnowflakeIssuerUrl",
                "saml2SnowflakeMetadata",
                "saml2SnowflakeX509Cert",
                "saml2SsoUrl",
                "saml2X509Cert"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether this security integration is enabled or disabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the SAML2 integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n",
                    "willReplaceOnChanges": true
                },
                "saml2EnableSpInitiated": {
                    "type": "boolean",
                    "description": "The Boolean indicating if the Log In With button will be shown on the login page. TRUE: displays the Log in WIth button on the login page.  FALSE: does not display the Log in With button on the login page.\n"
                },
                "saml2ForceAuthn": {
                    "type": "boolean",
                    "description": "The Boolean indicating whether users, during the initial authentication flow, are forced to authenticate again to access Snowflake. When set to TRUE, Snowflake sets the ForceAuthn SAML parameter to TRUE in the outgoing request from Snowflake to the identity provider. TRUE: forces users to authenticate again to access Snowflake, even if a valid session with the identity provider exists. FALSE: does not force users to authenticate again to access Snowflake.\n"
                },
                "saml2Issuer": {
                    "type": "string",
                    "description": "The string containing the IdP EntityID / Issuer.\n"
                },
                "saml2PostLogoutRedirectUrl": {
                    "type": "string",
                    "description": "The endpoint to which Snowflake redirects users after clicking the Log Out button in the classic Snowflake web interface. Snowflake terminates the Snowflake session upon redirecting to the specified endpoint.\n"
                },
                "saml2Provider": {
                    "type": "string",
                    "description": "The string describing the IdP. One of the following: OKTA, ADFS, Custom.\n"
                },
                "saml2RequestedNameidFormat": {
                    "type": "string",
                    "description": "The SAML NameID format allows Snowflake to set an expectation of the identifying attribute of the user (i.e. SAML Subject) in the SAML assertion from the IdP to ensure a valid authentication to Snowflake. If a value is not specified, Snowflake sends the urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress value in the authentication request to the IdP. NameID must be one of the following values: urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified, urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress, urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName, urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName, urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos, urn:oasis:names:tc:SAML:2.0:nameid-format:persistent, urn:oasis:names:tc:SAML:2.0:nameid-format:transient .\n"
                },
                "saml2SignRequest": {
                    "type": "boolean",
                    "description": "The Boolean indicating whether SAML requests are signed. TRUE: allows SAML requests to be signed. FALSE: does not allow SAML requests to be signed.\n"
                },
                "saml2SnowflakeAcsUrl": {
                    "type": "string",
                    "description": "The string containing the Snowflake Assertion Consumer Service URL to which the IdP will send its SAML authentication response back to Snowflake. This property will be set in the SAML authentication request generated by Snowflake when initiating a SAML SSO operation with the IdP. If an incorrect value is specified, Snowflake returns an error message indicating the acceptable values to use. Default: https://\\n\\n.\\n\\n.snowflakecomputing.com/fed/login\n"
                },
                "saml2SnowflakeIssuerUrl": {
                    "type": "string",
                    "description": "The string containing the EntityID / Issuer for the Snowflake service provider. If an incorrect value is specified, Snowflake returns an error message indicating the acceptable values to use.\n"
                },
                "saml2SnowflakeX509Cert": {
                    "type": "string",
                    "description": "The Base64 encoded self-signed certificate generated by Snowflake for use with Encrypting SAML Assertions and Signed SAML Requests. You must have at least one of these features (encrypted SAML assertions or signed SAML responses) enabled in your Snowflake account to access the certificate value.\n"
                },
                "saml2SpInitiatedLoginPageLabel": {
                    "type": "string",
                    "description": "The string containing the label to display after the Log In With button on the login page.\n"
                },
                "saml2SsoUrl": {
                    "type": "string",
                    "description": "The string containing the IdP SSO URL, where the user should be redirected by Snowflake (the Service Provider) with a SAML AuthnRequest message.\n"
                },
                "saml2X509Cert": {
                    "type": "string",
                    "description": "The Base64 encoded IdP signing certificate on a single line without the leading -----BEGIN CERTIFICATE----- and ending -----END CERTIFICATE----- markers.\n"
                }
            },
            "requiredInputs": [
                "saml2Issuer",
                "saml2Provider",
                "saml2SsoUrl",
                "saml2X509Cert"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SamlIntegration resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the SAML integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies whether this security integration is enabled or disabled.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the SAML2 integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "saml2DigestMethodsUsed": {
                        "type": "string"
                    },
                    "saml2EnableSpInitiated": {
                        "type": "boolean",
                        "description": "The Boolean indicating if the Log In With button will be shown on the login page. TRUE: displays the Log in WIth button on the login page.  FALSE: does not display the Log in With button on the login page.\n"
                    },
                    "saml2ForceAuthn": {
                        "type": "boolean",
                        "description": "The Boolean indicating whether users, during the initial authentication flow, are forced to authenticate again to access Snowflake. When set to TRUE, Snowflake sets the ForceAuthn SAML parameter to TRUE in the outgoing request from Snowflake to the identity provider. TRUE: forces users to authenticate again to access Snowflake, even if a valid session with the identity provider exists. FALSE: does not force users to authenticate again to access Snowflake.\n"
                    },
                    "saml2Issuer": {
                        "type": "string",
                        "description": "The string containing the IdP EntityID / Issuer.\n"
                    },
                    "saml2PostLogoutRedirectUrl": {
                        "type": "string",
                        "description": "The endpoint to which Snowflake redirects users after clicking the Log Out button in the classic Snowflake web interface. Snowflake terminates the Snowflake session upon redirecting to the specified endpoint.\n"
                    },
                    "saml2Provider": {
                        "type": "string",
                        "description": "The string describing the IdP. One of the following: OKTA, ADFS, Custom.\n"
                    },
                    "saml2RequestedNameidFormat": {
                        "type": "string",
                        "description": "The SAML NameID format allows Snowflake to set an expectation of the identifying attribute of the user (i.e. SAML Subject) in the SAML assertion from the IdP to ensure a valid authentication to Snowflake. If a value is not specified, Snowflake sends the urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress value in the authentication request to the IdP. NameID must be one of the following values: urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified, urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress, urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName, urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName, urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos, urn:oasis:names:tc:SAML:2.0:nameid-format:persistent, urn:oasis:names:tc:SAML:2.0:nameid-format:transient .\n"
                    },
                    "saml2SignRequest": {
                        "type": "boolean",
                        "description": "The Boolean indicating whether SAML requests are signed. TRUE: allows SAML requests to be signed. FALSE: does not allow SAML requests to be signed.\n"
                    },
                    "saml2SignatureMethodsUsed": {
                        "type": "string"
                    },
                    "saml2SnowflakeAcsUrl": {
                        "type": "string",
                        "description": "The string containing the Snowflake Assertion Consumer Service URL to which the IdP will send its SAML authentication response back to Snowflake. This property will be set in the SAML authentication request generated by Snowflake when initiating a SAML SSO operation with the IdP. If an incorrect value is specified, Snowflake returns an error message indicating the acceptable values to use. Default: https://\\n\\n.\\n\\n.snowflakecomputing.com/fed/login\n"
                    },
                    "saml2SnowflakeIssuerUrl": {
                        "type": "string",
                        "description": "The string containing the EntityID / Issuer for the Snowflake service provider. If an incorrect value is specified, Snowflake returns an error message indicating the acceptable values to use.\n"
                    },
                    "saml2SnowflakeMetadata": {
                        "type": "string",
                        "description": "Metadata created by Snowflake to provide to SAML2 provider.\n"
                    },
                    "saml2SnowflakeX509Cert": {
                        "type": "string",
                        "description": "The Base64 encoded self-signed certificate generated by Snowflake for use with Encrypting SAML Assertions and Signed SAML Requests. You must have at least one of these features (encrypted SAML assertions or signed SAML responses) enabled in your Snowflake account to access the certificate value.\n"
                    },
                    "saml2SpInitiatedLoginPageLabel": {
                        "type": "string",
                        "description": "The string containing the label to display after the Log In With button on the login page.\n"
                    },
                    "saml2SsoUrl": {
                        "type": "string",
                        "description": "The string containing the IdP SSO URL, where the user should be redirected by Snowflake (the Service Provider) with a SAML AuthnRequest message.\n"
                    },
                    "saml2X509Cert": {
                        "type": "string",
                        "description": "The Base64 encoded IdP signing certificate on a single line without the leading -----BEGIN CERTIFICATE----- and ending -----END CERTIFICATE----- markers.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/schema:Schema": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst schema = new snowflake.Schema(\"schema\", {\n    comment: \"A schema.\",\n    dataRetentionDays: 1,\n    database: \"database\",\n    isManaged: false,\n    isTransient: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nschema = snowflake.Schema(\"schema\",\n    comment=\"A schema.\",\n    data_retention_days=1,\n    database=\"database\",\n    is_managed=False,\n    is_transient=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var schema = new Snowflake.Schema(\"schema\", new()\n    {\n        Comment = \"A schema.\",\n        DataRetentionDays = 1,\n        Database = \"database\",\n        IsManaged = false,\n        IsTransient = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewSchema(ctx, \"schema\", \u0026snowflake.SchemaArgs{\n\t\t\tComment:           pulumi.String(\"A schema.\"),\n\t\t\tDataRetentionDays: pulumi.Int(1),\n\t\t\tDatabase:          pulumi.String(\"database\"),\n\t\t\tIsManaged:         pulumi.Bool(false),\n\t\t\tIsTransient:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Schema;\nimport com.pulumi.snowflake.SchemaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .comment(\"A schema.\")\n            .dataRetentionDays(1)\n            .database(\"database\")\n            .isManaged(false)\n            .isTransient(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  schema:\n    type: snowflake:Schema\n    properties:\n      comment: A schema.\n      dataRetentionDays: 1\n      database: database\n      isManaged: false\n      isTransient: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is dbName | schemaName\n\n```sh\n $ pulumi import snowflake:index/schema:Schema example 'dbName|schemaName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the schema.\n"
                },
                "dataRetentionDays": {
                    "type": "integer",
                    "description": "Specifies the number of days for which Time Travel actions (CLONE and UNDROP) can be performed on the schema, as well as specifying the default Time Travel retention time for all tables created in the schema.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "isManaged": {
                    "type": "boolean",
                    "description": "Specifies a managed schema. Managed access schemas centralize privilege management with the schema owner.\n"
                },
                "isTransient": {
                    "type": "boolean",
                    "description": "Specifies a schema as transient. Transient schemas do not have a Fail-safe period so they do not incur additional storage costs once they leave Time Travel; however, this means they are also not protected by Fail-safe in the event of a data loss.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/SchemaTag:SchemaTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "required": [
                "database",
                "name"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the schema.\n"
                },
                "dataRetentionDays": {
                    "type": "integer",
                    "description": "Specifies the number of days for which Time Travel actions (CLONE and UNDROP) can be performed on the schema, as well as specifying the default Time Travel retention time for all tables created in the schema.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "isManaged": {
                    "type": "boolean",
                    "description": "Specifies a managed schema. Managed access schemas centralize privilege management with the schema owner.\n"
                },
                "isTransient": {
                    "type": "boolean",
                    "description": "Specifies a schema as transient. Transient schemas do not have a Fail-safe period so they do not incur additional storage costs once they leave Time Travel; however, this means they are also not protected by Fail-safe in the event of a data loss.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/SchemaTag:SchemaTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "requiredInputs": [
                "database"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Schema resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the schema.\n"
                    },
                    "dataRetentionDays": {
                        "type": "integer",
                        "description": "Specifies the number of days for which Time Travel actions (CLONE and UNDROP) can be performed on the schema, as well as specifying the default Time Travel retention time for all tables created in the schema.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "isManaged": {
                        "type": "boolean",
                        "description": "Specifies a managed schema. Managed access schemas centralize privilege management with the schema owner.\n"
                    },
                    "isTransient": {
                        "type": "boolean",
                        "description": "Specifies a schema as transient. Transient schemas do not have a Fail-safe period so they do not incur additional storage costs once they leave Time Travel; however, this means they are also not protected by Fail-safe in the event of a data loss.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Tag name, e.g. department.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/SchemaTag:SchemaTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n",
                        "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/schemaGrant:SchemaGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.SchemaGrant(\"grant\", {\n    databaseName: \"database\",\n    onFuture: false,\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.SchemaGrant(\"grant\",\n    database_name=\"database\",\n    on_future=False,\n    privilege=\"USAGE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.SchemaGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        OnFuture = false,\n        Privilege = \"USAGE\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        Shares = new[]\n        {\n            \"share1\",\n            \"share2\",\n        },\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewSchemaGrant(ctx, \"grant\", \u0026snowflake.SchemaGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"USAGE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SchemaGrant;\nimport com.pulumi.snowflake.SchemaGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new SchemaGrant(\"grant\", SchemaGrantArgs.builder()        \n            .databaseName(\"database\")\n            .onFuture(false)\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:SchemaGrant\n    properties:\n      databaseName: database\n      onFuture: false\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|privilege|with_grant_option|on_future|on_all|roles|shares\n\n```sh\n $ pulumi import snowflake:index/schemaGrant:SchemaGrant example \"MY_DATABASE|MY_SCHEMA|USAGE|false|false|false|role1,role2|share1,share2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the schema on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true, apply this grant on all schemas in the given database. The schema*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true, apply this grant on all future schemas in the given database. The schema*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future schema. Note that if \"OWNERSHIP\" is specified, ensure that the role that\nterraform is using is granted access. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on*future and on*all are unset).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the schema on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true, apply this grant on all schemas in the given database. The schema*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true, apply this grant on all future schemas in the given database. The schema*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future schema. Note that if \"OWNERSHIP\" is specified, ensure that the role that\nterraform is using is granted access. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on*future and on*all are unset).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SchemaGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the schema on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true, apply this grant on all schemas in the given database. The schema*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true, apply this grant on all future schemas in the given database. The schema*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future schema. Note that if \"OWNERSHIP\" is specified, ensure that the role that\nterraform is using is granted access. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on*future and on*all are unset).\n"
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/scimIntegration:ScimIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst aad = new snowflake.ScimIntegration(\"aad\", {\n    networkPolicy: \"AAD_NETWORK_POLICY\",\n    provisionerRole: \"AAD_PROVISIONER\",\n    scimClient: \"AZURE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\naad = snowflake.ScimIntegration(\"aad\",\n    network_policy=\"AAD_NETWORK_POLICY\",\n    provisioner_role=\"AAD_PROVISIONER\",\n    scim_client=\"AZURE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var aad = new Snowflake.ScimIntegration(\"aad\", new()\n    {\n        NetworkPolicy = \"AAD_NETWORK_POLICY\",\n        ProvisionerRole = \"AAD_PROVISIONER\",\n        ScimClient = \"AZURE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewScimIntegration(ctx, \"aad\", \u0026snowflake.ScimIntegrationArgs{\n\t\t\tNetworkPolicy:   pulumi.String(\"AAD_NETWORK_POLICY\"),\n\t\t\tProvisionerRole: pulumi.String(\"AAD_PROVISIONER\"),\n\t\t\tScimClient:      pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ScimIntegration;\nimport com.pulumi.snowflake.ScimIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aad = new ScimIntegration(\"aad\", ScimIntegrationArgs.builder()        \n            .networkPolicy(\"AAD_NETWORK_POLICY\")\n            .provisionerRole(\"AAD_PROVISIONER\")\n            .scimClient(\"AZURE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aad:\n    type: snowflake:ScimIntegration\n    properties:\n      networkPolicy: AAD_NETWORK_POLICY\n      provisionerRole: AAD_PROVISIONER\n      scimClient: AZURE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/scimIntegration:ScimIntegration example name\n```\n\n ",
            "properties": {
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the SCIM integration was created.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the SCIM integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n"
                },
                "networkPolicy": {
                    "type": "string",
                    "description": "Specifies an existing network policy active for your account. The network policy restricts the list of user IP addresses when exchanging an authorization code for an access or refresh token and when using a refresh token to obtain a new access token. If this parameter is not set, the network policy for the account (if any) is used instead.\n"
                },
                "provisionerRole": {
                    "type": "string",
                    "description": "Specify the SCIM role in Snowflake that owns any users and roles that are imported from the identity provider into Snowflake using SCIM.\n"
                },
                "scimClient": {
                    "type": "string",
                    "description": "Specifies the client type for the scim integration\n"
                }
            },
            "required": [
                "createdOn",
                "name",
                "provisionerRole",
                "scimClient"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the SCIM integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n",
                    "willReplaceOnChanges": true
                },
                "networkPolicy": {
                    "type": "string",
                    "description": "Specifies an existing network policy active for your account. The network policy restricts the list of user IP addresses when exchanging an authorization code for an access or refresh token and when using a refresh token to obtain a new access token. If this parameter is not set, the network policy for the account (if any) is used instead.\n"
                },
                "provisionerRole": {
                    "type": "string",
                    "description": "Specify the SCIM role in Snowflake that owns any users and roles that are imported from the identity provider into Snowflake using SCIM.\n"
                },
                "scimClient": {
                    "type": "string",
                    "description": "Specifies the client type for the scim integration\n"
                }
            },
            "requiredInputs": [
                "provisionerRole",
                "scimClient"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ScimIntegration resources.\n",
                "properties": {
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the SCIM integration was created.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the SCIM integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkPolicy": {
                        "type": "string",
                        "description": "Specifies an existing network policy active for your account. The network policy restricts the list of user IP addresses when exchanging an authorization code for an access or refresh token and when using a refresh token to obtain a new access token. If this parameter is not set, the network policy for the account (if any) is used instead.\n"
                    },
                    "provisionerRole": {
                        "type": "string",
                        "description": "Specify the SCIM role in Snowflake that owns any users and roles that are imported from the identity provider into Snowflake using SCIM.\n"
                    },
                    "scimClient": {
                        "type": "string",
                        "description": "Specifies the client type for the scim integration\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/sequence:Sequence": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst database = new snowflake.Database(\"database\", {});\nconst testSchema = new snowflake.Schema(\"testSchema\", {database: snowflake_database.test_database.name});\nconst testSequence = new snowflake.Sequence(\"testSequence\", {\n    database: snowflake_database.test_database.name,\n    schema: testSchema.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndatabase = snowflake.Database(\"database\")\ntest_schema = snowflake.Schema(\"testSchema\", database=snowflake_database[\"test_database\"][\"name\"])\ntest_sequence = snowflake.Sequence(\"testSequence\",\n    database=snowflake_database[\"test_database\"][\"name\"],\n    schema=test_schema.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var database = new Snowflake.Database(\"database\");\n\n    var testSchema = new Snowflake.Schema(\"testSchema\", new()\n    {\n        Database = snowflake_database.Test_database.Name,\n    });\n\n    var testSequence = new Snowflake.Sequence(\"testSequence\", new()\n    {\n        Database = snowflake_database.Test_database.Name,\n        Schema = testSchema.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewDatabase(ctx, \"database\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestSchema, err := snowflake.NewSchema(ctx, \"testSchema\", \u0026snowflake.SchemaArgs{\n\t\t\tDatabase: pulumi.Any(snowflake_database.Test_database.Name),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewSequence(ctx, \"testSequence\", \u0026snowflake.SequenceArgs{\n\t\t\tDatabase: pulumi.Any(snowflake_database.Test_database.Name),\n\t\t\tSchema:   testSchema.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.Schema;\nimport com.pulumi.snowflake.SchemaArgs;\nimport com.pulumi.snowflake.Sequence;\nimport com.pulumi.snowflake.SequenceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var database = new Database(\"database\");\n\n        var testSchema = new Schema(\"testSchema\", SchemaArgs.builder()        \n            .database(snowflake_database.test_database().name())\n            .build());\n\n        var testSequence = new Sequence(\"testSequence\", SequenceArgs.builder()        \n            .database(snowflake_database.test_database().name())\n            .schema(testSchema.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  database:\n    type: snowflake:Database\n  testSchema:\n    type: snowflake:Schema\n    properties:\n      database: ${snowflake_database.test_database.name}\n  testSequence:\n    type: snowflake:Sequence\n    properties:\n      database: ${snowflake_database.test_database.name}\n      schema: ${testSchema.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | sequence name\n\n```sh\n $ pulumi import snowflake:index/sequence:Sequence example 'dbName|schemaName|sequenceName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the sequence.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the sequence. Don't use the | character.\n"
                },
                "fullyQualifiedName": {
                    "type": "string",
                    "description": "The fully qualified name of the sequence.\n"
                },
                "increment": {
                    "type": "integer",
                    "description": "The amount the sequence will increase by each time it is used\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name for the sequence.\n"
                },
                "nextValue": {
                    "type": "integer",
                    "description": "The next value the sequence will provide.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the sequence. Don't use the | character.\n"
                }
            },
            "required": [
                "database",
                "fullyQualifiedName",
                "name",
                "nextValue",
                "schema"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the sequence.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the sequence. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                },
                "increment": {
                    "type": "integer",
                    "description": "The amount the sequence will increase by each time it is used\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name for the sequence.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the sequence. Don't use the | character.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Sequence resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the sequence.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the sequence. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    },
                    "fullyQualifiedName": {
                        "type": "string",
                        "description": "The fully qualified name of the sequence.\n"
                    },
                    "increment": {
                        "type": "integer",
                        "description": "The amount the sequence will increase by each time it is used\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name for the sequence.\n",
                        "willReplaceOnChanges": true
                    },
                    "nextValue": {
                        "type": "integer",
                        "description": "The next value the sequence will provide.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the sequence. Don't use the | character.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/sequenceGrant:SequenceGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.SequenceGrant(\"grant\", {\n    databaseName: \"database\",\n    onFuture: false,\n    privilege: \"SELECT\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    sequenceName: \"sequence\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.SequenceGrant(\"grant\",\n    database_name=\"database\",\n    on_future=False,\n    privilege=\"SELECT\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    sequence_name=\"sequence\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.SequenceGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        OnFuture = false,\n        Privilege = \"SELECT\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        SequenceName = \"sequence\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewSequenceGrant(ctx, \"grant\", \u0026snowflake.SequenceGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"SELECT\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tSequenceName:    pulumi.String(\"sequence\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SequenceGrant;\nimport com.pulumi.snowflake.SequenceGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new SequenceGrant(\"grant\", SequenceGrantArgs.builder()        \n            .databaseName(\"database\")\n            .onFuture(false)\n            .privilege(\"SELECT\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .sequenceName(\"sequence\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:SequenceGrant\n    properties:\n      databaseName: database\n      onFuture: false\n      privilege: SELECT\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      sequenceName: sequence\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|sequence_name|privilege|with_grant_option|on_future|roles\n\n```sh\n $ pulumi import snowflake:index/sequenceGrant:SequenceGrant example \"MY_DATABASE|MY_SCHEMA|MY_SEQUENCE|USAGE|false|false|role1,role2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future sequences on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all sequences in the given schema. When this is true and no schema*name is provided apply this grant on all sequences in the given database. The sequence*name field must be unset in order to use on*all. Cannot be used together with on_future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future sequences in the given schema. When this is true and no schema*name is provided apply this grant on all future sequences in the given database. The sequence*name field must be unset in order to use on*future. Cannot be used together with on_all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future sequence. To grant all privileges, use the value `ALL PRIVILEGES`\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future sequences on which to grant privileges.\n"
                },
                "sequenceName": {
                    "type": "string",
                    "description": "The name of the sequence on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "roles"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future sequences on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all sequences in the given schema. When this is true and no schema*name is provided apply this grant on all sequences in the given database. The sequence*name field must be unset in order to use on*all. Cannot be used together with on_future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future sequences in the given schema. When this is true and no schema*name is provided apply this grant on all future sequences in the given database. The sequence*name field must be unset in order to use on*future. Cannot be used together with on_all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future sequence. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future sequences on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "sequenceName": {
                    "type": "string",
                    "description": "The name of the sequence on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SequenceGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future sequences on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all sequences in the given schema. When this is true and no schema*name is provided apply this grant on all sequences in the given database. The sequence*name field must be unset in order to use on*all. Cannot be used together with on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future sequences in the given schema. When this is true and no schema*name is provided apply this grant on all future sequences in the given database. The sequence*name field must be unset in order to use on*future. Cannot be used together with on_all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future sequence. To grant all privileges, use the value `ALL PRIVILEGES`\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future sequences on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "sequenceName": {
                        "type": "string",
                        "description": "The name of the sequence on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/sessionParameter:SessionParameter": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst sessionParameter = new snowflake.SessionParameter(\"sessionParameter\", {\n    key: \"AUTOCOMMIT\",\n    user: \"TEST_USER\",\n    value: \"false\",\n});\nconst s2 = new snowflake.SessionParameter(\"s2\", {\n    key: \"BINARY_OUTPUT_FORMAT\",\n    onAccount: true,\n    value: \"BASE64\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nsession_parameter = snowflake.SessionParameter(\"sessionParameter\",\n    key=\"AUTOCOMMIT\",\n    user=\"TEST_USER\",\n    value=\"false\")\ns2 = snowflake.SessionParameter(\"s2\",\n    key=\"BINARY_OUTPUT_FORMAT\",\n    on_account=True,\n    value=\"BASE64\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sessionParameter = new Snowflake.SessionParameter(\"sessionParameter\", new()\n    {\n        Key = \"AUTOCOMMIT\",\n        User = \"TEST_USER\",\n        Value = \"false\",\n    });\n\n    var s2 = new Snowflake.SessionParameter(\"s2\", new()\n    {\n        Key = \"BINARY_OUTPUT_FORMAT\",\n        OnAccount = true,\n        Value = \"BASE64\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewSessionParameter(ctx, \"sessionParameter\", \u0026snowflake.SessionParameterArgs{\n\t\t\tKey:   pulumi.String(\"AUTOCOMMIT\"),\n\t\t\tUser:  pulumi.String(\"TEST_USER\"),\n\t\t\tValue: pulumi.String(\"false\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewSessionParameter(ctx, \"s2\", \u0026snowflake.SessionParameterArgs{\n\t\t\tKey:       pulumi.String(\"BINARY_OUTPUT_FORMAT\"),\n\t\t\tOnAccount: pulumi.Bool(true),\n\t\t\tValue:     pulumi.String(\"BASE64\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SessionParameter;\nimport com.pulumi.snowflake.SessionParameterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sessionParameter = new SessionParameter(\"sessionParameter\", SessionParameterArgs.builder()        \n            .key(\"AUTOCOMMIT\")\n            .user(\"TEST_USER\")\n            .value(\"false\")\n            .build());\n\n        var s2 = new SessionParameter(\"s2\", SessionParameterArgs.builder()        \n            .key(\"BINARY_OUTPUT_FORMAT\")\n            .onAccount(true)\n            .value(\"BASE64\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  sessionParameter:\n    type: snowflake:SessionParameter\n    properties:\n      key: AUTOCOMMIT\n      user: TEST_USER\n      value: 'false'\n  s2:\n    type: snowflake:SessionParameter\n    properties:\n      key: BINARY_OUTPUT_FORMAT\n      onAccount: true\n      value: BASE64\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/sessionParameter:SessionParameter s \u003cparameter_name\u003e\n```\n\n ",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Name of session parameter. Valid values are those in [session parameters](https://docs.snowflake.com/en/sql-reference/parameters.html#session-parameters).\n"
                },
                "onAccount": {
                    "type": "boolean",
                    "description": "If true, the session parameter will be set on the account level.\n"
                },
                "user": {
                    "type": "string",
                    "description": "The user to set the session parameter for. Required if on_account is false\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of session parameter, as a string. Constraints are the same as those for the parameters in Snowflake documentation.\n"
                }
            },
            "required": [
                "key",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "Name of session parameter. Valid values are those in [session parameters](https://docs.snowflake.com/en/sql-reference/parameters.html#session-parameters).\n",
                    "willReplaceOnChanges": true
                },
                "onAccount": {
                    "type": "boolean",
                    "description": "If true, the session parameter will be set on the account level.\n"
                },
                "user": {
                    "type": "string",
                    "description": "The user to set the session parameter for. Required if on_account is false\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of session parameter, as a string. Constraints are the same as those for the parameters in Snowflake documentation.\n"
                }
            },
            "requiredInputs": [
                "key",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SessionParameter resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Name of session parameter. Valid values are those in [session parameters](https://docs.snowflake.com/en/sql-reference/parameters.html#session-parameters).\n",
                        "willReplaceOnChanges": true
                    },
                    "onAccount": {
                        "type": "boolean",
                        "description": "If true, the session parameter will be set on the account level.\n"
                    },
                    "user": {
                        "type": "string",
                        "description": "The user to set the session parameter for. Required if on_account is false\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "Value of session parameter, as a string. Constraints are the same as those for the parameters in Snowflake documentation.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/share:Share": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst test = new snowflake.Share(\"test\", {\n    accounts: [\"organizationName.accountName\"],\n    comment: \"cool comment\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntest = snowflake.Share(\"test\",\n    accounts=[\"organizationName.accountName\"],\n    comment=\"cool comment\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Snowflake.Share(\"test\", new()\n    {\n        Accounts = new[]\n        {\n            \"organizationName.accountName\",\n        },\n        Comment = \"cool comment\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewShare(ctx, \"test\", \u0026snowflake.ShareArgs{\n\t\t\tAccounts: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"organizationName.accountName\"),\n\t\t\t},\n\t\t\tComment: pulumi.String(\"cool comment\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Share;\nimport com.pulumi.snowflake.ShareArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Share(\"test\", ShareArgs.builder()        \n            .accounts(\"organizationName.accountName\")\n            .comment(\"cool comment\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: snowflake:Share\n    properties:\n      accounts:\n        - organizationName.accountName\n      comment: cool comment\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/share:Share example name\n```\n\n ",
            "properties": {
                "accounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of accounts to be added to the share. Values should not be the account locator, but in the form of 'organization*name.account*name\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the managed account.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the share; must be unique for the account in which the share is created.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "accounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of accounts to be added to the share. Values should not be the account locator, but in the form of 'organization*name.account*name\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the managed account.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the share; must be unique for the account in which the share is created.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Share resources.\n",
                "properties": {
                    "accounts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of accounts to be added to the share. Values should not be the account locator, but in the form of 'organization*name.account*name\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the managed account.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the share; must be unique for the account in which the share is created.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/stage:Stage": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst exampleStage = new snowflake.Stage(\"exampleStage\", {\n    url: \"s3://com.example.bucket/prefix\",\n    database: \"EXAMPLE_DB\",\n    schema: \"EXAMPLE_SCHEMA\",\n    credentials: `AWS_KEY_ID='${_var.example_aws_key_id}' AWS_SECRET_KEY='${_var.example_aws_secret_key}'`,\n});\nconst grantExampleStage = new snowflake.StageGrant(\"grantExampleStage\", {\n    databaseName: exampleStage.database,\n    schemaName: exampleStage.schema,\n    roles: [\"LOADER\"],\n    privilege: \"OWNERSHIP\",\n    stageName: exampleStage.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexample_stage = snowflake.Stage(\"exampleStage\",\n    url=\"s3://com.example.bucket/prefix\",\n    database=\"EXAMPLE_DB\",\n    schema=\"EXAMPLE_SCHEMA\",\n    credentials=f\"AWS_KEY_ID='{var['example_aws_key_id']}' AWS_SECRET_KEY='{var['example_aws_secret_key']}'\")\ngrant_example_stage = snowflake.StageGrant(\"grantExampleStage\",\n    database_name=example_stage.database,\n    schema_name=example_stage.schema,\n    roles=[\"LOADER\"],\n    privilege=\"OWNERSHIP\",\n    stage_name=example_stage.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleStage = new Snowflake.Stage(\"exampleStage\", new()\n    {\n        Url = \"s3://com.example.bucket/prefix\",\n        Database = \"EXAMPLE_DB\",\n        Schema = \"EXAMPLE_SCHEMA\",\n        Credentials = $\"AWS_KEY_ID='{@var.Example_aws_key_id}' AWS_SECRET_KEY='{@var.Example_aws_secret_key}'\",\n    });\n\n    var grantExampleStage = new Snowflake.StageGrant(\"grantExampleStage\", new()\n    {\n        DatabaseName = exampleStage.Database,\n        SchemaName = exampleStage.Schema,\n        Roles = new[]\n        {\n            \"LOADER\",\n        },\n        Privilege = \"OWNERSHIP\",\n        StageName = exampleStage.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleStage, err := snowflake.NewStage(ctx, \"exampleStage\", \u0026snowflake.StageArgs{\n\t\t\tUrl:         pulumi.String(\"s3://com.example.bucket/prefix\"),\n\t\t\tDatabase:    pulumi.String(\"EXAMPLE_DB\"),\n\t\t\tSchema:      pulumi.String(\"EXAMPLE_SCHEMA\"),\n\t\t\tCredentials: pulumi.String(fmt.Sprintf(\"AWS_KEY_ID='%v' AWS_SECRET_KEY='%v'\", _var.Example_aws_key_id, _var.Example_aws_secret_key)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewStageGrant(ctx, \"grantExampleStage\", \u0026snowflake.StageGrantArgs{\n\t\t\tDatabaseName: exampleStage.Database,\n\t\t\tSchemaName:   exampleStage.Schema,\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"LOADER\"),\n\t\t\t},\n\t\t\tPrivilege: pulumi.String(\"OWNERSHIP\"),\n\t\t\tStageName: exampleStage.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Stage;\nimport com.pulumi.snowflake.StageArgs;\nimport com.pulumi.snowflake.StageGrant;\nimport com.pulumi.snowflake.StageGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleStage = new Stage(\"exampleStage\", StageArgs.builder()        \n            .url(\"s3://com.example.bucket/prefix\")\n            .database(\"EXAMPLE_DB\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .credentials(String.format(\"AWS_KEY_ID='%s' AWS_SECRET_KEY='%s'\", var_.example_aws_key_id(),var_.example_aws_secret_key()))\n            .build());\n\n        var grantExampleStage = new StageGrant(\"grantExampleStage\", StageGrantArgs.builder()        \n            .databaseName(exampleStage.database())\n            .schemaName(exampleStage.schema())\n            .roles(\"LOADER\")\n            .privilege(\"OWNERSHIP\")\n            .stageName(exampleStage.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleStage:\n    type: snowflake:Stage\n    properties:\n      url: s3://com.example.bucket/prefix\n      database: EXAMPLE_DB\n      schema: EXAMPLE_SCHEMA\n      credentials: AWS_KEY_ID='${var.example_aws_key_id}' AWS_SECRET_KEY='${var.example_aws_secret_key}'\n  grantExampleStage:\n    type: snowflake:StageGrant\n    properties:\n      databaseName: ${exampleStage.database}\n      schemaName: ${exampleStage.schema}\n      roles:\n        - LOADER\n      privilege: OWNERSHIP\n      stageName: ${exampleStage.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | stage name\n\n```sh\n $ pulumi import snowflake:index/stage:Stage example 'dbName|schemaName|stageName'\n```\n\n ",
            "properties": {
                "awsExternalId": {
                    "type": "string"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the stage.\n"
                },
                "copyOptions": {
                    "type": "string",
                    "description": "Specifies the copy options for the stage.\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "Specifies the credentials for the stage.\n",
                    "secret": true
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "directory": {
                    "type": "string",
                    "description": "Specifies the directory settings for the stage.\n"
                },
                "encryption": {
                    "type": "string",
                    "description": "Specifies the encryption settings for the stage.\n"
                },
                "fileFormat": {
                    "type": "string",
                    "description": "Specifies the file format for the stage.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "snowflakeIamUser": {
                    "type": "string"
                },
                "storageIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the storage integration used to delegate authentication responsibility for external cloud storage to a Snowflake identity and access management (IAM) entity.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/StageTag:StageTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                },
                "url": {
                    "type": "string",
                    "description": "Specifies the URL for the stage.\n"
                }
            },
            "required": [
                "awsExternalId",
                "database",
                "name",
                "schema",
                "snowflakeIamUser"
            ],
            "inputProperties": {
                "awsExternalId": {
                    "type": "string"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the stage.\n"
                },
                "copyOptions": {
                    "type": "string",
                    "description": "Specifies the copy options for the stage.\n"
                },
                "credentials": {
                    "type": "string",
                    "description": "Specifies the credentials for the stage.\n",
                    "secret": true
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "directory": {
                    "type": "string",
                    "description": "Specifies the directory settings for the stage.\n",
                    "willReplaceOnChanges": true
                },
                "encryption": {
                    "type": "string",
                    "description": "Specifies the encryption settings for the stage.\n"
                },
                "fileFormat": {
                    "type": "string",
                    "description": "Specifies the file format for the stage.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "snowflakeIamUser": {
                    "type": "string"
                },
                "storageIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the storage integration used to delegate authentication responsibility for external cloud storage to a Snowflake identity and access management (IAM) entity.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/StageTag:StageTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                },
                "url": {
                    "type": "string",
                    "description": "Specifies the URL for the stage.\n"
                }
            },
            "requiredInputs": [
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Stage resources.\n",
                "properties": {
                    "awsExternalId": {
                        "type": "string"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the stage.\n"
                    },
                    "copyOptions": {
                        "type": "string",
                        "description": "Specifies the copy options for the stage.\n"
                    },
                    "credentials": {
                        "type": "string",
                        "description": "Specifies the credentials for the stage.\n",
                        "secret": true
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "directory": {
                        "type": "string",
                        "description": "Specifies the directory settings for the stage.\n",
                        "willReplaceOnChanges": true
                    },
                    "encryption": {
                        "type": "string",
                        "description": "Specifies the encryption settings for the stage.\n"
                    },
                    "fileFormat": {
                        "type": "string",
                        "description": "Specifies the file format for the stage.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Tag name, e.g. department.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "Name of the schema that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "snowflakeIamUser": {
                        "type": "string"
                    },
                    "storageIntegration": {
                        "type": "string",
                        "description": "Specifies the name of the storage integration used to delegate authentication responsibility for external cloud storage to a Snowflake identity and access management (IAM) entity.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/StageTag:StageTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n",
                        "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                    },
                    "url": {
                        "type": "string",
                        "description": "Specifies the URL for the stage.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/stageGrant:StageGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.StageGrant(\"grant\", {\n    databaseName: \"database\",\n    onFuture: false,\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    stageName: \"stage\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.StageGrant(\"grant\",\n    database_name=\"database\",\n    on_future=False,\n    privilege=\"USAGE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    stage_name=\"stage\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.StageGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        OnFuture = false,\n        Privilege = \"USAGE\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        StageName = \"stage\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewStageGrant(ctx, \"grant\", \u0026snowflake.StageGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"USAGE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tStageName:       pulumi.String(\"stage\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.StageGrant;\nimport com.pulumi.snowflake.StageGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new StageGrant(\"grant\", StageGrantArgs.builder()        \n            .databaseName(\"database\")\n            .onFuture(false)\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .stageName(\"stage\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:StageGrant\n    properties:\n      databaseName: database\n      onFuture: false\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      stageName: stage\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|stage_name|privilege|with_grant_option|on_future|on_all|roles\n\n```sh\n $ pulumi import snowflake:index/stageGrant:StageGrant example \"MY_DATABASE|MY_SCHEMA|MY_STAGE|USAGE|false|false|false|role1,role2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current stage on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all stages in the given schema. When this is true and no schema*name is provided apply this grant on all stages in the given database. The stage*name field must be unset in order to use on*all. Cannot be used together with on_future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future stages in the given schema. When this is true and no schema*name is provided apply this grant on all future stages in the given database. The stage*name field must be unset in order to use on*future. Cannot be used together with on_all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the stage. To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current stage on which to grant privileges.\n"
                },
                "stageName": {
                    "type": "string",
                    "description": "The name of the stage on which to grant privilege (only valid if on*future and on*all are false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "roles"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current stage on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all stages in the given schema. When this is true and no schema*name is provided apply this grant on all stages in the given database. The stage*name field must be unset in order to use on*all. Cannot be used together with on_future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future stages in the given schema. When this is true and no schema*name is provided apply this grant on all future stages in the given database. The stage*name field must be unset in order to use on*future. Cannot be used together with on_all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the stage. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current stage on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "stageName": {
                    "type": "string",
                    "description": "The name of the stage on which to grant privilege (only valid if on*future and on*all are false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StageGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current stage on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all stages in the given schema. When this is true and no schema*name is provided apply this grant on all stages in the given database. The stage*name field must be unset in order to use on*all. Cannot be used together with on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future stages in the given schema. When this is true and no schema*name is provided apply this grant on all future stages in the given database. The stage*name field must be unset in order to use on*future. Cannot be used together with on_all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the stage. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current stage on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "stageName": {
                        "type": "string",
                        "description": "The name of the stage on which to grant privilege (only valid if on*future and on*all are false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/storageIntegration:StorageIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.StorageIntegration;\nimport com.pulumi.snowflake.StorageIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var integration = new StorageIntegration(\"integration\", StorageIntegrationArgs.builder()        \n            .comment(\"A storage integration.\")\n            .enabled(true)\n            .storageAwsExternalId(\"...\")\n            .storageAwsIamUserArn(\"...\")\n            .storageAwsRoleArn(\"...\")\n            .storageProvider(\"S3\")\n            .type(\"EXTERNAL_STAGE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  integration:\n    type: snowflake:StorageIntegration\n    properties:\n      comment: A storage integration.\n      enabled: true\n      storageAwsExternalId: '...'\n      storageAwsIamUserArn: '...'\n      storageAwsRoleArn: '...'\n      storageProvider: S3\n      type: EXTERNAL_STAGE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/storageIntegration:StorageIntegration example name\n```\n\n ",
            "properties": {
                "azureConsentUrl": {
                    "type": "string",
                    "description": "The consent URL that is used to create an Azure Snowflake service principle inside your tenant.\n"
                },
                "azureMultiTenantAppName": {
                    "type": "string",
                    "description": "This is the name of the Snowflake client application created for your account.\n"
                },
                "azureTenantId": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "createdOn": {
                    "type": "string",
                    "description": "Date and time when the storage integration was created.\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "storageAllowedLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly limits external stages that use the integration to reference one or more storage locations.\n"
                },
                "storageAwsExternalId": {
                    "type": "string",
                    "description": "The external ID that Snowflake will use when assuming the AWS role.\n"
                },
                "storageAwsIamUserArn": {
                    "type": "string",
                    "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                },
                "storageAwsObjectAcl": {
                    "type": "string",
                    "description": "\"bucket-owner-full-control\" Enables support for AWS access control lists (ACLs) to grant the bucket owner full control.\n"
                },
                "storageAwsRoleArn": {
                    "type": "string"
                },
                "storageBlockedLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly prohibits external stages that use the integration from referencing one or more storage locations.\n"
                },
                "storageGcpServiceAccount": {
                    "type": "string",
                    "description": "This is the name of the Snowflake Google Service Account created for your account.\n"
                },
                "storageProvider": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "azureConsentUrl",
                "azureMultiTenantAppName",
                "createdOn",
                "name",
                "storageAllowedLocations",
                "storageAwsExternalId",
                "storageAwsIamUserArn",
                "storageGcpServiceAccount",
                "storageProvider"
            ],
            "inputProperties": {
                "azureTenantId": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "storageAllowedLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly limits external stages that use the integration to reference one or more storage locations.\n"
                },
                "storageAwsObjectAcl": {
                    "type": "string",
                    "description": "\"bucket-owner-full-control\" Enables support for AWS access control lists (ACLs) to grant the bucket owner full control.\n"
                },
                "storageAwsRoleArn": {
                    "type": "string"
                },
                "storageBlockedLocations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Explicitly prohibits external stages that use the integration from referencing one or more storage locations.\n"
                },
                "storageProvider": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "storageAllowedLocations",
                "storageProvider"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageIntegration resources.\n",
                "properties": {
                    "azureConsentUrl": {
                        "type": "string",
                        "description": "The consent URL that is used to create an Azure Snowflake service principle inside your tenant.\n"
                    },
                    "azureMultiTenantAppName": {
                        "type": "string",
                        "description": "This is the name of the Snowflake client application created for your account.\n"
                    },
                    "azureTenantId": {
                        "type": "string"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "Date and time when the storage integration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "storageAllowedLocations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Explicitly limits external stages that use the integration to reference one or more storage locations.\n"
                    },
                    "storageAwsExternalId": {
                        "type": "string",
                        "description": "The external ID that Snowflake will use when assuming the AWS role.\n"
                    },
                    "storageAwsIamUserArn": {
                        "type": "string",
                        "description": "The Snowflake user that will attempt to assume the AWS role.\n"
                    },
                    "storageAwsObjectAcl": {
                        "type": "string",
                        "description": "\"bucket-owner-full-control\" Enables support for AWS access control lists (ACLs) to grant the bucket owner full control.\n"
                    },
                    "storageAwsRoleArn": {
                        "type": "string"
                    },
                    "storageBlockedLocations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Explicitly prohibits external stages that use the integration from referencing one or more storage locations.\n"
                    },
                    "storageGcpServiceAccount": {
                        "type": "string",
                        "description": "This is the name of the Snowflake Google Service Account created for your account.\n"
                    },
                    "storageProvider": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/stream:Stream": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Stream;\nimport com.pulumi.snowflake.StreamArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var stream = new Stream(\"stream\", StreamArgs.builder()        \n            .appendOnly(false)\n            .comment(\"A stream.\")\n            .database(\"database\")\n            .insertOnly(false)\n            .onTable(\"table\")\n            .owner(\"role1\")\n            .schema(\"schema\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  stream:\n    type: snowflake:Stream\n    properties:\n      appendOnly: false\n      comment: A stream.\n      database: database\n      insertOnly: false\n      onTable: table\n      owner: role1\n      schema: schema\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | stream name\n\n```sh\n $ pulumi import snowflake:index/stream:Stream example 'dbName|schemaName|streamName'\n```\n\n ",
            "properties": {
                "appendOnly": {
                    "type": "boolean",
                    "description": "Type of the stream that will be created.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the stream.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the stream.\n"
                },
                "insertOnly": {
                    "type": "boolean",
                    "description": "Create an insert only stream type.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the stream; must be unique for the database and schema in which the stream is created.\n"
                },
                "onStage": {
                    "type": "string",
                    "description": "Specifies an identifier for the stage the stream will monitor.\n"
                },
                "onTable": {
                    "type": "string",
                    "description": "Specifies an identifier for the table the stream will monitor.\n"
                },
                "onView": {
                    "type": "string",
                    "description": "Specifies an identifier for the view the stream will monitor.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Name of the role that owns the stream.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the stream.\n"
                },
                "showInitialRows": {
                    "type": "boolean",
                    "description": "Specifies whether to return all existing rows in the source table as row inserts the first time the stream is consumed.\n"
                }
            },
            "required": [
                "database",
                "name",
                "owner",
                "schema"
            ],
            "inputProperties": {
                "appendOnly": {
                    "type": "boolean",
                    "description": "Type of the stream that will be created.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the stream.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the stream.\n",
                    "willReplaceOnChanges": true
                },
                "insertOnly": {
                    "type": "boolean",
                    "description": "Create an insert only stream type.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the stream; must be unique for the database and schema in which the stream is created.\n",
                    "willReplaceOnChanges": true
                },
                "onStage": {
                    "type": "string",
                    "description": "Specifies an identifier for the stage the stream will monitor.\n",
                    "willReplaceOnChanges": true
                },
                "onTable": {
                    "type": "string",
                    "description": "Specifies an identifier for the table the stream will monitor.\n",
                    "willReplaceOnChanges": true
                },
                "onView": {
                    "type": "string",
                    "description": "Specifies an identifier for the view the stream will monitor.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the stream.\n",
                    "willReplaceOnChanges": true
                },
                "showInitialRows": {
                    "type": "boolean",
                    "description": "Specifies whether to return all existing rows in the source table as row inserts the first time the stream is consumed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Stream resources.\n",
                "properties": {
                    "appendOnly": {
                        "type": "boolean",
                        "description": "Type of the stream that will be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the stream.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the stream.\n",
                        "willReplaceOnChanges": true
                    },
                    "insertOnly": {
                        "type": "boolean",
                        "description": "Create an insert only stream type.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the stream; must be unique for the database and schema in which the stream is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "onStage": {
                        "type": "string",
                        "description": "Specifies an identifier for the stage the stream will monitor.\n",
                        "willReplaceOnChanges": true
                    },
                    "onTable": {
                        "type": "string",
                        "description": "Specifies an identifier for the table the stream will monitor.\n",
                        "willReplaceOnChanges": true
                    },
                    "onView": {
                        "type": "string",
                        "description": "Specifies an identifier for the view the stream will monitor.\n",
                        "willReplaceOnChanges": true
                    },
                    "owner": {
                        "type": "string",
                        "description": "Name of the role that owns the stream.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the stream.\n",
                        "willReplaceOnChanges": true
                    },
                    "showInitialRows": {
                        "type": "boolean",
                        "description": "Specifies whether to return all existing rows in the source table as row inserts the first time the stream is consumed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/streamGrant:StreamGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.StreamGrant(\"grant\", {\n    databaseName: \"database\",\n    onFuture: false,\n    privilege: \"SELECT\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    streamName: \"view\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.StreamGrant(\"grant\",\n    database_name=\"database\",\n    on_future=False,\n    privilege=\"SELECT\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    stream_name=\"view\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.StreamGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        OnFuture = false,\n        Privilege = \"SELECT\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        StreamName = \"view\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewStreamGrant(ctx, \"grant\", \u0026snowflake.StreamGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"SELECT\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tStreamName:      pulumi.String(\"view\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.StreamGrant;\nimport com.pulumi.snowflake.StreamGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new StreamGrant(\"grant\", StreamGrantArgs.builder()        \n            .databaseName(\"database\")\n            .onFuture(false)\n            .privilege(\"SELECT\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .streamName(\"view\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:StreamGrant\n    properties:\n      databaseName: database\n      onFuture: false\n      privilege: SELECT\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      streamName: view\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|stream_name|privilege|with_grant_option|on_future|roles\"\n\n```sh\n $ pulumi import snowflake:index/streamGrant:StreamGrant example \"MY_DATABASE|MY_SCHEMA|MY_STREAM|SELECT|false|false|role1,role2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future streams on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all streams in the given schema. When this is true and no schema*name is provided apply this grant on all streams in the given database. The stream*name field must be unset in order to use on*all. Cannot be used together with on_future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future streams in the given schema. When this is true and no schema*name is provided apply this grant on all future streams in the given database. The stream*name field must be unset in order to use on*future. Cannot be used together with on_all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future stream. To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future streams on which to grant privileges.\n"
                },
                "streamName": {
                    "type": "string",
                    "description": "The name of the stream on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "roles"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future streams on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all streams in the given schema. When this is true and no schema*name is provided apply this grant on all streams in the given database. The stream*name field must be unset in order to use on*all. Cannot be used together with on_future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future streams in the given schema. When this is true and no schema*name is provided apply this grant on all future streams in the given database. The stream*name field must be unset in order to use on*future. Cannot be used together with on_all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future stream. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future streams on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "streamName": {
                    "type": "string",
                    "description": "The name of the stream on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StreamGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future streams on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all streams in the given schema. When this is true and no schema*name is provided apply this grant on all streams in the given database. The stream*name field must be unset in order to use on*all. Cannot be used together with on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future streams in the given schema. When this is true and no schema*name is provided apply this grant on all future streams in the given database. The stream*name field must be unset in order to use on*future. Cannot be used together with on_all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future stream. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future streams on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "streamName": {
                        "type": "string",
                        "description": "The name of the stream on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/table:Table": {
            "description": "\n\n## Import\n\nformat is database name | schema name | table name\n\n```sh\n $ pulumi import snowflake:index/table:Table example 'databaseName|schemaName|tableName'\n```\n\n ",
            "properties": {
                "changeTracking": {
                    "type": "boolean",
                    "description": "Specifies whether to enable change tracking on the table. Default false.\n"
                },
                "clusterBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of one or more table columns/expressions to be used as clustering key(s) for the table\n"
                },
                "columns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TableColumn:TableColumn"
                    },
                    "description": "Definitions of a column to create in the table. Minimum one required.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Column comment\n"
                },
                "dataRetentionDays": {
                    "type": "integer",
                    "description": "Specifies the retention period for the table so that Time Travel actions (SELECT, CLONE, UNDROP) can be performed on historical data in the table. Default value is 1, if you wish to inherit the parent schema setting then pass in the schema attribute to this argument.\n",
                    "deprecationMessage": "Use data_retention_time_in_days attribute instead"
                },
                "dataRetentionTimeInDays": {
                    "type": "integer",
                    "description": "Specifies the retention period for the table so that Time Travel actions (SELECT, CLONE, UNDROP) can be performed on historical data in the table. Default value is 1, if you wish to inherit the parent schema setting then pass in the schema attribute to this argument.\n",
                    "deprecationMessage": "Use snowflake_object_parameter instead"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Column name\n"
                },
                "owner": {
                    "type": "string",
                    "description": "Name of the role that owns the table.\n"
                },
                "primaryKey": {
                    "$ref": "#/types/snowflake:index/TablePrimaryKey:TablePrimaryKey",
                    "description": "Definitions of primary key constraint to create on table\n",
                    "deprecationMessage": "Use snowflake_table_constraint instead"
                },
                "qualifiedName": {
                    "type": "string",
                    "description": "Qualified name of the table.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TableTag:TableTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "required": [
                "columns",
                "database",
                "name",
                "owner",
                "qualifiedName",
                "schema"
            ],
            "inputProperties": {
                "changeTracking": {
                    "type": "boolean",
                    "description": "Specifies whether to enable change tracking on the table. Default false.\n"
                },
                "clusterBies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of one or more table columns/expressions to be used as clustering key(s) for the table\n"
                },
                "columns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TableColumn:TableColumn"
                    },
                    "description": "Definitions of a column to create in the table. Minimum one required.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Column comment\n"
                },
                "dataRetentionDays": {
                    "type": "integer",
                    "description": "Specifies the retention period for the table so that Time Travel actions (SELECT, CLONE, UNDROP) can be performed on historical data in the table. Default value is 1, if you wish to inherit the parent schema setting then pass in the schema attribute to this argument.\n",
                    "deprecationMessage": "Use data_retention_time_in_days attribute instead"
                },
                "dataRetentionTimeInDays": {
                    "type": "integer",
                    "description": "Specifies the retention period for the table so that Time Travel actions (SELECT, CLONE, UNDROP) can be performed on historical data in the table. Default value is 1, if you wish to inherit the parent schema setting then pass in the schema attribute to this argument.\n",
                    "deprecationMessage": "Use snowflake_object_parameter instead"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Column name\n"
                },
                "primaryKey": {
                    "$ref": "#/types/snowflake:index/TablePrimaryKey:TablePrimaryKey",
                    "description": "Definitions of primary key constraint to create on table\n",
                    "deprecationMessage": "Use snowflake_table_constraint instead"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TableTag:TableTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "requiredInputs": [
                "columns",
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Table resources.\n",
                "properties": {
                    "changeTracking": {
                        "type": "boolean",
                        "description": "Specifies whether to enable change tracking on the table. Default false.\n"
                    },
                    "clusterBies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of one or more table columns/expressions to be used as clustering key(s) for the table\n"
                    },
                    "columns": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/TableColumn:TableColumn"
                        },
                        "description": "Definitions of a column to create in the table. Minimum one required.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Column comment\n"
                    },
                    "dataRetentionDays": {
                        "type": "integer",
                        "description": "Specifies the retention period for the table so that Time Travel actions (SELECT, CLONE, UNDROP) can be performed on historical data in the table. Default value is 1, if you wish to inherit the parent schema setting then pass in the schema attribute to this argument.\n",
                        "deprecationMessage": "Use data_retention_time_in_days attribute instead"
                    },
                    "dataRetentionTimeInDays": {
                        "type": "integer",
                        "description": "Specifies the retention period for the table so that Time Travel actions (SELECT, CLONE, UNDROP) can be performed on historical data in the table. Default value is 1, if you wish to inherit the parent schema setting then pass in the schema attribute to this argument.\n",
                        "deprecationMessage": "Use snowflake_object_parameter instead"
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Column name\n"
                    },
                    "owner": {
                        "type": "string",
                        "description": "Name of the role that owns the table.\n"
                    },
                    "primaryKey": {
                        "$ref": "#/types/snowflake:index/TablePrimaryKey:TablePrimaryKey",
                        "description": "Definitions of primary key constraint to create on table\n",
                        "deprecationMessage": "Use snowflake_table_constraint instead"
                    },
                    "qualifiedName": {
                        "type": "string",
                        "description": "Qualified name of the table.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "Name of the schema that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/TableTag:TableTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n",
                        "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/tableColumnMaskingPolicyApplication:TableColumnMaskingPolicyApplication": {
            "description": "Applies a masking policy to a table column.\n\nOnly one masking policy may be applied per table column, hence only one `snowflake.TableColumnMaskingPolicyApplication` resources may be present per table column.\nUsing two or more `snowflake.TableColumnMaskingPolicyApplication` resources for the same table column will result in the last one overriding any previously applied masking policies and unresolvable diffs in pulumi preview.\n\nWhen using this resource to manage a table column's masking policy make sure to ignore changes to the column's masking policy in the table definition, otherwise the two resources would conflict. See example below.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Provider;\nimport com.pulumi.snowflake.ProviderArgs;\nimport com.pulumi.snowflake.MaskingPolicy;\nimport com.pulumi.snowflake.MaskingPolicyArgs;\nimport com.pulumi.snowflake.Table;\nimport com.pulumi.snowflake.TableArgs;\nimport com.pulumi.snowflake.inputs.TableColumnArgs;\nimport com.pulumi.snowflake.TableColumnMaskingPolicyApplication;\nimport com.pulumi.snowflake.TableColumnMaskingPolicyApplicationArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var masking = new Provider(\"masking\", ProviderArgs.builder()        \n            .role(\"MASKING_ADMIN\")\n            .build());\n\n        var policy = new MaskingPolicy(\"policy\", MaskingPolicyArgs.builder()        \n            .database(\"EXAMPLE_DB\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .valueDataType(\"VARCHAR\")\n            .maskingExpression(\"case when current_role() in ('ANALYST') then val else sha2(val, 512) end\")\n            .returnDataType(\"VARCHAR\")\n            .build(), CustomResourceOptions.builder()\n                .provider(snowflake.masking())\n                .build());\n\n        var table = new Table(\"table\", TableArgs.builder()        \n            .database(\"EXAMPLE_DB\")\n            .schema(\"EXAMPLE_SCHEMA\")\n            .columns(TableColumnArgs.builder()\n                .name(\"secret\")\n                .type(\"VARCHAR(16777216)\")\n                .build())\n            .build());\n\n        var application = new TableColumnMaskingPolicyApplication(\"application\", TableColumnMaskingPolicyApplicationArgs.builder()        \n            .table(table.qualifiedName())\n            .column(\"secret\")\n            .maskingPolicy(policy.qualifiedName())\n            .build(), CustomResourceOptions.builder()\n                .provider(snowflake.masking())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Alternative provider with masking_admin role\n  masking:\n    type: pulumi:providers:snowflake\n    properties:\n      role: MASKING_ADMIN\n  policy:\n    type: snowflake:MaskingPolicy\n    properties:\n      database: EXAMPLE_DB\n      schema: EXAMPLE_SCHEMA\n      valueDataType: VARCHAR\n      maskingExpression: case when current_role() in ('ANALYST') then val else sha2(val, 512) end\n      returnDataType: VARCHAR\n    options:\n      provider: ${snowflake.masking}\n  # Table is created by the default provider\n  table:\n    type: snowflake:Table\n    properties:\n      database: EXAMPLE_DB\n      schema: EXAMPLE_SCHEMA\n      columns:\n        - name: secret\n          type: VARCHAR(16777216)\n  application:\n    type: snowflake:TableColumnMaskingPolicyApplication\n    properties:\n      table: ${table.qualifiedName}\n      column: secret\n      maskingPolicy: ${policy.qualifiedName}\n    options:\n      provider: ${snowflake.masking}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "column": {
                    "type": "string",
                    "description": "The column to apply the masking policy to.\n"
                },
                "maskingPolicy": {
                    "type": "string",
                    "description": "Fully qualified name (`database.schema.policyname`) of the policy to apply.\n"
                },
                "table": {
                    "type": "string",
                    "description": "The fully qualified name (`database.schema.table`) of the table to apply the masking policy to.\n"
                }
            },
            "required": [
                "column",
                "maskingPolicy",
                "table"
            ],
            "inputProperties": {
                "column": {
                    "type": "string",
                    "description": "The column to apply the masking policy to.\n",
                    "willReplaceOnChanges": true
                },
                "maskingPolicy": {
                    "type": "string",
                    "description": "Fully qualified name (`database.schema.policyname`) of the policy to apply.\n",
                    "willReplaceOnChanges": true
                },
                "table": {
                    "type": "string",
                    "description": "The fully qualified name (`database.schema.table`) of the table to apply the masking policy to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "column",
                "maskingPolicy",
                "table"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TableColumnMaskingPolicyApplication resources.\n",
                "properties": {
                    "column": {
                        "type": "string",
                        "description": "The column to apply the masking policy to.\n",
                        "willReplaceOnChanges": true
                    },
                    "maskingPolicy": {
                        "type": "string",
                        "description": "Fully qualified name (`database.schema.policyname`) of the policy to apply.\n",
                        "willReplaceOnChanges": true
                    },
                    "table": {
                        "type": "string",
                        "description": "The fully qualified name (`database.schema.table`) of the table to apply the masking policy to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/tableConstraint:TableConstraint": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst database = new snowflake.Database(\"database\", {});\nconst schema = new snowflake.Schema(\"schema\", {database: database.name});\nconst table = new snowflake.Table(\"table\", {\n    database: database.name,\n    schema: schema.name,\n    columns: [\n        {\n            name: \"col1\",\n            type: \"text\",\n            nullable: false,\n        },\n        {\n            name: \"col2\",\n            type: \"text\",\n            nullable: false,\n        },\n        {\n            name: \"col3\",\n            type: \"text\",\n            nullable: false,\n        },\n    ],\n});\nconst fkT = new snowflake.Table(\"fkT\", {\n    database: database.name,\n    schema: schema.name,\n    columns: [\n        {\n            name: \"fk_col1\",\n            type: \"text\",\n            nullable: false,\n        },\n        {\n            name: \"fk_col2\",\n            type: \"text\",\n            nullable: false,\n        },\n    ],\n});\nconst primaryKey = new snowflake.TableConstraint(\"primaryKey\", {\n    type: \"PRIMARY KEY\",\n    tableId: table.id,\n    columns: [\"col1\"],\n    comment: \"hello world\",\n});\nconst foreignKey = new snowflake.TableConstraint(\"foreignKey\", {\n    type: \"FOREIGN KEY\",\n    tableId: table.id,\n    columns: [\"col2\"],\n    foreignKeyProperties: {\n        references: {\n            tableId: fkT.id,\n            columns: [\"fk_col1\"],\n        },\n    },\n    enforced: false,\n    deferrable: false,\n    initially: \"IMMEDIATE\",\n    comment: \"hello fk\",\n});\nconst unique = new snowflake.TableConstraint(\"unique\", {\n    type: \"UNIQUE\",\n    tableId: table.id,\n    columns: [\"col3\"],\n    comment: \"hello unique\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndatabase = snowflake.Database(\"database\")\nschema = snowflake.Schema(\"schema\", database=database.name)\ntable = snowflake.Table(\"table\",\n    database=database.name,\n    schema=schema.name,\n    columns=[\n        snowflake.TableColumnArgs(\n            name=\"col1\",\n            type=\"text\",\n            nullable=False,\n        ),\n        snowflake.TableColumnArgs(\n            name=\"col2\",\n            type=\"text\",\n            nullable=False,\n        ),\n        snowflake.TableColumnArgs(\n            name=\"col3\",\n            type=\"text\",\n            nullable=False,\n        ),\n    ])\nfk_t = snowflake.Table(\"fkT\",\n    database=database.name,\n    schema=schema.name,\n    columns=[\n        snowflake.TableColumnArgs(\n            name=\"fk_col1\",\n            type=\"text\",\n            nullable=False,\n        ),\n        snowflake.TableColumnArgs(\n            name=\"fk_col2\",\n            type=\"text\",\n            nullable=False,\n        ),\n    ])\nprimary_key = snowflake.TableConstraint(\"primaryKey\",\n    type=\"PRIMARY KEY\",\n    table_id=table.id,\n    columns=[\"col1\"],\n    comment=\"hello world\")\nforeign_key = snowflake.TableConstraint(\"foreignKey\",\n    type=\"FOREIGN KEY\",\n    table_id=table.id,\n    columns=[\"col2\"],\n    foreign_key_properties=snowflake.TableConstraintForeignKeyPropertiesArgs(\n        references=snowflake.TableConstraintForeignKeyPropertiesReferencesArgs(\n            table_id=fk_t.id,\n            columns=[\"fk_col1\"],\n        ),\n    ),\n    enforced=False,\n    deferrable=False,\n    initially=\"IMMEDIATE\",\n    comment=\"hello fk\")\nunique = snowflake.TableConstraint(\"unique\",\n    type=\"UNIQUE\",\n    table_id=table.id,\n    columns=[\"col3\"],\n    comment=\"hello unique\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var database = new Snowflake.Database(\"database\");\n\n    var schema = new Snowflake.Schema(\"schema\", new()\n    {\n        Database = database.Name,\n    });\n\n    var table = new Snowflake.Table(\"table\", new()\n    {\n        Database = database.Name,\n        Schema = schema.Name,\n        Columns = new[]\n        {\n            new Snowflake.Inputs.TableColumnArgs\n            {\n                Name = \"col1\",\n                Type = \"text\",\n                Nullable = false,\n            },\n            new Snowflake.Inputs.TableColumnArgs\n            {\n                Name = \"col2\",\n                Type = \"text\",\n                Nullable = false,\n            },\n            new Snowflake.Inputs.TableColumnArgs\n            {\n                Name = \"col3\",\n                Type = \"text\",\n                Nullable = false,\n            },\n        },\n    });\n\n    var fkT = new Snowflake.Table(\"fkT\", new()\n    {\n        Database = database.Name,\n        Schema = schema.Name,\n        Columns = new[]\n        {\n            new Snowflake.Inputs.TableColumnArgs\n            {\n                Name = \"fk_col1\",\n                Type = \"text\",\n                Nullable = false,\n            },\n            new Snowflake.Inputs.TableColumnArgs\n            {\n                Name = \"fk_col2\",\n                Type = \"text\",\n                Nullable = false,\n            },\n        },\n    });\n\n    var primaryKey = new Snowflake.TableConstraint(\"primaryKey\", new()\n    {\n        Type = \"PRIMARY KEY\",\n        TableId = table.Id,\n        Columns = new[]\n        {\n            \"col1\",\n        },\n        Comment = \"hello world\",\n    });\n\n    var foreignKey = new Snowflake.TableConstraint(\"foreignKey\", new()\n    {\n        Type = \"FOREIGN KEY\",\n        TableId = table.Id,\n        Columns = new[]\n        {\n            \"col2\",\n        },\n        ForeignKeyProperties = new Snowflake.Inputs.TableConstraintForeignKeyPropertiesArgs\n        {\n            References = new Snowflake.Inputs.TableConstraintForeignKeyPropertiesReferencesArgs\n            {\n                TableId = fkT.Id,\n                Columns = new[]\n                {\n                    \"fk_col1\",\n                },\n            },\n        },\n        Enforced = false,\n        Deferrable = false,\n        Initially = \"IMMEDIATE\",\n        Comment = \"hello fk\",\n    });\n\n    var unique = new Snowflake.TableConstraint(\"unique\", new()\n    {\n        Type = \"UNIQUE\",\n        TableId = table.Id,\n        Columns = new[]\n        {\n            \"col3\",\n        },\n        Comment = \"hello unique\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatabase, err := snowflake.NewDatabase(ctx, \"database\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tschema, err := snowflake.NewSchema(ctx, \"schema\", \u0026snowflake.SchemaArgs{\n\t\t\tDatabase: database.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttable, err := snowflake.NewTable(ctx, \"table\", \u0026snowflake.TableArgs{\n\t\t\tDatabase: database.Name,\n\t\t\tSchema:   schema.Name,\n\t\t\tColumns: snowflake.TableColumnArray{\n\t\t\t\t\u0026snowflake.TableColumnArgs{\n\t\t\t\t\tName:     pulumi.String(\"col1\"),\n\t\t\t\t\tType:     pulumi.String(\"text\"),\n\t\t\t\t\tNullable: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t\t\u0026snowflake.TableColumnArgs{\n\t\t\t\t\tName:     pulumi.String(\"col2\"),\n\t\t\t\t\tType:     pulumi.String(\"text\"),\n\t\t\t\t\tNullable: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t\t\u0026snowflake.TableColumnArgs{\n\t\t\t\t\tName:     pulumi.String(\"col3\"),\n\t\t\t\t\tType:     pulumi.String(\"text\"),\n\t\t\t\t\tNullable: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfkT, err := snowflake.NewTable(ctx, \"fkT\", \u0026snowflake.TableArgs{\n\t\t\tDatabase: database.Name,\n\t\t\tSchema:   schema.Name,\n\t\t\tColumns: snowflake.TableColumnArray{\n\t\t\t\t\u0026snowflake.TableColumnArgs{\n\t\t\t\t\tName:     pulumi.String(\"fk_col1\"),\n\t\t\t\t\tType:     pulumi.String(\"text\"),\n\t\t\t\t\tNullable: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t\t\u0026snowflake.TableColumnArgs{\n\t\t\t\t\tName:     pulumi.String(\"fk_col2\"),\n\t\t\t\t\tType:     pulumi.String(\"text\"),\n\t\t\t\t\tNullable: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTableConstraint(ctx, \"primaryKey\", \u0026snowflake.TableConstraintArgs{\n\t\t\tType:    pulumi.String(\"PRIMARY KEY\"),\n\t\t\tTableId: table.ID(),\n\t\t\tColumns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"col1\"),\n\t\t\t},\n\t\t\tComment: pulumi.String(\"hello world\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTableConstraint(ctx, \"foreignKey\", \u0026snowflake.TableConstraintArgs{\n\t\t\tType:    pulumi.String(\"FOREIGN KEY\"),\n\t\t\tTableId: table.ID(),\n\t\t\tColumns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"col2\"),\n\t\t\t},\n\t\t\tForeignKeyProperties: \u0026snowflake.TableConstraintForeignKeyPropertiesArgs{\n\t\t\t\tReferences: \u0026snowflake.TableConstraintForeignKeyPropertiesReferencesArgs{\n\t\t\t\t\tTableId: fkT.ID(),\n\t\t\t\t\tColumns: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"fk_col1\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnforced:   pulumi.Bool(false),\n\t\t\tDeferrable: pulumi.Bool(false),\n\t\t\tInitially:  pulumi.String(\"IMMEDIATE\"),\n\t\t\tComment:    pulumi.String(\"hello fk\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTableConstraint(ctx, \"unique\", \u0026snowflake.TableConstraintArgs{\n\t\t\tType:    pulumi.String(\"UNIQUE\"),\n\t\t\tTableId: table.ID(),\n\t\t\tColumns: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"col3\"),\n\t\t\t},\n\t\t\tComment: pulumi.String(\"hello unique\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.Schema;\nimport com.pulumi.snowflake.SchemaArgs;\nimport com.pulumi.snowflake.Table;\nimport com.pulumi.snowflake.TableArgs;\nimport com.pulumi.snowflake.inputs.TableColumnArgs;\nimport com.pulumi.snowflake.TableConstraint;\nimport com.pulumi.snowflake.TableConstraintArgs;\nimport com.pulumi.snowflake.inputs.TableConstraintForeignKeyPropertiesArgs;\nimport com.pulumi.snowflake.inputs.TableConstraintForeignKeyPropertiesReferencesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var database = new Database(\"database\");\n\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .database(database.name())\n            .build());\n\n        var table = new Table(\"table\", TableArgs.builder()        \n            .database(database.name())\n            .schema(schema.name())\n            .columns(            \n                TableColumnArgs.builder()\n                    .name(\"col1\")\n                    .type(\"text\")\n                    .nullable(false)\n                    .build(),\n                TableColumnArgs.builder()\n                    .name(\"col2\")\n                    .type(\"text\")\n                    .nullable(false)\n                    .build(),\n                TableColumnArgs.builder()\n                    .name(\"col3\")\n                    .type(\"text\")\n                    .nullable(false)\n                    .build())\n            .build());\n\n        var fkT = new Table(\"fkT\", TableArgs.builder()        \n            .database(database.name())\n            .schema(schema.name())\n            .columns(            \n                TableColumnArgs.builder()\n                    .name(\"fk_col1\")\n                    .type(\"text\")\n                    .nullable(false)\n                    .build(),\n                TableColumnArgs.builder()\n                    .name(\"fk_col2\")\n                    .type(\"text\")\n                    .nullable(false)\n                    .build())\n            .build());\n\n        var primaryKey = new TableConstraint(\"primaryKey\", TableConstraintArgs.builder()        \n            .type(\"PRIMARY KEY\")\n            .tableId(table.id())\n            .columns(\"col1\")\n            .comment(\"hello world\")\n            .build());\n\n        var foreignKey = new TableConstraint(\"foreignKey\", TableConstraintArgs.builder()        \n            .type(\"FOREIGN KEY\")\n            .tableId(table.id())\n            .columns(\"col2\")\n            .foreignKeyProperties(TableConstraintForeignKeyPropertiesArgs.builder()\n                .references(TableConstraintForeignKeyPropertiesReferencesArgs.builder()\n                    .tableId(fkT.id())\n                    .columns(\"fk_col1\")\n                    .build())\n                .build())\n            .enforced(false)\n            .deferrable(false)\n            .initially(\"IMMEDIATE\")\n            .comment(\"hello fk\")\n            .build());\n\n        var unique = new TableConstraint(\"unique\", TableConstraintArgs.builder()        \n            .type(\"UNIQUE\")\n            .tableId(table.id())\n            .columns(\"col3\")\n            .comment(\"hello unique\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  database:\n    type: snowflake:Database\n  schema:\n    type: snowflake:Schema\n    properties:\n      database: ${database.name}\n  table:\n    type: snowflake:Table\n    properties:\n      database: ${database.name}\n      schema: ${schema.name}\n      columns:\n        - name: col1\n          type: text\n          nullable: false\n        - name: col2\n          type: text\n          nullable: false\n        - name: col3\n          type: text\n          nullable: false\n  fkT:\n    type: snowflake:Table\n    properties:\n      database: ${database.name}\n      schema: ${schema.name}\n      columns:\n        - name: fk_col1\n          type: text\n          nullable: false\n        - name: fk_col2\n          type: text\n          nullable: false\n  primaryKey:\n    type: snowflake:TableConstraint\n    properties:\n      type: PRIMARY KEY\n      tableId: ${table.id}\n      columns:\n        - col1\n      comment: hello world\n  foreignKey:\n    type: snowflake:TableConstraint\n    properties:\n      type: FOREIGN KEY\n      tableId: ${table.id}\n      columns:\n        - col2\n      foreignKeyProperties:\n        references:\n          tableId: ${fkT.id}\n          columns:\n            - fk_col1\n      enforced: false\n      deferrable: false\n      initially: IMMEDIATE\n      comment: hello fk\n  unique:\n    type: snowflake:TableConstraint\n    properties:\n      type: UNIQUE\n      tableId: ${table.id}\n      columns:\n        - col3\n      comment: hello unique\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/tableConstraint:TableConstraint example 'myconstraintfk❄️FOREIGN KEY❄️test|test|table'\n```\n\n ",
            "properties": {
                "columns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Columns to use in foreign key reference\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Comment for the table constraint\n"
                },
                "deferrable": {
                    "type": "boolean",
                    "description": "Whether the constraint is deferrable\n"
                },
                "enable": {
                    "type": "boolean",
                    "description": "Specifies whether the constraint is enabled or disabled. These properties are provided for compatibility with Oracle.\n"
                },
                "enforced": {
                    "type": "boolean",
                    "description": "Whether the constraint is enforced\n"
                },
                "foreignKeyProperties": {
                    "$ref": "#/types/snowflake:index/TableConstraintForeignKeyProperties:TableConstraintForeignKeyProperties",
                    "description": "Additional properties when type is set to foreign key. Not applicable for primary/unique keys\n"
                },
                "initially": {
                    "type": "string",
                    "description": "Whether the constraint is initially deferred or immediate\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of constraint\n"
                },
                "rely": {
                    "type": "boolean",
                    "description": "Specifies whether a constraint in NOVALIDATE mode is taken into account during query rewrite.\n"
                },
                "tableId": {
                    "type": "string",
                    "description": "Name of constraint\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of constraint, one of 'UNIQUE', 'PRIMARY KEY', 'FOREIGN KEY', or 'NOT NULL'\n"
                },
                "validate": {
                    "type": "boolean",
                    "description": "Specifies whether to validate existing data on the table when a constraint is created. Only used in conjunction with the ENABLE property.\n"
                }
            },
            "required": [
                "columns",
                "name",
                "tableId",
                "type"
            ],
            "inputProperties": {
                "columns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Columns to use in foreign key reference\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Comment for the table constraint\n",
                    "willReplaceOnChanges": true
                },
                "deferrable": {
                    "type": "boolean",
                    "description": "Whether the constraint is deferrable\n",
                    "willReplaceOnChanges": true
                },
                "enable": {
                    "type": "boolean",
                    "description": "Specifies whether the constraint is enabled or disabled. These properties are provided for compatibility with Oracle.\n",
                    "willReplaceOnChanges": true
                },
                "enforced": {
                    "type": "boolean",
                    "description": "Whether the constraint is enforced\n",
                    "willReplaceOnChanges": true
                },
                "foreignKeyProperties": {
                    "$ref": "#/types/snowflake:index/TableConstraintForeignKeyProperties:TableConstraintForeignKeyProperties",
                    "description": "Additional properties when type is set to foreign key. Not applicable for primary/unique keys\n",
                    "willReplaceOnChanges": true
                },
                "initially": {
                    "type": "string",
                    "description": "Whether the constraint is initially deferred or immediate\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of constraint\n"
                },
                "rely": {
                    "type": "boolean",
                    "description": "Specifies whether a constraint in NOVALIDATE mode is taken into account during query rewrite.\n",
                    "willReplaceOnChanges": true
                },
                "tableId": {
                    "type": "string",
                    "description": "Name of constraint\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Type of constraint, one of 'UNIQUE', 'PRIMARY KEY', 'FOREIGN KEY', or 'NOT NULL'\n",
                    "willReplaceOnChanges": true
                },
                "validate": {
                    "type": "boolean",
                    "description": "Specifies whether to validate existing data on the table when a constraint is created. Only used in conjunction with the ENABLE property.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "columns",
                "tableId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TableConstraint resources.\n",
                "properties": {
                    "columns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Columns to use in foreign key reference\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Comment for the table constraint\n",
                        "willReplaceOnChanges": true
                    },
                    "deferrable": {
                        "type": "boolean",
                        "description": "Whether the constraint is deferrable\n",
                        "willReplaceOnChanges": true
                    },
                    "enable": {
                        "type": "boolean",
                        "description": "Specifies whether the constraint is enabled or disabled. These properties are provided for compatibility with Oracle.\n",
                        "willReplaceOnChanges": true
                    },
                    "enforced": {
                        "type": "boolean",
                        "description": "Whether the constraint is enforced\n",
                        "willReplaceOnChanges": true
                    },
                    "foreignKeyProperties": {
                        "$ref": "#/types/snowflake:index/TableConstraintForeignKeyProperties:TableConstraintForeignKeyProperties",
                        "description": "Additional properties when type is set to foreign key. Not applicable for primary/unique keys\n",
                        "willReplaceOnChanges": true
                    },
                    "initially": {
                        "type": "string",
                        "description": "Whether the constraint is initially deferred or immediate\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of constraint\n"
                    },
                    "rely": {
                        "type": "boolean",
                        "description": "Specifies whether a constraint in NOVALIDATE mode is taken into account during query rewrite.\n",
                        "willReplaceOnChanges": true
                    },
                    "tableId": {
                        "type": "string",
                        "description": "Name of constraint\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of constraint, one of 'UNIQUE', 'PRIMARY KEY', 'FOREIGN KEY', or 'NOT NULL'\n",
                        "willReplaceOnChanges": true
                    },
                    "validate": {
                        "type": "boolean",
                        "description": "Specifies whether to validate existing data on the table when a constraint is created. Only used in conjunction with the ENABLE property.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/tableGrant:TableGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.TableGrant(\"grant\", {\n    databaseName: \"database\",\n    onFuture: false,\n    privilege: \"SELECT\",\n    roles: [\"role1\"],\n    schemaName: \"schema\",\n    shares: [\"share1\"],\n    tableName: \"table\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.TableGrant(\"grant\",\n    database_name=\"database\",\n    on_future=False,\n    privilege=\"SELECT\",\n    roles=[\"role1\"],\n    schema_name=\"schema\",\n    shares=[\"share1\"],\n    table_name=\"table\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.TableGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        OnFuture = false,\n        Privilege = \"SELECT\",\n        Roles = new[]\n        {\n            \"role1\",\n        },\n        SchemaName = \"schema\",\n        Shares = new[]\n        {\n            \"share1\",\n        },\n        TableName = \"table\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewTableGrant(ctx, \"grant\", \u0026snowflake.TableGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"SELECT\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t},\n\t\t\tTableName:       pulumi.String(\"table\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.TableGrant;\nimport com.pulumi.snowflake.TableGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new TableGrant(\"grant\", TableGrantArgs.builder()        \n            .databaseName(\"database\")\n            .onFuture(false)\n            .privilege(\"SELECT\")\n            .roles(\"role1\")\n            .schemaName(\"schema\")\n            .shares(\"share1\")\n            .tableName(\"table\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:TableGrant\n    properties:\n      databaseName: database\n      onFuture: false\n      privilege: SELECT\n      roles:\n        - role1\n      schemaName: schema\n      shares:\n        - share1\n      tableName: table\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|table_name|privilege|with_grant_option|on_future|on_all|roles|shares\n\n```sh\n $ pulumi import snowflake:index/tableGrant:TableGrant example \"MY_DATABASE|MY_SCHEMA|MY_TABLE|USAGE|false|false|false|role1,role2|share1,share2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future tables on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all tables in the given schema. When this is true and no schema*name is provided apply this grant on all tables in the given database. The table*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future tables in the given schema. When this is true and no schema*name is provided apply this grant on all future tables in the given database. The table*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future table. To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future tables on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on*future or on*all are unset).\n"
                },
                "tableName": {
                    "type": "string",
                    "description": "The name of the table on which to grant privileges immediately (only valid if on*future or on*all are unset).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future tables on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all tables in the given schema. When this is true and no schema*name is provided apply this grant on all tables in the given database. The table*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future tables in the given schema. When this is true and no schema*name is provided apply this grant on all future tables in the given database. The table*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future table. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future tables on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on*future or on*all are unset).\n"
                },
                "tableName": {
                    "type": "string",
                    "description": "The name of the table on which to grant privileges immediately (only valid if on*future or on*all are unset).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TableGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future tables on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all tables in the given schema. When this is true and no schema*name is provided apply this grant on all tables in the given database. The table*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future tables in the given schema. When this is true and no schema*name is provided apply this grant on all future tables in the given database. The table*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future table. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future tables on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on*future or on*all are unset).\n"
                    },
                    "tableName": {
                        "type": "string",
                        "description": "The name of the table on which to grant privileges immediately (only valid if on*future or on*all are unset).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/tag:Tag": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst database = new snowflake.Database(\"database\", {});\nconst schema = new snowflake.Schema(\"schema\", {database: database.name});\nconst tag = new snowflake.Tag(\"tag\", {\n    database: database.name,\n    schema: schema.name,\n    allowedValues: [\n        \"finance\",\n        \"engineering\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndatabase = snowflake.Database(\"database\")\nschema = snowflake.Schema(\"schema\", database=database.name)\ntag = snowflake.Tag(\"tag\",\n    database=database.name,\n    schema=schema.name,\n    allowed_values=[\n        \"finance\",\n        \"engineering\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var database = new Snowflake.Database(\"database\");\n\n    var schema = new Snowflake.Schema(\"schema\", new()\n    {\n        Database = database.Name,\n    });\n\n    var tag = new Snowflake.Tag(\"tag\", new()\n    {\n        Database = database.Name,\n        Schema = schema.Name,\n        AllowedValues = new[]\n        {\n            \"finance\",\n            \"engineering\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatabase, err := snowflake.NewDatabase(ctx, \"database\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tschema, err := snowflake.NewSchema(ctx, \"schema\", \u0026snowflake.SchemaArgs{\n\t\t\tDatabase: database.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTag(ctx, \"tag\", \u0026snowflake.TagArgs{\n\t\t\tDatabase: database.Name,\n\t\t\tSchema:   schema.Name,\n\t\t\tAllowedValues: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"finance\"),\n\t\t\t\tpulumi.String(\"engineering\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.Schema;\nimport com.pulumi.snowflake.SchemaArgs;\nimport com.pulumi.snowflake.Tag;\nimport com.pulumi.snowflake.TagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var database = new Database(\"database\");\n\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .database(database.name())\n            .build());\n\n        var tag = new Tag(\"tag\", TagArgs.builder()        \n            .database(database.name())\n            .schema(schema.name())\n            .allowedValues(            \n                \"finance\",\n                \"engineering\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  database:\n    type: snowflake:Database\n  schema:\n    type: snowflake:Schema\n    properties:\n      database: ${database.name}\n  tag:\n    type: snowflake:Tag\n    properties:\n      database: ${database.name}\n      schema: ${schema.name}\n      allowedValues:\n        - finance\n        - engineering\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | tag name\n\n```sh\n $ pulumi import snowflake:index/tag:Tag example 'dbName|schemaName|tagName'\n```\n\n ",
            "properties": {
                "allowedValues": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed values for the tag.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the tag.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the tag; must be unique for the database in which the tag is created.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the tag.\n"
                }
            },
            "required": [
                "database",
                "name",
                "schema"
            ],
            "inputProperties": {
                "allowedValues": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed values for the tag.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the tag.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the tag.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the tag; must be unique for the database in which the tag is created.\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the tag.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "database",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tag resources.\n",
                "properties": {
                    "allowedValues": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of allowed values for the tag.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the tag.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the tag.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the tag; must be unique for the database in which the tag is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the tag.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/tagAssociation:TagAssociation": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst database = new snowflake.Database(\"database\", {});\nconst schema = new snowflake.Schema(\"schema\", {database: database.name});\nconst tag = new snowflake.Tag(\"tag\", {\n    database: database.name,\n    schema: schema.name,\n    allowedValues: [\n        \"finance\",\n        \"engineering\",\n    ],\n});\nconst dbAssociation = new snowflake.TagAssociation(\"dbAssociation\", {\n    objectIdentifiers: [{\n        name: database.name,\n    }],\n    objectType: \"DATABASE\",\n    tagId: tag.id,\n    tagValue: \"finance\",\n});\nconst test = new snowflake.Table(\"test\", {\n    database: snowflake_database.test.name,\n    schema: snowflake_schema.test.name,\n    comment: \"Terraform example table\",\n    columns: [\n        {\n            name: \"column1\",\n            type: \"VARIANT\",\n        },\n        {\n            name: \"column2\",\n            type: \"VARCHAR(16)\",\n        },\n    ],\n});\nconst tableAssociation = new snowflake.TagAssociation(\"tableAssociation\", {\n    objectIdentifiers: [{\n        name: test.name,\n        database: snowflake_database.test.name,\n        schema: snowflake_schema.test.name,\n    }],\n    objectType: \"TABLE\",\n    tagId: snowflake_tag.test.id,\n    tagValue: \"engineering\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndatabase = snowflake.Database(\"database\")\nschema = snowflake.Schema(\"schema\", database=database.name)\ntag = snowflake.Tag(\"tag\",\n    database=database.name,\n    schema=schema.name,\n    allowed_values=[\n        \"finance\",\n        \"engineering\",\n    ])\ndb_association = snowflake.TagAssociation(\"dbAssociation\",\n    object_identifiers=[snowflake.TagAssociationObjectIdentifierArgs(\n        name=database.name,\n    )],\n    object_type=\"DATABASE\",\n    tag_id=tag.id,\n    tag_value=\"finance\")\ntest = snowflake.Table(\"test\",\n    database=snowflake_database[\"test\"][\"name\"],\n    schema=snowflake_schema[\"test\"][\"name\"],\n    comment=\"Terraform example table\",\n    columns=[\n        snowflake.TableColumnArgs(\n            name=\"column1\",\n            type=\"VARIANT\",\n        ),\n        snowflake.TableColumnArgs(\n            name=\"column2\",\n            type=\"VARCHAR(16)\",\n        ),\n    ])\ntable_association = snowflake.TagAssociation(\"tableAssociation\",\n    object_identifiers=[snowflake.TagAssociationObjectIdentifierArgs(\n        name=test.name,\n        database=snowflake_database[\"test\"][\"name\"],\n        schema=snowflake_schema[\"test\"][\"name\"],\n    )],\n    object_type=\"TABLE\",\n    tag_id=snowflake_tag[\"test\"][\"id\"],\n    tag_value=\"engineering\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var database = new Snowflake.Database(\"database\");\n\n    var schema = new Snowflake.Schema(\"schema\", new()\n    {\n        Database = database.Name,\n    });\n\n    var tag = new Snowflake.Tag(\"tag\", new()\n    {\n        Database = database.Name,\n        Schema = schema.Name,\n        AllowedValues = new[]\n        {\n            \"finance\",\n            \"engineering\",\n        },\n    });\n\n    var dbAssociation = new Snowflake.TagAssociation(\"dbAssociation\", new()\n    {\n        ObjectIdentifiers = new[]\n        {\n            new Snowflake.Inputs.TagAssociationObjectIdentifierArgs\n            {\n                Name = database.Name,\n            },\n        },\n        ObjectType = \"DATABASE\",\n        TagId = tag.Id,\n        TagValue = \"finance\",\n    });\n\n    var test = new Snowflake.Table(\"test\", new()\n    {\n        Database = snowflake_database.Test.Name,\n        Schema = snowflake_schema.Test.Name,\n        Comment = \"Terraform example table\",\n        Columns = new[]\n        {\n            new Snowflake.Inputs.TableColumnArgs\n            {\n                Name = \"column1\",\n                Type = \"VARIANT\",\n            },\n            new Snowflake.Inputs.TableColumnArgs\n            {\n                Name = \"column2\",\n                Type = \"VARCHAR(16)\",\n            },\n        },\n    });\n\n    var tableAssociation = new Snowflake.TagAssociation(\"tableAssociation\", new()\n    {\n        ObjectIdentifiers = new[]\n        {\n            new Snowflake.Inputs.TagAssociationObjectIdentifierArgs\n            {\n                Name = test.Name,\n                Database = snowflake_database.Test.Name,\n                Schema = snowflake_schema.Test.Name,\n            },\n        },\n        ObjectType = \"TABLE\",\n        TagId = snowflake_tag.Test.Id,\n        TagValue = \"engineering\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatabase, err := snowflake.NewDatabase(ctx, \"database\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tschema, err := snowflake.NewSchema(ctx, \"schema\", \u0026snowflake.SchemaArgs{\n\t\t\tDatabase: database.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttag, err := snowflake.NewTag(ctx, \"tag\", \u0026snowflake.TagArgs{\n\t\t\tDatabase: database.Name,\n\t\t\tSchema:   schema.Name,\n\t\t\tAllowedValues: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"finance\"),\n\t\t\t\tpulumi.String(\"engineering\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTagAssociation(ctx, \"dbAssociation\", \u0026snowflake.TagAssociationArgs{\n\t\t\tObjectIdentifiers: snowflake.TagAssociationObjectIdentifierArray{\n\t\t\t\t\u0026snowflake.TagAssociationObjectIdentifierArgs{\n\t\t\t\t\tName: database.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tObjectType: pulumi.String(\"DATABASE\"),\n\t\t\tTagId:      tag.ID(),\n\t\t\tTagValue:   pulumi.String(\"finance\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest, err := snowflake.NewTable(ctx, \"test\", \u0026snowflake.TableArgs{\n\t\t\tDatabase: pulumi.Any(snowflake_database.Test.Name),\n\t\t\tSchema:   pulumi.Any(snowflake_schema.Test.Name),\n\t\t\tComment:  pulumi.String(\"Terraform example table\"),\n\t\t\tColumns: snowflake.TableColumnArray{\n\t\t\t\t\u0026snowflake.TableColumnArgs{\n\t\t\t\t\tName: pulumi.String(\"column1\"),\n\t\t\t\t\tType: pulumi.String(\"VARIANT\"),\n\t\t\t\t},\n\t\t\t\t\u0026snowflake.TableColumnArgs{\n\t\t\t\t\tName: pulumi.String(\"column2\"),\n\t\t\t\t\tType: pulumi.String(\"VARCHAR(16)\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTagAssociation(ctx, \"tableAssociation\", \u0026snowflake.TagAssociationArgs{\n\t\t\tObjectIdentifiers: snowflake.TagAssociationObjectIdentifierArray{\n\t\t\t\t\u0026snowflake.TagAssociationObjectIdentifierArgs{\n\t\t\t\t\tName:     test.Name,\n\t\t\t\t\tDatabase: pulumi.Any(snowflake_database.Test.Name),\n\t\t\t\t\tSchema:   pulumi.Any(snowflake_schema.Test.Name),\n\t\t\t\t},\n\t\t\t},\n\t\t\tObjectType: pulumi.String(\"TABLE\"),\n\t\t\tTagId:      pulumi.Any(snowflake_tag.Test.Id),\n\t\t\tTagValue:   pulumi.String(\"engineering\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.Schema;\nimport com.pulumi.snowflake.SchemaArgs;\nimport com.pulumi.snowflake.Tag;\nimport com.pulumi.snowflake.TagArgs;\nimport com.pulumi.snowflake.TagAssociation;\nimport com.pulumi.snowflake.TagAssociationArgs;\nimport com.pulumi.snowflake.inputs.TagAssociationObjectIdentifierArgs;\nimport com.pulumi.snowflake.Table;\nimport com.pulumi.snowflake.TableArgs;\nimport com.pulumi.snowflake.inputs.TableColumnArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var database = new Database(\"database\");\n\n        var schema = new Schema(\"schema\", SchemaArgs.builder()        \n            .database(database.name())\n            .build());\n\n        var tag = new Tag(\"tag\", TagArgs.builder()        \n            .database(database.name())\n            .schema(schema.name())\n            .allowedValues(            \n                \"finance\",\n                \"engineering\")\n            .build());\n\n        var dbAssociation = new TagAssociation(\"dbAssociation\", TagAssociationArgs.builder()        \n            .objectIdentifiers(TagAssociationObjectIdentifierArgs.builder()\n                .name(database.name())\n                .build())\n            .objectType(\"DATABASE\")\n            .tagId(tag.id())\n            .tagValue(\"finance\")\n            .build());\n\n        var test = new Table(\"test\", TableArgs.builder()        \n            .database(snowflake_database.test().name())\n            .schema(snowflake_schema.test().name())\n            .comment(\"Terraform example table\")\n            .columns(            \n                TableColumnArgs.builder()\n                    .name(\"column1\")\n                    .type(\"VARIANT\")\n                    .build(),\n                TableColumnArgs.builder()\n                    .name(\"column2\")\n                    .type(\"VARCHAR(16)\")\n                    .build())\n            .build());\n\n        var tableAssociation = new TagAssociation(\"tableAssociation\", TagAssociationArgs.builder()        \n            .objectIdentifiers(TagAssociationObjectIdentifierArgs.builder()\n                .name(test.name())\n                .database(snowflake_database.test().name())\n                .schema(snowflake_schema.test().name())\n                .build())\n            .objectType(\"TABLE\")\n            .tagId(snowflake_tag.test().id())\n            .tagValue(\"engineering\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  database:\n    type: snowflake:Database\n  schema:\n    type: snowflake:Schema\n    properties:\n      database: ${database.name}\n  tag:\n    type: snowflake:Tag\n    properties:\n      database: ${database.name}\n      schema: ${schema.name}\n      allowedValues:\n        - finance\n        - engineering\n  dbAssociation:\n    type: snowflake:TagAssociation\n    properties:\n      objectIdentifiers:\n        - name: ${database.name}\n      objectType: DATABASE\n      tagId: ${tag.id}\n      tagValue: finance\n  test:\n    type: snowflake:Table\n    properties:\n      database: ${snowflake_database.test.name}\n      schema: ${snowflake_schema.test.name}\n      comment: Terraform example table\n      columns:\n        - name: column1\n          type: VARIANT\n        - name: column2\n          type: VARCHAR(16)\n  tableAssociation:\n    type: snowflake:TagAssociation\n    properties:\n      objectIdentifiers:\n        - name: ${test.name}\n          database: ${snowflake_database.test.name}\n          schema: ${snowflake_schema.test.name}\n      objectType: TABLE\n      tagId: ${snowflake_tag.test.id}\n      tagValue: engineering\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is dbName.schemaName.tagName or dbName.schemaName.tagName\n\n```sh\n $ pulumi import snowflake:index/tagAssociation:TagAssociation example 'dbName.schemaName.tagName'\n```\n\n ",
            "properties": {
                "objectIdentifiers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TagAssociationObjectIdentifier:TagAssociationObjectIdentifier"
                    },
                    "description": "Specifies the object identifier for the tag association.\n"
                },
                "objectName": {
                    "type": "string",
                    "description": "Specifies the object identifier for the tag association.\n",
                    "deprecationMessage": "Use `object_identifier` instead"
                },
                "objectType": {
                    "type": "string",
                    "description": "Specifies the type of object to add a tag to. ex: 'ACCOUNT', 'COLUMN', 'DATABASE', etc. For more information: https://docs.snowflake.com/en/user-guide/object-tagging.html#supported-objects\n"
                },
                "skipValidation": {
                    "type": "boolean",
                    "description": "If true, skips validation of the tag association.\n"
                },
                "tagId": {
                    "type": "string",
                    "description": "Specifies the identifier for the tag. Note: format must follow: \"databaseName\".\"schemaName\".\"tagName\" or \"databaseName.schemaName.tagName\" or \"databaseName|schemaName.tagName\" (snowflake_tag.tag.id)\n"
                },
                "tagValue": {
                    "type": "string",
                    "description": "Specifies the value of the tag, (e.g. 'finance' or 'engineering')\n"
                }
            },
            "required": [
                "objectIdentifiers",
                "objectType",
                "tagId",
                "tagValue"
            ],
            "inputProperties": {
                "objectIdentifiers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/TagAssociationObjectIdentifier:TagAssociationObjectIdentifier"
                    },
                    "description": "Specifies the object identifier for the tag association.\n"
                },
                "objectName": {
                    "type": "string",
                    "description": "Specifies the object identifier for the tag association.\n",
                    "deprecationMessage": "Use `object_identifier` instead",
                    "willReplaceOnChanges": true
                },
                "objectType": {
                    "type": "string",
                    "description": "Specifies the type of object to add a tag to. ex: 'ACCOUNT', 'COLUMN', 'DATABASE', etc. For more information: https://docs.snowflake.com/en/user-guide/object-tagging.html#supported-objects\n",
                    "willReplaceOnChanges": true
                },
                "skipValidation": {
                    "type": "boolean",
                    "description": "If true, skips validation of the tag association.\n"
                },
                "tagId": {
                    "type": "string",
                    "description": "Specifies the identifier for the tag. Note: format must follow: \"databaseName\".\"schemaName\".\"tagName\" or \"databaseName.schemaName.tagName\" or \"databaseName|schemaName.tagName\" (snowflake_tag.tag.id)\n",
                    "willReplaceOnChanges": true
                },
                "tagValue": {
                    "type": "string",
                    "description": "Specifies the value of the tag, (e.g. 'finance' or 'engineering')\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "objectIdentifiers",
                "objectType",
                "tagId",
                "tagValue"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagAssociation resources.\n",
                "properties": {
                    "objectIdentifiers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/TagAssociationObjectIdentifier:TagAssociationObjectIdentifier"
                        },
                        "description": "Specifies the object identifier for the tag association.\n"
                    },
                    "objectName": {
                        "type": "string",
                        "description": "Specifies the object identifier for the tag association.\n",
                        "deprecationMessage": "Use `object_identifier` instead",
                        "willReplaceOnChanges": true
                    },
                    "objectType": {
                        "type": "string",
                        "description": "Specifies the type of object to add a tag to. ex: 'ACCOUNT', 'COLUMN', 'DATABASE', etc. For more information: https://docs.snowflake.com/en/user-guide/object-tagging.html#supported-objects\n",
                        "willReplaceOnChanges": true
                    },
                    "skipValidation": {
                        "type": "boolean",
                        "description": "If true, skips validation of the tag association.\n"
                    },
                    "tagId": {
                        "type": "string",
                        "description": "Specifies the identifier for the tag. Note: format must follow: \"databaseName\".\"schemaName\".\"tagName\" or \"databaseName.schemaName.tagName\" or \"databaseName|schemaName.tagName\" (snowflake_tag.tag.id)\n",
                        "willReplaceOnChanges": true
                    },
                    "tagValue": {
                        "type": "string",
                        "description": "Specifies the value of the tag, (e.g. 'finance' or 'engineering')\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/tagGrant:TagGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst example = new snowflake.TagGrant(\"example\", {\n    databaseName: \"database\",\n    privilege: \"OWNERSHIP\",\n    roles: [\"TEST_ROLE\"],\n    schemaName: \"schema\",\n    tagName: \"tag\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nexample = snowflake.TagGrant(\"example\",\n    database_name=\"database\",\n    privilege=\"OWNERSHIP\",\n    roles=[\"TEST_ROLE\"],\n    schema_name=\"schema\",\n    tag_name=\"tag\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Snowflake.TagGrant(\"example\", new()\n    {\n        DatabaseName = \"database\",\n        Privilege = \"OWNERSHIP\",\n        Roles = new[]\n        {\n            \"TEST_ROLE\",\n        },\n        SchemaName = \"schema\",\n        TagName = \"tag\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewTagGrant(ctx, \"example\", \u0026snowflake.TagGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tPrivilege:    pulumi.String(\"OWNERSHIP\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"TEST_ROLE\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tTagName:    pulumi.String(\"tag\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.TagGrant;\nimport com.pulumi.snowflake.TagGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TagGrant(\"example\", TagGrantArgs.builder()        \n            .databaseName(\"database\")\n            .privilege(\"OWNERSHIP\")\n            .roles(\"TEST_ROLE\")\n            .schemaName(\"schema\")\n            .tagName(\"tag\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: snowflake:TagGrant\n    properties:\n      databaseName: database\n      privilege: OWNERSHIP\n      roles:\n        - TEST_ROLE\n      schemaName: schema\n      tagName: tag\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database|schema|tag|privilege|with_grant_option|roles\n\n```sh\n $ pulumi import snowflake:index/tagGrant:TagGrant example \"MY_DATABASE|MY_SCHEMA|MY_TAG|USAGE|false|role1,role2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the tag on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the tag. To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the tag on which to grant privileges.\n"
                },
                "tagName": {
                    "type": "string",
                    "description": "The name of the tag on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "schemaName",
                "tagName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the tag on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the tag. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the tag on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "tagName": {
                    "type": "string",
                    "description": "The name of the tag on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "schemaName",
                "tagName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the tag on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the tag. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the tag on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The name of the tag on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/tagMaskingPolicyAssociation:TagMaskingPolicyAssociation": {
            "description": "Attach a masking policy to a tag. Requires a current warehouse to be set. Either with SNOWFLAKE_WAREHOUSE env variable or in current session. If no warehouse is provided, a temporary warehouse will be created.\n\n\n## Import\n\nformat is tag database name | tag schema name | tag name | masking policy database | masking policy schema | masking policy name\n\n```sh\n $ pulumi import snowflake:index/tagMaskingPolicyAssociation:TagMaskingPolicyAssociation example 'tag_db|tag_schema|tag_name|mp_db|mp_schema|mp_name'\n```\n\n ",
            "properties": {
                "maskingPolicyId": {
                    "type": "string",
                    "description": "The resource id of the masking policy\n"
                },
                "tagId": {
                    "type": "string",
                    "description": "Specifies the identifier for the tag. Note: format must follow: \"databaseName\".\"schemaName\".\"tagName\" or \"databaseName.schemaName.tagName\" or \"databaseName|schemaName.tagName\" (snowflake_tag.tag.id)\n"
                }
            },
            "required": [
                "maskingPolicyId",
                "tagId"
            ],
            "inputProperties": {
                "maskingPolicyId": {
                    "type": "string",
                    "description": "The resource id of the masking policy\n",
                    "willReplaceOnChanges": true
                },
                "tagId": {
                    "type": "string",
                    "description": "Specifies the identifier for the tag. Note: format must follow: \"databaseName\".\"schemaName\".\"tagName\" or \"databaseName.schemaName.tagName\" or \"databaseName|schemaName.tagName\" (snowflake_tag.tag.id)\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "maskingPolicyId",
                "tagId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagMaskingPolicyAssociation resources.\n",
                "properties": {
                    "maskingPolicyId": {
                        "type": "string",
                        "description": "The resource id of the masking policy\n",
                        "willReplaceOnChanges": true
                    },
                    "tagId": {
                        "type": "string",
                        "description": "Specifies the identifier for the tag. Note: format must follow: \"databaseName\".\"schemaName\".\"tagName\" or \"databaseName.schemaName.tagName\" or \"databaseName|schemaName.tagName\" (snowflake_tag.tag.id)\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/task:Task": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst task = new snowflake.Task(\"task\", {\n    comment: \"my task\",\n    database: \"database\",\n    schema: \"schema\",\n    warehouse: \"warehouse\",\n    schedule: \"10 MINUTE\",\n    sqlStatement: \"select * from foo;\",\n    sessionParameters: {\n        foo: \"bar\",\n    },\n    userTaskTimeoutMs: 10000,\n    afters: \"preceding_task\",\n    when: \"foo AND bar\",\n    enabled: true,\n});\nconst serverlessTask = new snowflake.Task(\"serverlessTask\", {\n    comment: \"my serverless task\",\n    database: \"db\",\n    schema: \"schema\",\n    schedule: \"10 MINUTE\",\n    sqlStatement: \"select * from foo;\",\n    sessionParameters: {\n        foo: \"bar\",\n    },\n    userTaskTimeoutMs: 10000,\n    userTaskManagedInitialWarehouseSize: \"XSMALL\",\n    afters: [task.name],\n    when: \"foo AND bar\",\n    enabled: true,\n});\nconst testTask = new snowflake.Task(\"testTask\", {\n    comment: \"task with allow_overlapping_execution\",\n    database: \"database\",\n    schema: \"schema\",\n    sqlStatement: \"select 1 as c;\",\n    allowOverlappingExecution: true,\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ntask = snowflake.Task(\"task\",\n    comment=\"my task\",\n    database=\"database\",\n    schema=\"schema\",\n    warehouse=\"warehouse\",\n    schedule=\"10 MINUTE\",\n    sql_statement=\"select * from foo;\",\n    session_parameters={\n        \"foo\": \"bar\",\n    },\n    user_task_timeout_ms=10000,\n    afters=\"preceding_task\",\n    when=\"foo AND bar\",\n    enabled=True)\nserverless_task = snowflake.Task(\"serverlessTask\",\n    comment=\"my serverless task\",\n    database=\"db\",\n    schema=\"schema\",\n    schedule=\"10 MINUTE\",\n    sql_statement=\"select * from foo;\",\n    session_parameters={\n        \"foo\": \"bar\",\n    },\n    user_task_timeout_ms=10000,\n    user_task_managed_initial_warehouse_size=\"XSMALL\",\n    afters=[task.name],\n    when=\"foo AND bar\",\n    enabled=True)\ntest_task = snowflake.Task(\"testTask\",\n    comment=\"task with allow_overlapping_execution\",\n    database=\"database\",\n    schema=\"schema\",\n    sql_statement=\"select 1 as c;\",\n    allow_overlapping_execution=True,\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var task = new Snowflake.Task(\"task\", new()\n    {\n        Comment = \"my task\",\n        Database = \"database\",\n        Schema = \"schema\",\n        Warehouse = \"warehouse\",\n        Schedule = \"10 MINUTE\",\n        SqlStatement = \"select * from foo;\",\n        SessionParameters = \n        {\n            { \"foo\", \"bar\" },\n        },\n        UserTaskTimeoutMs = 10000,\n        Afters = \"preceding_task\",\n        When = \"foo AND bar\",\n        Enabled = true,\n    });\n\n    var serverlessTask = new Snowflake.Task(\"serverlessTask\", new()\n    {\n        Comment = \"my serverless task\",\n        Database = \"db\",\n        Schema = \"schema\",\n        Schedule = \"10 MINUTE\",\n        SqlStatement = \"select * from foo;\",\n        SessionParameters = \n        {\n            { \"foo\", \"bar\" },\n        },\n        UserTaskTimeoutMs = 10000,\n        UserTaskManagedInitialWarehouseSize = \"XSMALL\",\n        Afters = new[]\n        {\n            task.Name,\n        },\n        When = \"foo AND bar\",\n        Enabled = true,\n    });\n\n    var testTask = new Snowflake.Task(\"testTask\", new()\n    {\n        Comment = \"task with allow_overlapping_execution\",\n        Database = \"database\",\n        Schema = \"schema\",\n        SqlStatement = \"select 1 as c;\",\n        AllowOverlappingExecution = true,\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttask, err := snowflake.NewTask(ctx, \"task\", \u0026snowflake.TaskArgs{\n\t\t\tComment:      pulumi.String(\"my task\"),\n\t\t\tDatabase:     pulumi.String(\"database\"),\n\t\t\tSchema:       pulumi.String(\"schema\"),\n\t\t\tWarehouse:    pulumi.String(\"warehouse\"),\n\t\t\tSchedule:     pulumi.String(\"10 MINUTE\"),\n\t\t\tSqlStatement: pulumi.String(\"select * from foo;\"),\n\t\t\tSessionParameters: pulumi.StringMap{\n\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t},\n\t\t\tUserTaskTimeoutMs: pulumi.Int(10000),\n\t\t\tAfters:            pulumi.StringArray(\"preceding_task\"),\n\t\t\tWhen:              pulumi.String(\"foo AND bar\"),\n\t\t\tEnabled:           pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTask(ctx, \"serverlessTask\", \u0026snowflake.TaskArgs{\n\t\t\tComment:      pulumi.String(\"my serverless task\"),\n\t\t\tDatabase:     pulumi.String(\"db\"),\n\t\t\tSchema:       pulumi.String(\"schema\"),\n\t\t\tSchedule:     pulumi.String(\"10 MINUTE\"),\n\t\t\tSqlStatement: pulumi.String(\"select * from foo;\"),\n\t\t\tSessionParameters: pulumi.StringMap{\n\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t},\n\t\t\tUserTaskTimeoutMs:                   pulumi.Int(10000),\n\t\t\tUserTaskManagedInitialWarehouseSize: pulumi.String(\"XSMALL\"),\n\t\t\tAfters: pulumi.StringArray{\n\t\t\t\ttask.Name,\n\t\t\t},\n\t\t\tWhen:    pulumi.String(\"foo AND bar\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewTask(ctx, \"testTask\", \u0026snowflake.TaskArgs{\n\t\t\tComment:                   pulumi.String(\"task with allow_overlapping_execution\"),\n\t\t\tDatabase:                  pulumi.String(\"database\"),\n\t\t\tSchema:                    pulumi.String(\"schema\"),\n\t\t\tSqlStatement:              pulumi.String(\"select 1 as c;\"),\n\t\t\tAllowOverlappingExecution: pulumi.Bool(true),\n\t\t\tEnabled:                   pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Task;\nimport com.pulumi.snowflake.TaskArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var task = new Task(\"task\", TaskArgs.builder()        \n            .comment(\"my task\")\n            .database(\"database\")\n            .schema(\"schema\")\n            .warehouse(\"warehouse\")\n            .schedule(\"10 MINUTE\")\n            .sqlStatement(\"select * from foo;\")\n            .sessionParameters(Map.of(\"foo\", \"bar\"))\n            .userTaskTimeoutMs(10000)\n            .afters(\"preceding_task\")\n            .when(\"foo AND bar\")\n            .enabled(true)\n            .build());\n\n        var serverlessTask = new Task(\"serverlessTask\", TaskArgs.builder()        \n            .comment(\"my serverless task\")\n            .database(\"db\")\n            .schema(\"schema\")\n            .schedule(\"10 MINUTE\")\n            .sqlStatement(\"select * from foo;\")\n            .sessionParameters(Map.of(\"foo\", \"bar\"))\n            .userTaskTimeoutMs(10000)\n            .userTaskManagedInitialWarehouseSize(\"XSMALL\")\n            .afters(task.name())\n            .when(\"foo AND bar\")\n            .enabled(true)\n            .build());\n\n        var testTask = new Task(\"testTask\", TaskArgs.builder()        \n            .comment(\"task with allow_overlapping_execution\")\n            .database(\"database\")\n            .schema(\"schema\")\n            .sqlStatement(\"select 1 as c;\")\n            .allowOverlappingExecution(true)\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  task:\n    type: snowflake:Task\n    properties:\n      comment: my task\n      database: database\n      schema: schema\n      warehouse: warehouse\n      schedule: 10 MINUTE\n      sqlStatement: select * from foo;\n      sessionParameters:\n        foo: bar\n      userTaskTimeoutMs: 10000\n      afters: preceding_task\n      when: foo AND bar\n      enabled: true\n  serverlessTask:\n    type: snowflake:Task\n    properties:\n      comment: my serverless task\n      database: db\n      schema: schema\n      schedule: 10 MINUTE\n      sqlStatement: select * from foo;\n      sessionParameters:\n        foo: bar\n      userTaskTimeoutMs: 10000\n      userTaskManagedInitialWarehouseSize: XSMALL\n      afters:\n        - ${task.name}\n      when: foo AND bar\n      enabled: true\n  testTask:\n    type: snowflake:Task\n    properties:\n      comment: task with allow_overlapping_execution\n      database: database\n      schema: schema\n      sqlStatement: select 1 as c;\n      allowOverlappingExecution: true\n      enabled: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | task name\n\n```sh\n $ pulumi import snowflake:index/task:Task example 'dbName|schemaName|taskName'\n```\n\n ",
            "properties": {
                "afters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more predecessor tasks for the current task. Use this option to create a DAG of tasks or add this task to an existing DAG. A DAG is a series of tasks that starts with a scheduled root task and is linked together by dependencies.\n"
                },
                "allowOverlappingExecution": {
                    "type": "boolean",
                    "description": "By default, Snowflake ensures that only one instance of a particular DAG is allowed to run at a time, setting the parameter value to TRUE permits DAG runs to overlap.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the task.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the task.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies if the task should be started (enabled) after creation or should remain suspended (default).\n"
                },
                "errorIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the notification integration used for error notifications.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the task; must be unique for the database and schema in which the task is created.\n"
                },
                "schedule": {
                    "type": "string",
                    "description": "The schedule for periodically running the task. This can be a cron or interval in minutes. (Conflict with after)\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the task.\n"
                },
                "sessionParameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies session parameters to set for the session when the task runs. A task supports all session parameters.\n"
                },
                "sqlStatement": {
                    "type": "string",
                    "description": "Any single SQL statement, or a call to a stored procedure, executed when the task runs.\n"
                },
                "suspendTaskAfterNumFailures": {
                    "type": "integer",
                    "description": "Specifies the number of consecutive failed task runs after which the current task is suspended automatically. The default is 0 (no automatic suspension).\n"
                },
                "userTaskManagedInitialWarehouseSize": {
                    "type": "string",
                    "description": "Specifies the size of the compute resources to provision for the first run of the task, before a task history is available for Snowflake to determine an ideal size. Once a task has successfully completed a few runs, Snowflake ignores this parameter setting. (Conflicts with warehouse)\n"
                },
                "userTaskTimeoutMs": {
                    "type": "integer",
                    "description": "Specifies the time limit on a single run of the task before it times out (in milliseconds).\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse the task will use. Omit this parameter to use Snowflake-managed compute resources for runs of this task. (Conflicts with user*task*managed*initial*warehouse_size)\n"
                },
                "when": {
                    "type": "string",
                    "description": "Specifies a Boolean SQL expression; multiple conditions joined with AND/OR are supported.\n"
                }
            },
            "required": [
                "database",
                "name",
                "schema",
                "sqlStatement"
            ],
            "inputProperties": {
                "afters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies one or more predecessor tasks for the current task. Use this option to create a DAG of tasks or add this task to an existing DAG. A DAG is a series of tasks that starts with a scheduled root task and is linked together by dependencies.\n"
                },
                "allowOverlappingExecution": {
                    "type": "boolean",
                    "description": "By default, Snowflake ensures that only one instance of a particular DAG is allowed to run at a time, setting the parameter value to TRUE permits DAG runs to overlap.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the task.\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database in which to create the task.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies if the task should be started (enabled) after creation or should remain suspended (default).\n"
                },
                "errorIntegration": {
                    "type": "string",
                    "description": "Specifies the name of the notification integration used for error notifications.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the identifier for the task; must be unique for the database and schema in which the task is created.\n",
                    "willReplaceOnChanges": true
                },
                "schedule": {
                    "type": "string",
                    "description": "The schedule for periodically running the task. This can be a cron or interval in minutes. (Conflict with after)\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema in which to create the task.\n",
                    "willReplaceOnChanges": true
                },
                "sessionParameters": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies session parameters to set for the session when the task runs. A task supports all session parameters.\n"
                },
                "sqlStatement": {
                    "type": "string",
                    "description": "Any single SQL statement, or a call to a stored procedure, executed when the task runs.\n"
                },
                "suspendTaskAfterNumFailures": {
                    "type": "integer",
                    "description": "Specifies the number of consecutive failed task runs after which the current task is suspended automatically. The default is 0 (no automatic suspension).\n"
                },
                "userTaskManagedInitialWarehouseSize": {
                    "type": "string",
                    "description": "Specifies the size of the compute resources to provision for the first run of the task, before a task history is available for Snowflake to determine an ideal size. Once a task has successfully completed a few runs, Snowflake ignores this parameter setting. (Conflicts with warehouse)\n"
                },
                "userTaskTimeoutMs": {
                    "type": "integer",
                    "description": "Specifies the time limit on a single run of the task before it times out (in milliseconds).\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "The warehouse the task will use. Omit this parameter to use Snowflake-managed compute resources for runs of this task. (Conflicts with user*task*managed*initial*warehouse_size)\n"
                },
                "when": {
                    "type": "string",
                    "description": "Specifies a Boolean SQL expression; multiple conditions joined with AND/OR are supported.\n"
                }
            },
            "requiredInputs": [
                "database",
                "schema",
                "sqlStatement"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Task resources.\n",
                "properties": {
                    "afters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies one or more predecessor tasks for the current task. Use this option to create a DAG of tasks or add this task to an existing DAG. A DAG is a series of tasks that starts with a scheduled root task and is linked together by dependencies.\n"
                    },
                    "allowOverlappingExecution": {
                        "type": "boolean",
                        "description": "By default, Snowflake ensures that only one instance of a particular DAG is allowed to run at a time, setting the parameter value to TRUE permits DAG runs to overlap.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the task.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database in which to create the task.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Specifies if the task should be started (enabled) after creation or should remain suspended (default).\n"
                    },
                    "errorIntegration": {
                        "type": "string",
                        "description": "Specifies the name of the notification integration used for error notifications.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the identifier for the task; must be unique for the database and schema in which the task is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "schedule": {
                        "type": "string",
                        "description": "The schedule for periodically running the task. This can be a cron or interval in minutes. (Conflict with after)\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema in which to create the task.\n",
                        "willReplaceOnChanges": true
                    },
                    "sessionParameters": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies session parameters to set for the session when the task runs. A task supports all session parameters.\n"
                    },
                    "sqlStatement": {
                        "type": "string",
                        "description": "Any single SQL statement, or a call to a stored procedure, executed when the task runs.\n"
                    },
                    "suspendTaskAfterNumFailures": {
                        "type": "integer",
                        "description": "Specifies the number of consecutive failed task runs after which the current task is suspended automatically. The default is 0 (no automatic suspension).\n"
                    },
                    "userTaskManagedInitialWarehouseSize": {
                        "type": "string",
                        "description": "Specifies the size of the compute resources to provision for the first run of the task, before a task history is available for Snowflake to determine an ideal size. Once a task has successfully completed a few runs, Snowflake ignores this parameter setting. (Conflicts with warehouse)\n"
                    },
                    "userTaskTimeoutMs": {
                        "type": "integer",
                        "description": "Specifies the time limit on a single run of the task before it times out (in milliseconds).\n"
                    },
                    "warehouse": {
                        "type": "string",
                        "description": "The warehouse the task will use. Omit this parameter to use Snowflake-managed compute resources for runs of this task. (Conflicts with user*task*managed*initial*warehouse_size)\n"
                    },
                    "when": {
                        "type": "string",
                        "description": "Specifies a Boolean SQL expression; multiple conditions joined with AND/OR are supported.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/taskGrant:TaskGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.TaskGrant(\"grant\", {\n    databaseName: \"database\",\n    onFuture: false,\n    privilege: \"OPERATE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    taskName: \"task\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.TaskGrant(\"grant\",\n    database_name=\"database\",\n    on_future=False,\n    privilege=\"OPERATE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    task_name=\"task\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.TaskGrant(\"grant\", new()\n    {\n        DatabaseName = \"database\",\n        OnFuture = false,\n        Privilege = \"OPERATE\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        TaskName = \"task\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewTaskGrant(ctx, \"grant\", \u0026snowflake.TaskGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"OPERATE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName:      pulumi.String(\"schema\"),\n\t\t\tTaskName:        pulumi.String(\"task\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.TaskGrant;\nimport com.pulumi.snowflake.TaskGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new TaskGrant(\"grant\", TaskGrantArgs.builder()        \n            .databaseName(\"database\")\n            .onFuture(false)\n            .privilege(\"OPERATE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .taskName(\"task\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:TaskGrant\n    properties:\n      databaseName: database\n      onFuture: false\n      privilege: OPERATE\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      taskName: task\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|task_name|privilege|with_grant_option|on_future|roles\"\n\n```sh\n $ pulumi import snowflake:index/taskGrant:TaskGrant example \"MY_DATABASE|MY_SCHEMA|MY_TASK|OPERATE|false|false|role1,role2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future tasks on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all tasks in the given schema. When this is true and no schema*name is provided apply this grant on all tasks in the given database. The task*name field must be unset in order to use on*all. Cannot be used together with on_future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future tasks in the given schema. When this is true and no schema*name is provided apply this grant on all future tasks in the given database. The task*name field must be unset in order to use on*future. Cannot be used together with on_all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future task. To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future tasks on which to grant privileges.\n"
                },
                "taskName": {
                    "type": "string",
                    "description": "The name of the task on which to grant privileges immediately (only valid if on_future is false).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName",
                "roles"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future tasks on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                    "willReplaceOnChanges": true
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all tasks in the given schema. When this is true and no schema*name is provided apply this grant on all tasks in the given database. The task*name field must be unset in order to use on*all. Cannot be used together with on_future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future tasks in the given schema. When this is true and no schema*name is provided apply this grant on all future tasks in the given database. The task*name field must be unset in order to use on*future. Cannot be used together with on_all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future task. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future tasks on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "taskName": {
                    "type": "string",
                    "description": "The name of the task on which to grant privileges immediately (only valid if on_future is false).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName",
                "roles"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TaskGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future tasks on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n",
                        "willReplaceOnChanges": true
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all tasks in the given schema. When this is true and no schema*name is provided apply this grant on all tasks in the given database. The task*name field must be unset in order to use on*all. Cannot be used together with on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future tasks in the given schema. When this is true and no schema*name is provided apply this grant on all future tasks in the given database. The task*name field must be unset in order to use on*future. Cannot be used together with on_all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future task. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future tasks on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "taskName": {
                        "type": "string",
                        "description": "The name of the task on which to grant privileges immediately (only valid if on_future is false).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/unsafeExecute:UnsafeExecute": {
            "description": "!\u003e **Warning** This is a dangerous resource that allows executing **ANY** SQL statement. It may destroy resources if used incorrectly. It may behave incorrectly combined with other resources. Will be deleted in the upcoming versions. Use at your own risk.\n\n\u003e **Note** It can be theoretically used to manage resource that are not supported by the provider. This is risky and may brake other resources if used incorrectly.\n\n\u003e **Note** Use `query` parameter with caution. It will fetch **ALL** the results returned by the query provided. Try to limit the number of results by writing query with filters. Query failure does not stop resource creation; it simply results in `query_results` being empty.\n\nExperimental resource used for testing purposes only. Allows to execute ANY SQL statement.\n\n{{% examples %}}\n## Example Usage\n### simple use cases\n##################################\n\n# create and destroy resource\nresource \"snowflake_unsafe_execute\" \"test\" {\n  execute = \"CREATE DATABASE ABC\"\n  revert  = \"DROP DATABASE ABC\"\n}\n\n# create and destroy resource using qualified name\nresource \"snowflake_unsafe_execute\" \"test\" {\n  execute = \"CREATE DATABASE \\\"abc\\\"\"\n  revert  = \"DROP DATABASE \\\"abc\\\"\"\n}\n\n# with query\nresource \"snowflake_unsafe_execute\" \"test\" {\n  execute = \"CREATE DATABASE ABC\"\n  revert  = \"DROP DATABASE ABC\"\n  query   = \"SHOW DATABASES LIKE '%ABC%'\"\n}\n\n##################################\n### grants example\n##################################\n\n# grant and revoke privilege USAGE to ROLE on database\nresource \"snowflake_unsafe_execute\" \"test\" {\n  execute = \"GRANT USAGE ON DATABASE ABC TO ROLE XYZ\"\n  revert  = \"REVOKE USAGE ON DATABASE ABC FROM ROLE XYZ\"\n}\n\n# grant and revoke with for_each\nvariable \"database_grants\" {\n  type = list(object({\n    database_name = string\n    role_id       = string\n    privileges    = list(string)\n  }))\n}\n\nresource \"snowflake_unsafe_execute\" \"test\" {\n  for_each = { for index, db_grant in var.database_grants : index =\u003e db_grant }\n  execute  = \"GRANT ${join(\",\", each.value.privileges)} ON DATABASE ${each.value.database_name} TO ROLE ${each.value.role_id}\"\n  revert   = \"REVOKE ${join(\",\", each.value.privileges)} ON DATABASE ${each.value.database_name} FROM ROLE ${each.value.role_id}\"\n}\n\n##################################\n{{% /examples %}}",
            "properties": {
                "execute": {
                    "type": "string",
                    "description": "SQL statement to execute. Forces recreation of resource on change.\n"
                },
                "query": {
                    "type": "string",
                    "description": "Optional SQL statement to do a read. Invoked after creation and every time it is changed.\n"
                },
                "queryResults": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "description": "List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.\n"
                },
                "revert": {
                    "type": "string",
                    "description": "SQL statement to revert the execute statement. Invoked when resource is being destroyed.\n"
                }
            },
            "required": [
                "execute",
                "queryResults",
                "revert"
            ],
            "inputProperties": {
                "execute": {
                    "type": "string",
                    "description": "SQL statement to execute. Forces recreation of resource on change.\n",
                    "willReplaceOnChanges": true
                },
                "query": {
                    "type": "string",
                    "description": "Optional SQL statement to do a read. Invoked after creation and every time it is changed.\n"
                },
                "revert": {
                    "type": "string",
                    "description": "SQL statement to revert the execute statement. Invoked when resource is being destroyed.\n"
                }
            },
            "requiredInputs": [
                "execute",
                "revert"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UnsafeExecute resources.\n",
                "properties": {
                    "execute": {
                        "type": "string",
                        "description": "SQL statement to execute. Forces recreation of resource on change.\n",
                        "willReplaceOnChanges": true
                    },
                    "query": {
                        "type": "string",
                        "description": "Optional SQL statement to do a read. Invoked after creation and every time it is changed.\n"
                    },
                    "queryResults": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        },
                        "description": "List of key-value maps (text to text) retrieved after executing read query. Will be empty if the query results in an error.\n"
                    },
                    "revert": {
                        "type": "string",
                        "description": "SQL statement to revert the execute statement. Invoked when resource is being destroyed.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/user:User": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst user = new snowflake.User(\"user\", {\n    comment: \"A user of snowflake.\",\n    defaultRole: \"role1\",\n    defaultSecondaryRoles: [\"ALL\"],\n    defaultWarehouse: \"warehouse\",\n    disabled: false,\n    displayName: \"Snowflake User\",\n    email: \"user@snowflake.example\",\n    firstName: \"Snowflake\",\n    lastName: \"User\",\n    loginName: \"snowflake_user\",\n    mustChangePassword: false,\n    password: \"secret\",\n    rsaPublicKey: \"...\",\n    rsaPublicKey2: \"...\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nuser = snowflake.User(\"user\",\n    comment=\"A user of snowflake.\",\n    default_role=\"role1\",\n    default_secondary_roles=[\"ALL\"],\n    default_warehouse=\"warehouse\",\n    disabled=False,\n    display_name=\"Snowflake User\",\n    email=\"user@snowflake.example\",\n    first_name=\"Snowflake\",\n    last_name=\"User\",\n    login_name=\"snowflake_user\",\n    must_change_password=False,\n    password=\"secret\",\n    rsa_public_key=\"...\",\n    rsa_public_key2=\"...\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var user = new Snowflake.User(\"user\", new()\n    {\n        Comment = \"A user of snowflake.\",\n        DefaultRole = \"role1\",\n        DefaultSecondaryRoles = new[]\n        {\n            \"ALL\",\n        },\n        DefaultWarehouse = \"warehouse\",\n        Disabled = false,\n        DisplayName = \"Snowflake User\",\n        Email = \"user@snowflake.example\",\n        FirstName = \"Snowflake\",\n        LastName = \"User\",\n        LoginName = \"snowflake_user\",\n        MustChangePassword = false,\n        Password = \"secret\",\n        RsaPublicKey = \"...\",\n        RsaPublicKey2 = \"...\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewUser(ctx, \"user\", \u0026snowflake.UserArgs{\n\t\t\tComment:     pulumi.String(\"A user of snowflake.\"),\n\t\t\tDefaultRole: pulumi.String(\"role1\"),\n\t\t\tDefaultSecondaryRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ALL\"),\n\t\t\t},\n\t\t\tDefaultWarehouse:   pulumi.String(\"warehouse\"),\n\t\t\tDisabled:           pulumi.Bool(false),\n\t\t\tDisplayName:        pulumi.String(\"Snowflake User\"),\n\t\t\tEmail:              pulumi.String(\"user@snowflake.example\"),\n\t\t\tFirstName:          pulumi.String(\"Snowflake\"),\n\t\t\tLastName:           pulumi.String(\"User\"),\n\t\t\tLoginName:          pulumi.String(\"snowflake_user\"),\n\t\t\tMustChangePassword: pulumi.Bool(false),\n\t\t\tPassword:           pulumi.String(\"secret\"),\n\t\t\tRsaPublicKey:       pulumi.String(\"...\"),\n\t\t\tRsaPublicKey2:      pulumi.String(\"...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.User;\nimport com.pulumi.snowflake.UserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var user = new User(\"user\", UserArgs.builder()        \n            .comment(\"A user of snowflake.\")\n            .defaultRole(\"role1\")\n            .defaultSecondaryRoles(\"ALL\")\n            .defaultWarehouse(\"warehouse\")\n            .disabled(false)\n            .displayName(\"Snowflake User\")\n            .email(\"user@snowflake.example\")\n            .firstName(\"Snowflake\")\n            .lastName(\"User\")\n            .loginName(\"snowflake_user\")\n            .mustChangePassword(false)\n            .password(\"secret\")\n            .rsaPublicKey(\"...\")\n            .rsaPublicKey2(\"...\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  user:\n    type: snowflake:User\n    properties:\n      comment: A user of snowflake.\n      defaultRole: role1\n      defaultSecondaryRoles:\n        - ALL\n      defaultWarehouse: warehouse\n      disabled: false\n      displayName: Snowflake User\n      email: user@snowflake.example\n      firstName: Snowflake\n      lastName: User\n      loginName: snowflake_user\n      mustChangePassword: false\n      password: secret\n      rsaPublicKey: '...'\n      rsaPublicKey2: '...'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/user:User example userName\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string"
                },
                "defaultNamespace": {
                    "type": "string",
                    "description": "Specifies the namespace (database only or database and schema) that is active by default for the user’s session upon login.\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "Specifies the role that is active by default for the user’s session upon login.\n"
                },
                "defaultSecondaryRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the set of secondary roles that are active for the user’s session upon login. Currently only [\"ALL\"] value is supported - more information can be found in [doc](https://docs.snowflake.com/en/sql-reference/sql/create-user#optional-object-properties-objectproperties)\n"
                },
                "defaultWarehouse": {
                    "type": "string",
                    "description": "Specifies the virtual warehouse that is active by default for the user’s session upon login.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "displayName": {
                    "type": "string",
                    "description": "Name displayed for the user in the Snowflake web interface.\n",
                    "secret": true
                },
                "email": {
                    "type": "string",
                    "description": "Email address for the user.\n",
                    "secret": true
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the user.\n",
                    "secret": true
                },
                "hasRsaPublicKey": {
                    "type": "boolean",
                    "description": "Will be true if user as an RSA key set.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the user.\n",
                    "secret": true
                },
                "loginName": {
                    "type": "string",
                    "description": "The name users use to log in. If not supplied, snowflake will use name instead.\n"
                },
                "mustChangePassword": {
                    "type": "boolean",
                    "description": "Specifies whether the user is forced to change their password on next login (including their first/initial login) into the system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the user. Note that if you do not supply login*name this will be used as login*name. [doc](https://docs.snowflake.net/manuals/sql-reference/sql/create-user.html#required-parameters)\n",
                    "secret": true
                },
                "password": {
                    "type": "string",
                    "description": "**WARNING:** this will put the password in the terraform state file. Use carefully.\n",
                    "secret": true
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies the user’s RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies the user’s second RSA public key; used to rotate the public and private keys for key-pair authentication based on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                }
            },
            "required": [
                "defaultRole",
                "disabled",
                "displayName",
                "hasRsaPublicKey",
                "loginName",
                "name"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string"
                },
                "defaultNamespace": {
                    "type": "string",
                    "description": "Specifies the namespace (database only or database and schema) that is active by default for the user’s session upon login.\n"
                },
                "defaultRole": {
                    "type": "string",
                    "description": "Specifies the role that is active by default for the user’s session upon login.\n"
                },
                "defaultSecondaryRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the set of secondary roles that are active for the user’s session upon login. Currently only [\"ALL\"] value is supported - more information can be found in [doc](https://docs.snowflake.com/en/sql-reference/sql/create-user#optional-object-properties-objectproperties)\n"
                },
                "defaultWarehouse": {
                    "type": "string",
                    "description": "Specifies the virtual warehouse that is active by default for the user’s session upon login.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "displayName": {
                    "type": "string",
                    "description": "Name displayed for the user in the Snowflake web interface.\n",
                    "secret": true
                },
                "email": {
                    "type": "string",
                    "description": "Email address for the user.\n",
                    "secret": true
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the user.\n",
                    "secret": true
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the user.\n",
                    "secret": true
                },
                "loginName": {
                    "type": "string",
                    "description": "The name users use to log in. If not supplied, snowflake will use name instead.\n"
                },
                "mustChangePassword": {
                    "type": "boolean",
                    "description": "Specifies whether the user is forced to change their password on next login (including their first/initial login) into the system.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the user. Note that if you do not supply login*name this will be used as login*name. [doc](https://docs.snowflake.net/manuals/sql-reference/sql/create-user.html#required-parameters)\n",
                    "secret": true
                },
                "password": {
                    "type": "string",
                    "description": "**WARNING:** this will put the password in the terraform state file. Use carefully.\n",
                    "secret": true
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies the user’s RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies the user’s second RSA public key; used to rotate the public and private keys for key-pair authentication based on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "comment": {
                        "type": "string"
                    },
                    "defaultNamespace": {
                        "type": "string",
                        "description": "Specifies the namespace (database only or database and schema) that is active by default for the user’s session upon login.\n"
                    },
                    "defaultRole": {
                        "type": "string",
                        "description": "Specifies the role that is active by default for the user’s session upon login.\n"
                    },
                    "defaultSecondaryRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies the set of secondary roles that are active for the user’s session upon login. Currently only [\"ALL\"] value is supported - more information can be found in [doc](https://docs.snowflake.com/en/sql-reference/sql/create-user#optional-object-properties-objectproperties)\n"
                    },
                    "defaultWarehouse": {
                        "type": "string",
                        "description": "Specifies the virtual warehouse that is active by default for the user’s session upon login.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Name displayed for the user in the Snowflake web interface.\n",
                        "secret": true
                    },
                    "email": {
                        "type": "string",
                        "description": "Email address for the user.\n",
                        "secret": true
                    },
                    "firstName": {
                        "type": "string",
                        "description": "First name of the user.\n",
                        "secret": true
                    },
                    "hasRsaPublicKey": {
                        "type": "boolean",
                        "description": "Will be true if user as an RSA key set.\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "Last name of the user.\n",
                        "secret": true
                    },
                    "loginName": {
                        "type": "string",
                        "description": "The name users use to log in. If not supplied, snowflake will use name instead.\n"
                    },
                    "mustChangePassword": {
                        "type": "boolean",
                        "description": "Specifies whether the user is forced to change their password on next login (including their first/initial login) into the system.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the user. Note that if you do not supply login*name this will be used as login*name. [doc](https://docs.snowflake.net/manuals/sql-reference/sql/create-user.html#required-parameters)\n",
                        "secret": true
                    },
                    "password": {
                        "type": "string",
                        "description": "**WARNING:** this will put the password in the terraform state file. Use carefully.\n",
                        "secret": true
                    },
                    "rsaPublicKey": {
                        "type": "string",
                        "description": "Specifies the user’s RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                    },
                    "rsaPublicKey2": {
                        "type": "string",
                        "description": "Specifies the user’s second RSA public key; used to rotate the public and private keys for key-pair authentication based on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/userGrant:UserGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.UserGrant(\"grant\", {\n    privilege: \"MONITOR\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    userName: \"user\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.UserGrant(\"grant\",\n    privilege=\"MONITOR\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    user_name=\"user\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.UserGrant(\"grant\", new()\n    {\n        Privilege = \"MONITOR\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        UserName = \"user\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewUserGrant(ctx, \"grant\", \u0026snowflake.UserGrantArgs{\n\t\t\tPrivilege: pulumi.String(\"MONITOR\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tUserName:        pulumi.String(\"user\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.UserGrant;\nimport com.pulumi.snowflake.UserGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new UserGrant(\"grant\", UserGrantArgs.builder()        \n            .privilege(\"MONITOR\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .userName(\"user\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:UserGrant\n    properties:\n      privilege: MONITOR\n      roles:\n        - role1\n        - role2\n      userName: user\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is user_name|privilege|with_grant_option|roles\n\n```sh\n $ pulumi import snowflake:index/userGrant:UserGrant example \"USERNAME|MONITOR|false|role1,role2\"\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the user. To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "userName": {
                    "type": "string",
                    "description": "The name of the user on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "privilege",
                "userName"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the user. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "userName": {
                    "type": "string",
                    "description": "The name of the user on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "privilege",
                "userName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the user. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "userName": {
                        "type": "string",
                        "description": "The name of the user on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/userOwnershipGrant:UserOwnershipGrant": {
            "properties": {
                "currentGrants": {
                    "type": "string",
                    "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to a new role.\n"
                },
                "onUserName": {
                    "type": "string",
                    "description": "The name of the user ownership is granted on.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy.\n"
                },
                "toRoleName": {
                    "type": "string",
                    "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                }
            },
            "required": [
                "onUserName",
                "toRoleName"
            ],
            "inputProperties": {
                "currentGrants": {
                    "type": "string",
                    "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to a new role.\n"
                },
                "onUserName": {
                    "type": "string",
                    "description": "The name of the user ownership is granted on.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy.\n"
                },
                "toRoleName": {
                    "type": "string",
                    "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                }
            },
            "requiredInputs": [
                "onUserName",
                "toRoleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserOwnershipGrant resources.\n",
                "properties": {
                    "currentGrants": {
                        "type": "string",
                        "description": "Specifies whether to remove or transfer all existing outbound privileges on the object when ownership is transferred to a new role.\n"
                    },
                    "onUserName": {
                        "type": "string",
                        "description": "The name of the user ownership is granted on.\n"
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy.\n"
                    },
                    "toRoleName": {
                        "type": "string",
                        "description": "The name of the role to grant ownership. Please ensure that the role that terraform is using is granted access.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/userPublicKeys:UserPublicKeys": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the user.\n"
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies the user’s RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies the user’s second RSA public key; used to rotate the public and Public keys for key-pair authentication based on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Name of the user.\n",
                    "willReplaceOnChanges": true
                },
                "rsaPublicKey": {
                    "type": "string",
                    "description": "Specifies the user’s RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                },
                "rsaPublicKey2": {
                    "type": "string",
                    "description": "Specifies the user’s second RSA public key; used to rotate the public and Public keys for key-pair authentication based on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPublicKeys resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the user.\n",
                        "willReplaceOnChanges": true
                    },
                    "rsaPublicKey": {
                        "type": "string",
                        "description": "Specifies the user’s RSA public key; used for key-pair authentication. Must be on 1 line without header and trailer.\n"
                    },
                    "rsaPublicKey2": {
                        "type": "string",
                        "description": "Specifies the user’s second RSA public key; used to rotate the public and Public keys for key-pair authentication based on an expiration schedule set by your organization. Must be on 1 line without header and trailer.\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/view:View": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst view = new snowflake.View(\"view\", {\n    database: \"database\",\n    schema: \"schema\",\n    comment: \"comment\",\n    statement: \"select * from foo;\\n\",\n    orReplace: false,\n    isSecure: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nview = snowflake.View(\"view\",\n    database=\"database\",\n    schema=\"schema\",\n    comment=\"comment\",\n    statement=\"select * from foo;\\n\",\n    or_replace=False,\n    is_secure=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var view = new Snowflake.View(\"view\", new()\n    {\n        Database = \"database\",\n        Schema = \"schema\",\n        Comment = \"comment\",\n        Statement = @\"select * from foo;\n\",\n        OrReplace = false,\n        IsSecure = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewView(ctx, \"view\", \u0026snowflake.ViewArgs{\n\t\t\tDatabase:  pulumi.String(\"database\"),\n\t\t\tSchema:    pulumi.String(\"schema\"),\n\t\t\tComment:   pulumi.String(\"comment\"),\n\t\t\tStatement: pulumi.String(\"select * from foo;\\n\"),\n\t\t\tOrReplace: pulumi.Bool(false),\n\t\t\tIsSecure:  pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.View;\nimport com.pulumi.snowflake.ViewArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var view = new View(\"view\", ViewArgs.builder()        \n            .database(\"database\")\n            .schema(\"schema\")\n            .comment(\"comment\")\n            .statement(\"\"\"\nselect * from foo;\n            \"\"\")\n            .orReplace(false)\n            .isSecure(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  view:\n    type: snowflake:View\n    properties:\n      database: database\n      schema: schema\n      comment: comment\n      statement: |\n        select * from foo;\n      orReplace: false\n      isSecure: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database name | schema name | view name\n\n```sh\n $ pulumi import snowflake:index/view:View example 'dbName|schemaName|viewName'\n```\n\n ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the view.\n"
                },
                "copyGrants": {
                    "type": "boolean",
                    "description": "Retains the access permissions from the original view when a new view is created using the OR REPLACE clause.\n"
                },
                "createdOn": {
                    "type": "string",
                    "description": "The timestamp at which the view was created.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n"
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the view is secure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Overwrites the View if it exists.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n"
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the query used to create the view.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ViewTag:ViewTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "required": [
                "createdOn",
                "database",
                "name",
                "schema",
                "statement"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Specifies a comment for the view.\n"
                },
                "copyGrants": {
                    "type": "boolean",
                    "description": "Retains the access permissions from the original view when a new view is created using the OR REPLACE clause.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "isSecure": {
                    "type": "boolean",
                    "description": "Specifies that the view is secure.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Tag name, e.g. department.\n"
                },
                "orReplace": {
                    "type": "boolean",
                    "description": "Overwrites the View if it exists.\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Name of the schema that the tag was created in.\n",
                    "willReplaceOnChanges": true
                },
                "statement": {
                    "type": "string",
                    "description": "Specifies the query used to create the view.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/snowflake:index/ViewTag:ViewTag"
                    },
                    "description": "Definitions of a tag to associate with the resource.\n",
                    "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                }
            },
            "requiredInputs": [
                "database",
                "schema",
                "statement"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering View resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Specifies a comment for the view.\n"
                    },
                    "copyGrants": {
                        "type": "boolean",
                        "description": "Retains the access permissions from the original view when a new view is created using the OR REPLACE clause.\n"
                    },
                    "createdOn": {
                        "type": "string",
                        "description": "The timestamp at which the view was created.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "isSecure": {
                        "type": "boolean",
                        "description": "Specifies that the view is secure.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Tag name, e.g. department.\n"
                    },
                    "orReplace": {
                        "type": "boolean",
                        "description": "Overwrites the View if it exists.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "Name of the schema that the tag was created in.\n",
                        "willReplaceOnChanges": true
                    },
                    "statement": {
                        "type": "string",
                        "description": "Specifies the query used to create the view.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/ViewTag:ViewTag"
                        },
                        "description": "Definitions of a tag to associate with the resource.\n",
                        "deprecationMessage": "Use the 'snowflake_tag_association' resource instead."
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/viewGrant:ViewGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grantViewGrant = new snowflake.ViewGrant(\"grantViewGrant\", {\n    databaseName: \"database\",\n    onFuture: false,\n    privilege: \"SELECT\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n    shares: [\n        \"share1\",\n        \"share2\",\n    ],\n    viewName: \"view\",\n    withGrantOption: false,\n});\nconst grantSchemaGrant = new snowflake.SchemaGrant(\"grantSchemaGrant\", {\n    databaseName: \"database\",\n    privilege: \"USAGE\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    schemaName: \"schema\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant_view_grant = snowflake.ViewGrant(\"grantViewGrant\",\n    database_name=\"database\",\n    on_future=False,\n    privilege=\"SELECT\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\",\n    shares=[\n        \"share1\",\n        \"share2\",\n    ],\n    view_name=\"view\",\n    with_grant_option=False)\ngrant_schema_grant = snowflake.SchemaGrant(\"grantSchemaGrant\",\n    database_name=\"database\",\n    privilege=\"USAGE\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    schema_name=\"schema\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grantViewGrant = new Snowflake.ViewGrant(\"grantViewGrant\", new()\n    {\n        DatabaseName = \"database\",\n        OnFuture = false,\n        Privilege = \"SELECT\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n        Shares = new[]\n        {\n            \"share1\",\n            \"share2\",\n        },\n        ViewName = \"view\",\n        WithGrantOption = false,\n    });\n\n    var grantSchemaGrant = new Snowflake.SchemaGrant(\"grantSchemaGrant\", new()\n    {\n        DatabaseName = \"database\",\n        Privilege = \"USAGE\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        SchemaName = \"schema\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewViewGrant(ctx, \"grantViewGrant\", \u0026snowflake.ViewGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tOnFuture:     pulumi.Bool(false),\n\t\t\tPrivilege:    pulumi.String(\"SELECT\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t\tShares: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"share1\"),\n\t\t\t\tpulumi.String(\"share2\"),\n\t\t\t},\n\t\t\tViewName:        pulumi.String(\"view\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.NewSchemaGrant(ctx, \"grantSchemaGrant\", \u0026snowflake.SchemaGrantArgs{\n\t\t\tDatabaseName: pulumi.String(\"database\"),\n\t\t\tPrivilege:    pulumi.String(\"USAGE\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tSchemaName: pulumi.String(\"schema\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.ViewGrant;\nimport com.pulumi.snowflake.ViewGrantArgs;\nimport com.pulumi.snowflake.SchemaGrant;\nimport com.pulumi.snowflake.SchemaGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grantViewGrant = new ViewGrant(\"grantViewGrant\", ViewGrantArgs.builder()        \n            .databaseName(\"database\")\n            .onFuture(false)\n            .privilege(\"SELECT\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .shares(            \n                \"share1\",\n                \"share2\")\n            .viewName(\"view\")\n            .withGrantOption(false)\n            .build());\n\n        var grantSchemaGrant = new SchemaGrant(\"grantSchemaGrant\", SchemaGrantArgs.builder()        \n            .databaseName(\"database\")\n            .privilege(\"USAGE\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .schemaName(\"schema\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grantViewGrant:\n    type: snowflake:ViewGrant\n    properties:\n      databaseName: database\n      onFuture: false\n      privilege: SELECT\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n      shares:\n        - share1\n        - share2\n      viewName: view\n      withGrantOption: false\n  grantSchemaGrant:\n    type: snowflake:SchemaGrant\n    properties:\n      databaseName: database\n      privilege: USAGE\n      roles:\n        - role1\n        - role2\n      schemaName: schema\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is database_name|schema_name|view_name|privilege|with_grant_option|on_future|on_all|roles|shares\n\n```sh\n $ pulumi import snowflake:index/viewGrant:ViewGrant example \"MY_DATABASE|MY_SCHEMA|MY_VIEW|USAGE|false|false|false|role1,role2|share1,share2\"\n```\n\n ",
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future views on which to grant privileges.\n"
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all views in the given schema. When this is true and no schema*name is provided apply this grant on all views in the given database. The view*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n"
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future views in the given schema. When this is true and no schema*name is provided apply this grant on all future views in the given database. The view*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future view. To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future views on which to grant privileges.\n"
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on*future and on*all are unset).\n"
                },
                "viewName": {
                    "type": "string",
                    "description": "The name of the view on which to grant privileges immediately (only valid if on*future and on*all are unset).\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "databaseName"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "The name of the database containing the current or future views on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "onAll": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all views in the given schema. When this is true and no schema*name is provided apply this grant on all views in the given database. The view*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n",
                    "willReplaceOnChanges": true
                },
                "onFuture": {
                    "type": "boolean",
                    "description": "When this is set to true and a schema*name is provided, apply this grant on all future views in the given schema. When this is true and no schema*name is provided apply this grant on all future views in the given database. The view*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n",
                    "willReplaceOnChanges": true
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the current or future view. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "schemaName": {
                    "type": "string",
                    "description": "The name of the schema containing the current or future views on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "shares": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these shares (only valid if on*future and on*all are unset).\n"
                },
                "viewName": {
                    "type": "string",
                    "description": "The name of the view on which to grant privileges immediately (only valid if on*future and on*all are unset).\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "databaseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ViewGrant resources.\n",
                "properties": {
                    "databaseName": {
                        "type": "string",
                        "description": "The name of the database containing the current or future views on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "onAll": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all views in the given schema. When this is true and no schema*name is provided apply this grant on all views in the given database. The view*name and shares fields must be unset in order to use on*all. Cannot be used together with on_future.\n",
                        "willReplaceOnChanges": true
                    },
                    "onFuture": {
                        "type": "boolean",
                        "description": "When this is set to true and a schema*name is provided, apply this grant on all future views in the given schema. When this is true and no schema*name is provided apply this grant on all future views in the given database. The view*name and shares fields must be unset in order to use on*future. Cannot be used together with on_all.\n",
                        "willReplaceOnChanges": true
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the current or future view. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "schemaName": {
                        "type": "string",
                        "description": "The name of the schema containing the current or future views on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these shares (only valid if on*future and on*all are unset).\n"
                    },
                    "viewName": {
                        "type": "string",
                        "description": "The name of the view on which to grant privileges immediately (only valid if on*future and on*all are unset).\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/warehouse:Warehouse": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst warehouse = new snowflake.Warehouse(\"warehouse\", {\n    comment: \"foo\",\n    warehouseSize: \"small\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nwarehouse = snowflake.Warehouse(\"warehouse\",\n    comment=\"foo\",\n    warehouse_size=\"small\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var warehouse = new Snowflake.Warehouse(\"warehouse\", new()\n    {\n        Comment = \"foo\",\n        WarehouseSize = \"small\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewWarehouse(ctx, \"warehouse\", \u0026snowflake.WarehouseArgs{\n\t\t\tComment:       pulumi.String(\"foo\"),\n\t\t\tWarehouseSize: pulumi.String(\"small\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Warehouse;\nimport com.pulumi.snowflake.WarehouseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var warehouse = new Warehouse(\"warehouse\", WarehouseArgs.builder()        \n            .comment(\"foo\")\n            .warehouseSize(\"small\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  warehouse:\n    type: snowflake:Warehouse\n    properties:\n      comment: foo\n      warehouseSize: small\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import snowflake:index/warehouse:Warehouse example warehouseName\n```\n\n ",
            "properties": {
                "autoResume": {
                    "type": "boolean",
                    "description": "Specifies whether to automatically resume a warehouse when a SQL statement (e.g. query) is submitted to it.\n"
                },
                "autoSuspend": {
                    "type": "integer",
                    "description": "Specifies the number of seconds of inactivity after which a warehouse is automatically suspended.\n"
                },
                "comment": {
                    "type": "string"
                },
                "enableQueryAcceleration": {
                    "type": "boolean",
                    "description": "Specifies whether to enable the query acceleration service for queries that rely on this warehouse for compute resources.\n"
                },
                "initiallySuspended": {
                    "type": "boolean",
                    "description": "Specifies whether the warehouse is created initially in the ‘Suspended’ state.\n"
                },
                "maxClusterCount": {
                    "type": "integer",
                    "description": "Specifies the maximum number of server clusters for the warehouse.\n"
                },
                "maxConcurrencyLevel": {
                    "type": "integer",
                    "description": "Object parameter that specifies the concurrency level for SQL statements (i.e. queries and DML) executed by a warehouse.\n"
                },
                "minClusterCount": {
                    "type": "integer",
                    "description": "Specifies the minimum number of server clusters for the warehouse (only applies to multi-cluster warehouses).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the virtual warehouse; must be unique for your account.\n"
                },
                "queryAccelerationMaxScaleFactor": {
                    "type": "integer",
                    "description": "Specifies the maximum scale factor for leasing compute resources for query acceleration. The scale factor is used as a multiplier based on warehouse size.\n"
                },
                "resourceMonitor": {
                    "type": "string",
                    "description": "Specifies the name of a resource monitor that is explicitly assigned to the warehouse.\n"
                },
                "scalingPolicy": {
                    "type": "string",
                    "description": "Specifies the policy for automatically starting and shutting down clusters in a multi-cluster warehouse running in Auto-scale mode.\n"
                },
                "statementQueuedTimeoutInSeconds": {
                    "type": "integer",
                    "description": "Object parameter that specifies the time, in seconds, a SQL statement (query, DDL, DML, etc.) can be queued on a warehouse before it is canceled by the system.\n"
                },
                "statementTimeoutInSeconds": {
                    "type": "integer",
                    "description": "Specifies the time, in seconds, after which a running SQL statement (query, DDL, DML, etc.) is canceled by the system\n"
                },
                "waitForProvisioning": {
                    "type": "boolean",
                    "description": "Specifies whether the warehouse, after being resized, waits for all the servers to provision before executing any queued or new queries.\n",
                    "deprecationMessage": "This field is deprecated and will be removed in the next major version of the provider. It doesn't do anything and should be removed from your configuration."
                },
                "warehouseSize": {
                    "type": "string",
                    "description": "Specifies the size of the virtual warehouse. Larger warehouse sizes 5X-Large and 6X-Large are currently in preview and only available on Amazon Web Services (AWS).\n"
                },
                "warehouseType": {
                    "type": "string",
                    "description": "Specifies a STANDARD or SNOWPARK-OPTIMIZED warehouse\n"
                }
            },
            "required": [
                "autoResume",
                "autoSuspend",
                "maxClusterCount",
                "minClusterCount",
                "name",
                "resourceMonitor",
                "scalingPolicy",
                "warehouseSize"
            ],
            "inputProperties": {
                "autoResume": {
                    "type": "boolean",
                    "description": "Specifies whether to automatically resume a warehouse when a SQL statement (e.g. query) is submitted to it.\n"
                },
                "autoSuspend": {
                    "type": "integer",
                    "description": "Specifies the number of seconds of inactivity after which a warehouse is automatically suspended.\n"
                },
                "comment": {
                    "type": "string"
                },
                "enableQueryAcceleration": {
                    "type": "boolean",
                    "description": "Specifies whether to enable the query acceleration service for queries that rely on this warehouse for compute resources.\n"
                },
                "initiallySuspended": {
                    "type": "boolean",
                    "description": "Specifies whether the warehouse is created initially in the ‘Suspended’ state.\n",
                    "willReplaceOnChanges": true
                },
                "maxClusterCount": {
                    "type": "integer",
                    "description": "Specifies the maximum number of server clusters for the warehouse.\n"
                },
                "maxConcurrencyLevel": {
                    "type": "integer",
                    "description": "Object parameter that specifies the concurrency level for SQL statements (i.e. queries and DML) executed by a warehouse.\n"
                },
                "minClusterCount": {
                    "type": "integer",
                    "description": "Specifies the minimum number of server clusters for the warehouse (only applies to multi-cluster warehouses).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Identifier for the virtual warehouse; must be unique for your account.\n"
                },
                "queryAccelerationMaxScaleFactor": {
                    "type": "integer",
                    "description": "Specifies the maximum scale factor for leasing compute resources for query acceleration. The scale factor is used as a multiplier based on warehouse size.\n"
                },
                "resourceMonitor": {
                    "type": "string",
                    "description": "Specifies the name of a resource monitor that is explicitly assigned to the warehouse.\n"
                },
                "scalingPolicy": {
                    "type": "string",
                    "description": "Specifies the policy for automatically starting and shutting down clusters in a multi-cluster warehouse running in Auto-scale mode.\n"
                },
                "statementQueuedTimeoutInSeconds": {
                    "type": "integer",
                    "description": "Object parameter that specifies the time, in seconds, a SQL statement (query, DDL, DML, etc.) can be queued on a warehouse before it is canceled by the system.\n"
                },
                "statementTimeoutInSeconds": {
                    "type": "integer",
                    "description": "Specifies the time, in seconds, after which a running SQL statement (query, DDL, DML, etc.) is canceled by the system\n"
                },
                "waitForProvisioning": {
                    "type": "boolean",
                    "description": "Specifies whether the warehouse, after being resized, waits for all the servers to provision before executing any queued or new queries.\n",
                    "deprecationMessage": "This field is deprecated and will be removed in the next major version of the provider. It doesn't do anything and should be removed from your configuration."
                },
                "warehouseSize": {
                    "type": "string",
                    "description": "Specifies the size of the virtual warehouse. Larger warehouse sizes 5X-Large and 6X-Large are currently in preview and only available on Amazon Web Services (AWS).\n"
                },
                "warehouseType": {
                    "type": "string",
                    "description": "Specifies a STANDARD or SNOWPARK-OPTIMIZED warehouse\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Warehouse resources.\n",
                "properties": {
                    "autoResume": {
                        "type": "boolean",
                        "description": "Specifies whether to automatically resume a warehouse when a SQL statement (e.g. query) is submitted to it.\n"
                    },
                    "autoSuspend": {
                        "type": "integer",
                        "description": "Specifies the number of seconds of inactivity after which a warehouse is automatically suspended.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "enableQueryAcceleration": {
                        "type": "boolean",
                        "description": "Specifies whether to enable the query acceleration service for queries that rely on this warehouse for compute resources.\n"
                    },
                    "initiallySuspended": {
                        "type": "boolean",
                        "description": "Specifies whether the warehouse is created initially in the ‘Suspended’ state.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxClusterCount": {
                        "type": "integer",
                        "description": "Specifies the maximum number of server clusters for the warehouse.\n"
                    },
                    "maxConcurrencyLevel": {
                        "type": "integer",
                        "description": "Object parameter that specifies the concurrency level for SQL statements (i.e. queries and DML) executed by a warehouse.\n"
                    },
                    "minClusterCount": {
                        "type": "integer",
                        "description": "Specifies the minimum number of server clusters for the warehouse (only applies to multi-cluster warehouses).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Identifier for the virtual warehouse; must be unique for your account.\n"
                    },
                    "queryAccelerationMaxScaleFactor": {
                        "type": "integer",
                        "description": "Specifies the maximum scale factor for leasing compute resources for query acceleration. The scale factor is used as a multiplier based on warehouse size.\n"
                    },
                    "resourceMonitor": {
                        "type": "string",
                        "description": "Specifies the name of a resource monitor that is explicitly assigned to the warehouse.\n"
                    },
                    "scalingPolicy": {
                        "type": "string",
                        "description": "Specifies the policy for automatically starting and shutting down clusters in a multi-cluster warehouse running in Auto-scale mode.\n"
                    },
                    "statementQueuedTimeoutInSeconds": {
                        "type": "integer",
                        "description": "Object parameter that specifies the time, in seconds, a SQL statement (query, DDL, DML, etc.) can be queued on a warehouse before it is canceled by the system.\n"
                    },
                    "statementTimeoutInSeconds": {
                        "type": "integer",
                        "description": "Specifies the time, in seconds, after which a running SQL statement (query, DDL, DML, etc.) is canceled by the system\n"
                    },
                    "waitForProvisioning": {
                        "type": "boolean",
                        "description": "Specifies whether the warehouse, after being resized, waits for all the servers to provision before executing any queued or new queries.\n",
                        "deprecationMessage": "This field is deprecated and will be removed in the next major version of the provider. It doesn't do anything and should be removed from your configuration."
                    },
                    "warehouseSize": {
                        "type": "string",
                        "description": "Specifies the size of the virtual warehouse. Larger warehouse sizes 5X-Large and 6X-Large are currently in preview and only available on Amazon Web Services (AWS).\n"
                    },
                    "warehouseType": {
                        "type": "string",
                        "description": "Specifies a STANDARD or SNOWPARK-OPTIMIZED warehouse\n"
                    }
                },
                "type": "object"
            }
        },
        "snowflake:index/warehouseGrant:WarehouseGrant": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grant = new snowflake.WarehouseGrant(\"grant\", {\n    privilege: \"MODIFY\",\n    roles: [\n        \"role1\",\n        \"role2\",\n    ],\n    warehouseName: \"warehouse\",\n    withGrantOption: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrant = snowflake.WarehouseGrant(\"grant\",\n    privilege=\"MODIFY\",\n    roles=[\n        \"role1\",\n        \"role2\",\n    ],\n    warehouse_name=\"warehouse\",\n    with_grant_option=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grant = new Snowflake.WarehouseGrant(\"grant\", new()\n    {\n        Privilege = \"MODIFY\",\n        Roles = new[]\n        {\n            \"role1\",\n            \"role2\",\n        },\n        WarehouseName = \"warehouse\",\n        WithGrantOption = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.NewWarehouseGrant(ctx, \"grant\", \u0026snowflake.WarehouseGrantArgs{\n\t\t\tPrivilege: pulumi.String(\"MODIFY\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role1\"),\n\t\t\t\tpulumi.String(\"role2\"),\n\t\t\t},\n\t\t\tWarehouseName:   pulumi.String(\"warehouse\"),\n\t\t\tWithGrantOption: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.WarehouseGrant;\nimport com.pulumi.snowflake.WarehouseGrantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var grant = new WarehouseGrant(\"grant\", WarehouseGrantArgs.builder()        \n            .privilege(\"MODIFY\")\n            .roles(            \n                \"role1\",\n                \"role2\")\n            .warehouseName(\"warehouse\")\n            .withGrantOption(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  grant:\n    type: snowflake:WarehouseGrant\n    properties:\n      privilege: MODIFY\n      roles:\n        - role1\n        - role2\n      warehouseName: warehouse\n      withGrantOption: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nformat is warehouse_name|privilege|with_grant_option|roles\n\n```sh\n $ pulumi import snowflake:index/warehouseGrant:WarehouseGrant example \"MY_WAREHOUSE|MODIFY|false|role1,role2\"\n```\n\n ",
            "properties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the warehouse. To grant all privileges, use the value `ALL PRIVILEGES`.\n"
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "warehouseName": {
                    "type": "string",
                    "description": "The name of the warehouse on which to grant privileges.\n"
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n"
                }
            },
            "required": [
                "warehouseName"
            ],
            "inputProperties": {
                "enableMultipleGrants": {
                    "type": "boolean",
                    "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                },
                "privilege": {
                    "type": "string",
                    "description": "The privilege to grant on the warehouse. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                    "willReplaceOnChanges": true
                },
                "revertOwnershipToRoleName": {
                    "type": "string",
                    "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Grants privilege to these roles.\n"
                },
                "warehouseName": {
                    "type": "string",
                    "description": "The name of the warehouse on which to grant privileges.\n",
                    "willReplaceOnChanges": true
                },
                "withGrantOption": {
                    "type": "boolean",
                    "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "warehouseName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WarehouseGrant resources.\n",
                "properties": {
                    "enableMultipleGrants": {
                        "type": "boolean",
                        "description": "When this is set to true, multiple grants of the same type can be created. This will cause Terraform to not revoke\ngrants applied to roles and objects outside Terraform.\n"
                    },
                    "privilege": {
                        "type": "string",
                        "description": "The privilege to grant on the warehouse. To grant all privileges, use the value `ALL PRIVILEGES`.\n",
                        "willReplaceOnChanges": true
                    },
                    "revertOwnershipToRoleName": {
                        "type": "string",
                        "description": "The name of the role to revert ownership to on destroy. Has no effect unless `privilege` is set to `OWNERSHIP`\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Grants privilege to these roles.\n"
                    },
                    "warehouseName": {
                        "type": "string",
                        "description": "The name of the warehouse on which to grant privileges.\n",
                        "willReplaceOnChanges": true
                    },
                    "withGrantOption": {
                        "type": "boolean",
                        "description": "When this is set to true, allows the recipient role to grant the privileges to other roles.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "snowflake:index/getAccounts:getAccounts": {
            "inputs": {
                "description": "A collection of arguments for invoking getAccounts.\n",
                "properties": {
                    "pattern": {
                        "type": "string",
                        "description": "Specifies an account name pattern. If a pattern is specified, only accounts matching the pattern are returned.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAccounts.\n",
                "properties": {
                    "accounts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getAccountsAccount:getAccountsAccount"
                        },
                        "description": "List of all the accounts available in the organization.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Specifies an account name pattern. If a pattern is specified, only accounts matching the pattern are returned.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accounts",
                    "id"
                ]
            }
        },
        "snowflake:index/getAlerts:getAlerts": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getAlerts({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_alerts(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetAlerts.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetAlerts(ctx, \u0026snowflake.GetAlertsArgs{\n\t\t\tDatabase: pulumi.StringRef(\"MYDB\"),\n\t\t\tSchema:   pulumi.StringRef(\"MYSCHEMA\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetAlertsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getAlerts(GetAlertsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getAlerts\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAlerts.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the alerts from.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Filters the command output by object name.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the alerts from.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAlerts.\n",
                "properties": {
                    "alerts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getAlertsAlert:getAlertsAlert"
                        },
                        "description": "Lists alerts for the current/specified database or schema, or across the entire account.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the alerts from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Filters the command output by object name.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the alerts from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "alerts",
                    "id"
                ]
            }
        },
        "snowflake:index/getCurrentAccount:getCurrentAccount": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst this = snowflake.getCurrentAccount({});\nconst snowflakeAccountUrl = new aws.ssm.Parameter(\"snowflakeAccountUrl\", {\n    type: \"String\",\n    value: _this.then(_this =\u003e _this.url),\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_current_account()\nsnowflake_account_url = aws.ssm.Parameter(\"snowflakeAccountUrl\",\n    type=\"String\",\n    value=this.url)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = Snowflake.GetCurrentAccount.Invoke();\n\n    var snowflakeAccountUrl = new Aws.Ssm.Parameter(\"snowflakeAccountUrl\", new()\n    {\n        Type = \"String\",\n        Value = @this.Apply(@this =\u003e @this.Apply(getCurrentAccountResult =\u003e getCurrentAccountResult.Url)),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ssm\"\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := snowflake.GetCurrentAccount(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ssm.NewParameter(ctx, \"snowflakeAccountUrl\", \u0026ssm.ParameterArgs{\n\t\t\tType:  pulumi.String(\"String\"),\n\t\t\tValue: *pulumi.String(this.Url),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.aws.ssm.Parameter;\nimport com.pulumi.aws.ssm.ParameterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = SnowflakeFunctions.getCurrentAccount();\n\n        var snowflakeAccountUrl = new Parameter(\"snowflakeAccountUrl\", ParameterArgs.builder()        \n            .type(\"String\")\n            .value(this_.url())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  snowflakeAccountUrl:\n    type: aws:ssm:Parameter\n    properties:\n      type: String\n      value: ${this.url}\nvariables:\n  this:\n    fn::invoke:\n      Function: snowflake:getCurrentAccount\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getCurrentAccount.\n",
                "properties": {
                    "account": {
                        "type": "string",
                        "description": "The Snowflake Account ID; as returned by CURRENT_ACCOUNT().\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "The Snowflake Region; as returned by CURRENT_REGION()\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The Snowflake URL.\n"
                    }
                },
                "type": "object",
                "required": [
                    "account",
                    "region",
                    "url",
                    "id"
                ]
            }
        },
        "snowflake:index/getCurrentRole:getCurrentRole": {
            "outputs": {
                "description": "A collection of values returned by getCurrentRole.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the [primary role](https://docs.snowflake.com/en/user-guide/security-access-control-overview.html#label-access-control-role-enforcement) in use for the current session.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "snowflake:index/getDatabase:getDatabase": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst this = snowflake.getDatabase({\n    name: \"DEMO_DB\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_database(name=\"DEMO_DB\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = Snowflake.GetDatabase.Invoke(new()\n    {\n        Name = \"DEMO_DB\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.LookupDatabase(ctx, \u0026snowflake.LookupDatabaseArgs{\n\t\t\tName: \"DEMO_DB\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetDatabaseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = SnowflakeFunctions.getDatabase(GetDatabaseArgs.builder()\n            .name(\"DEMO_DB\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      Function: snowflake:getDatabase\n      Arguments:\n        name: DEMO_DB\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatabase.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The database from which to return its metadata.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatabase.\n",
                "properties": {
                    "comment": {
                        "type": "string"
                    },
                    "createdOn": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "isCurrent": {
                        "type": "boolean"
                    },
                    "isDefault": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string",
                        "description": "The database from which to return its metadata.\n"
                    },
                    "options": {
                        "type": "string"
                    },
                    "origin": {
                        "type": "string"
                    },
                    "owner": {
                        "type": "string"
                    },
                    "retentionTime": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "comment",
                    "createdOn",
                    "isCurrent",
                    "isDefault",
                    "name",
                    "options",
                    "origin",
                    "owner",
                    "retentionTime",
                    "id"
                ]
            }
        },
        "snowflake:index/getDatabaseRoles:getDatabaseRoles": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst dbRoles = snowflake.getDatabaseRoles({\n    database: \"MYDB\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndb_roles = snowflake.get_database_roles(database=\"MYDB\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dbRoles = Snowflake.GetDatabaseRoles.Invoke(new()\n    {\n        Database = \"MYDB\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetDatabaseRoles(ctx, \u0026snowflake.GetDatabaseRolesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetDatabaseRolesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dbRoles = SnowflakeFunctions.getDatabaseRoles(GetDatabaseRolesArgs.builder()\n            .database(\"MYDB\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  dbRoles:\n    fn::invoke:\n      Function: snowflake:getDatabaseRoles\n      Arguments:\n        database: MYDB\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatabaseRoles.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the database roles from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatabaseRoles.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the database roles from.\n"
                    },
                    "databaseRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getDatabaseRolesDatabaseRole:getDatabaseRolesDatabaseRole"
                        },
                        "description": "Lists all the database roles in a specified database.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "databaseRoles",
                    "id"
                ]
            }
        },
        "snowflake:index/getDatabases:getDatabases": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst this = snowflake.getDatabases({});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_databases()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = Snowflake.GetDatabases.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetDatabases(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetDatabasesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = SnowflakeFunctions.getDatabases();\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      Function: snowflake:getDatabases\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatabases.\n",
                "properties": {
                    "history": {
                        "type": "boolean",
                        "description": "Optionally includes dropped databases that have not yet been purged The output also includes an additional `dropped_on` column\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Optionally filters the databases by a pattern\n"
                    },
                    "startsWith": {
                        "type": "string",
                        "description": "Optionally filters the databases by a pattern\n"
                    },
                    "terse": {
                        "type": "boolean",
                        "description": "Optionally returns only the columns `created_on` and `name` in the results\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatabases.\n",
                "properties": {
                    "databases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getDatabasesDatabase:getDatabasesDatabase"
                        },
                        "description": "Snowflake databases\n"
                    },
                    "history": {
                        "type": "boolean",
                        "description": "Optionally includes dropped databases that have not yet been purged The output also includes an additional `dropped_on` column\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Optionally filters the databases by a pattern\n"
                    },
                    "startsWith": {
                        "type": "string",
                        "description": "Optionally filters the databases by a pattern\n"
                    },
                    "terse": {
                        "type": "boolean",
                        "description": "Optionally returns only the columns `created_on` and `name` in the results\n"
                    }
                },
                "type": "object",
                "required": [
                    "databases",
                    "id"
                ]
            }
        },
        "snowflake:index/getDynamicTables:getDynamicTables": {
            "inputs": {
                "description": "A collection of arguments for invoking getDynamicTables.\n",
                "properties": {
                    "in": {
                        "$ref": "#/types/snowflake:index/getDynamicTablesIn:getDynamicTablesIn",
                        "description": "IN clause to filter the list of dynamic tables.\n"
                    },
                    "like": {
                        "$ref": "#/types/snowflake:index/getDynamicTablesLike:getDynamicTablesLike",
                        "description": "LIKE clause to filter the list of dynamic tables.\n"
                    },
                    "limit": {
                        "$ref": "#/types/snowflake:index/getDynamicTablesLimit:getDynamicTablesLimit",
                        "description": "Optionally limits the maximum number of rows returned, while also enabling “pagination” of the results. Note that the actual number of rows returned might be less than the specified limit (e.g. the number of existing objects is less than the specified limit).\n"
                    },
                    "startsWith": {
                        "type": "string",
                        "description": "Optionally filters the command output based on the characters that appear at the beginning of the object name. The string is case-sensitive.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDynamicTables.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "in": {
                        "$ref": "#/types/snowflake:index/getDynamicTablesIn:getDynamicTablesIn",
                        "description": "IN clause to filter the list of dynamic tables.\n"
                    },
                    "like": {
                        "$ref": "#/types/snowflake:index/getDynamicTablesLike:getDynamicTablesLike",
                        "description": "LIKE clause to filter the list of dynamic tables.\n"
                    },
                    "limit": {
                        "$ref": "#/types/snowflake:index/getDynamicTablesLimit:getDynamicTablesLimit",
                        "description": "Optionally limits the maximum number of rows returned, while also enabling “pagination” of the results. Note that the actual number of rows returned might be less than the specified limit (e.g. the number of existing objects is less than the specified limit).\n"
                    },
                    "records": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getDynamicTablesRecord:getDynamicTablesRecord"
                        },
                        "description": "The list of dynamic tables.\n"
                    },
                    "startsWith": {
                        "type": "string",
                        "description": "Optionally filters the command output based on the characters that appear at the beginning of the object name. The string is case-sensitive.\n"
                    }
                },
                "type": "object",
                "required": [
                    "records",
                    "id"
                ]
            }
        },
        "snowflake:index/getExternalFunctions:getExternalFunctions": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getExternalFunctions({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_external_functions(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetExternalFunctions.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetExternalFunctions(ctx, \u0026snowflake.GetExternalFunctionsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetExternalFunctionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getExternalFunctions(GetExternalFunctionsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getExternalFunctions\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getExternalFunctions.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getExternalFunctions.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "externalFunctions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getExternalFunctionsExternalFunction:getExternalFunctionsExternalFunction"
                        },
                        "description": "The external functions in the schema\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the external functions from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "externalFunctions",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getExternalTables:getExternalTables": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getExternalTables({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_external_tables(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetExternalTables.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetExternalTables(ctx, \u0026snowflake.GetExternalTablesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetExternalTablesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getExternalTables(GetExternalTablesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getExternalTables\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getExternalTables.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getExternalTables.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "externalTables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getExternalTablesExternalTable:getExternalTablesExternalTable"
                        },
                        "description": "The external tables in the schema\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the external tables from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "externalTables",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getFailoverGroups:getFailoverGroups": {
            "inputs": {
                "description": "A collection of arguments for invoking getFailoverGroups.\n",
                "properties": {
                    "inAccount": {
                        "type": "string",
                        "description": "Specifies the identifier for the account\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getFailoverGroups.\n",
                "properties": {
                    "failoverGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getFailoverGroupsFailoverGroup:getFailoverGroupsFailoverGroup"
                        },
                        "description": "List of all the failover groups available in the system.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "inAccount": {
                        "type": "string",
                        "description": "Specifies the identifier for the account\n"
                    }
                },
                "type": "object",
                "required": [
                    "failoverGroups",
                    "id"
                ]
            }
        },
        "snowflake:index/getFileFormats:getFileFormats": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getFileFormats({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_file_formats(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetFileFormats.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetFileFormats(ctx, \u0026snowflake.GetFileFormatsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetFileFormatsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getFileFormats(GetFileFormatsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getFileFormats\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFileFormats.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFileFormats.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "fileFormats": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getFileFormatsFileFormat:getFileFormatsFileFormat"
                        },
                        "description": "The file formats in the schema\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the file formats from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "fileFormats",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getFunctions:getFunctions": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getFunctions({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_functions(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetFunctions.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetFunctions(ctx, \u0026snowflake.GetFunctionsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetFunctionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getFunctions(GetFunctionsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getFunctions\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFunctions.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFunctions.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "functions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getFunctionsFunction:getFunctionsFunction"
                        },
                        "description": "The functions in the schema\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the functions from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "functions",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getGrants:getGrants": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst grants = snowflake.getGrants({\n    grantsOn: {\n        account: true,\n    },\n});\nconst grants2 = snowflake.getGrants({\n    grantsOn: {\n        objectName: \"\\\"tst\\\"\",\n        objectType: \"DATABASE\",\n    },\n});\nconst grants3 = snowflake.getGrants({\n    grantsTo: {\n        role: \"ACCOUNTADMIN\",\n    },\n});\nconst grants4 = snowflake.getGrants({\n    grantsOf: {\n        role: \"ACCOUNTADMIN\",\n    },\n});\nconst grants5 = snowflake.getGrants({\n    futureGrantsIn: {\n        database: \"\\\"tst\\\"\",\n    },\n});\nconst grants6 = snowflake.getGrants({\n    futureGrantsIn: {\n        schema: {\n            databaseName: \"\\\"mydatabase\\\"\",\n            schemaName: \"\\\"myschema\\\"\",\n        },\n    },\n});\nconst grants7 = snowflake.getGrants({\n    futureGrantsTo: {\n        role: \"ACCOUNTADMIN\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ngrants = snowflake.get_grants(grants_on=snowflake.GetGrantsGrantsOnArgs(\n    account=True,\n))\ngrants2 = snowflake.get_grants(grants_on=snowflake.GetGrantsGrantsOnArgs(\n    object_name=\"\\\"tst\\\"\",\n    object_type=\"DATABASE\",\n))\ngrants3 = snowflake.get_grants(grants_to=snowflake.GetGrantsGrantsToArgs(\n    role=\"ACCOUNTADMIN\",\n))\ngrants4 = snowflake.get_grants(grants_of=snowflake.GetGrantsGrantsOfArgs(\n    role=\"ACCOUNTADMIN\",\n))\ngrants5 = snowflake.get_grants(future_grants_in=snowflake.GetGrantsFutureGrantsInArgs(\n    database=\"\\\"tst\\\"\",\n))\ngrants6 = snowflake.get_grants(future_grants_in=snowflake.GetGrantsFutureGrantsInArgs(\n    schema=snowflake.GetGrantsFutureGrantsInSchemaArgs(\n        database_name=\"\\\"mydatabase\\\"\",\n        schema_name=\"\\\"myschema\\\"\",\n    ),\n))\ngrants7 = snowflake.get_grants(future_grants_to=snowflake.GetGrantsFutureGrantsToArgs(\n    role=\"ACCOUNTADMIN\",\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var grants = Snowflake.GetGrants.Invoke(new()\n    {\n        GrantsOn = new Snowflake.Inputs.GetGrantsGrantsOnInputArgs\n        {\n            Account = true,\n        },\n    });\n\n    var grants2 = Snowflake.GetGrants.Invoke(new()\n    {\n        GrantsOn = new Snowflake.Inputs.GetGrantsGrantsOnInputArgs\n        {\n            ObjectName = \"\\\"tst\\\"\",\n            ObjectType = \"DATABASE\",\n        },\n    });\n\n    var grants3 = Snowflake.GetGrants.Invoke(new()\n    {\n        GrantsTo = new Snowflake.Inputs.GetGrantsGrantsToInputArgs\n        {\n            Role = \"ACCOUNTADMIN\",\n        },\n    });\n\n    var grants4 = Snowflake.GetGrants.Invoke(new()\n    {\n        GrantsOf = new Snowflake.Inputs.GetGrantsGrantsOfInputArgs\n        {\n            Role = \"ACCOUNTADMIN\",\n        },\n    });\n\n    var grants5 = Snowflake.GetGrants.Invoke(new()\n    {\n        FutureGrantsIn = new Snowflake.Inputs.GetGrantsFutureGrantsInInputArgs\n        {\n            Database = \"\\\"tst\\\"\",\n        },\n    });\n\n    var grants6 = Snowflake.GetGrants.Invoke(new()\n    {\n        FutureGrantsIn = new Snowflake.Inputs.GetGrantsFutureGrantsInInputArgs\n        {\n            Schema = new Snowflake.Inputs.GetGrantsFutureGrantsInSchemaInputArgs\n            {\n                DatabaseName = \"\\\"mydatabase\\\"\",\n                SchemaName = \"\\\"myschema\\\"\",\n            },\n        },\n    });\n\n    var grants7 = Snowflake.GetGrants.Invoke(new()\n    {\n        FutureGrantsTo = new Snowflake.Inputs.GetGrantsFutureGrantsToInputArgs\n        {\n            Role = \"ACCOUNTADMIN\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetGrants(ctx, \u0026snowflake.GetGrantsArgs{\n\t\t\tGrantsOn: snowflake.GetGrantsGrantsOn{\n\t\t\t\tAccount: pulumi.BoolRef(true),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.GetGrants(ctx, \u0026snowflake.GetGrantsArgs{\n\t\t\tGrantsOn: snowflake.GetGrantsGrantsOn{\n\t\t\t\tObjectName: pulumi.StringRef(\"\\\"tst\\\"\"),\n\t\t\t\tObjectType: pulumi.StringRef(\"DATABASE\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.GetGrants(ctx, \u0026snowflake.GetGrantsArgs{\n\t\t\tGrantsTo: snowflake.GetGrantsGrantsTo{\n\t\t\t\tRole: pulumi.StringRef(\"ACCOUNTADMIN\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.GetGrants(ctx, \u0026snowflake.GetGrantsArgs{\n\t\t\tGrantsOf: snowflake.GetGrantsGrantsOf{\n\t\t\t\tRole: pulumi.StringRef(\"ACCOUNTADMIN\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.GetGrants(ctx, \u0026snowflake.GetGrantsArgs{\n\t\t\tFutureGrantsIn: snowflake.GetGrantsFutureGrantsIn{\n\t\t\t\tDatabase: pulumi.StringRef(\"\\\"tst\\\"\"),\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.GetGrants(ctx, \u0026snowflake.GetGrantsArgs{\n\t\t\tFutureGrantsIn: snowflake.GetGrantsFutureGrantsIn{\n\t\t\t\tSchema: snowflake.GetGrantsFutureGrantsInSchema{\n\t\t\t\t\tDatabaseName: pulumi.StringRef(\"\\\"mydatabase\\\"\"),\n\t\t\t\t\tSchemaName:   \"\\\"myschema\\\"\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.GetGrants(ctx, \u0026snowflake.GetGrantsArgs{\n\t\t\tFutureGrantsTo: snowflake.GetGrantsFutureGrantsTo{\n\t\t\t\tRole: \"ACCOUNTADMIN\",\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetGrantsArgs;\nimport com.pulumi.snowflake.inputs.GetGrantsGrantsOnArgs;\nimport com.pulumi.snowflake.inputs.GetGrantsGrantsToArgs;\nimport com.pulumi.snowflake.inputs.GetGrantsGrantsOfArgs;\nimport com.pulumi.snowflake.inputs.GetGrantsFutureGrantsInArgs;\nimport com.pulumi.snowflake.inputs.GetGrantsFutureGrantsInSchemaArgs;\nimport com.pulumi.snowflake.inputs.GetGrantsFutureGrantsToArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var grants = SnowflakeFunctions.getGrants(GetGrantsArgs.builder()\n            .grantsOn(GetGrantsGrantsOnArgs.builder()\n                .account(true)\n                .build())\n            .build());\n\n        final var grants2 = SnowflakeFunctions.getGrants(GetGrantsArgs.builder()\n            .grantsOn(GetGrantsGrantsOnArgs.builder()\n                .objectName(\"\\\"tst\\\"\")\n                .objectType(\"DATABASE\")\n                .build())\n            .build());\n\n        final var grants3 = SnowflakeFunctions.getGrants(GetGrantsArgs.builder()\n            .grantsTo(GetGrantsGrantsToArgs.builder()\n                .role(\"ACCOUNTADMIN\")\n                .build())\n            .build());\n\n        final var grants4 = SnowflakeFunctions.getGrants(GetGrantsArgs.builder()\n            .grantsOf(GetGrantsGrantsOfArgs.builder()\n                .role(\"ACCOUNTADMIN\")\n                .build())\n            .build());\n\n        final var grants5 = SnowflakeFunctions.getGrants(GetGrantsArgs.builder()\n            .futureGrantsIn(GetGrantsFutureGrantsInArgs.builder()\n                .database(\"\\\"tst\\\"\")\n                .build())\n            .build());\n\n        final var grants6 = SnowflakeFunctions.getGrants(GetGrantsArgs.builder()\n            .futureGrantsIn(GetGrantsFutureGrantsInArgs.builder()\n                .schema(GetGrantsFutureGrantsInSchemaArgs.builder()\n                    .databaseName(\"\\\"mydatabase\\\"\")\n                    .schemaName(\"\\\"myschema\\\"\")\n                    .build())\n                .build())\n            .build());\n\n        final var grants7 = SnowflakeFunctions.getGrants(GetGrantsArgs.builder()\n            .futureGrantsTo(GetGrantsFutureGrantsToArgs.builder()\n                .role(\"ACCOUNTADMIN\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  grants:\n    fn::invoke:\n      Function: snowflake:getGrants\n      Arguments:\n        grantsOn:\n          account: true\n  grants2:\n    fn::invoke:\n      Function: snowflake:getGrants\n      Arguments:\n        grantsOn:\n          objectName: '\"tst\"'\n          objectType: DATABASE\n  grants3:\n    fn::invoke:\n      Function: snowflake:getGrants\n      Arguments:\n        grantsTo:\n          role: ACCOUNTADMIN\n  grants4:\n    fn::invoke:\n      Function: snowflake:getGrants\n      Arguments:\n        grantsOf:\n          role: ACCOUNTADMIN\n  grants5:\n    fn::invoke:\n      Function: snowflake:getGrants\n      Arguments:\n        futureGrantsIn:\n          database: '\"tst\"'\n  grants6:\n    fn::invoke:\n      Function: snowflake:getGrants\n      Arguments:\n        futureGrantsIn:\n          schema:\n            databaseName: '\"mydatabase\"'\n            schemaName: '\"myschema\"'\n  grants7:\n    fn::invoke:\n      Function: snowflake:getGrants\n      Arguments:\n        futureGrantsTo:\n          role: ACCOUNTADMIN\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGrants.\n",
                "properties": {
                    "futureGrantsIn": {
                        "$ref": "#/types/snowflake:index/getGrantsFutureGrantsIn:getGrantsFutureGrantsIn",
                        "description": "Lists all privileges on new (i.e. future) objects\n"
                    },
                    "futureGrantsTo": {
                        "$ref": "#/types/snowflake:index/getGrantsFutureGrantsTo:getGrantsFutureGrantsTo",
                        "description": "Lists all privileges granted to the object on new (i.e. future) objects\n"
                    },
                    "grantsOf": {
                        "$ref": "#/types/snowflake:index/getGrantsGrantsOf:getGrantsGrantsOf",
                        "description": "Lists all objects to which the given object has been granted\n"
                    },
                    "grantsOn": {
                        "$ref": "#/types/snowflake:index/getGrantsGrantsOn:getGrantsGrantsOn",
                        "description": "Lists all privileges that have been granted on an object or account\n"
                    },
                    "grantsTo": {
                        "$ref": "#/types/snowflake:index/getGrantsGrantsTo:getGrantsGrantsTo",
                        "description": "Lists all privileges granted to the object\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGrants.\n",
                "properties": {
                    "futureGrantsIn": {
                        "$ref": "#/types/snowflake:index/getGrantsFutureGrantsIn:getGrantsFutureGrantsIn",
                        "description": "Lists all privileges on new (i.e. future) objects\n"
                    },
                    "futureGrantsTo": {
                        "$ref": "#/types/snowflake:index/getGrantsFutureGrantsTo:getGrantsFutureGrantsTo",
                        "description": "Lists all privileges granted to the object on new (i.e. future) objects\n"
                    },
                    "grants": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getGrantsGrant:getGrantsGrant"
                        },
                        "description": "The list of grants\n"
                    },
                    "grantsOf": {
                        "$ref": "#/types/snowflake:index/getGrantsGrantsOf:getGrantsGrantsOf",
                        "description": "Lists all objects to which the given object has been granted\n"
                    },
                    "grantsOn": {
                        "$ref": "#/types/snowflake:index/getGrantsGrantsOn:getGrantsGrantsOn",
                        "description": "Lists all privileges that have been granted on an object or account\n"
                    },
                    "grantsTo": {
                        "$ref": "#/types/snowflake:index/getGrantsGrantsTo:getGrantsGrantsTo",
                        "description": "Lists all privileges granted to the object\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "grants",
                    "id"
                ]
            }
        },
        "snowflake:index/getMaskingPolicies:getMaskingPolicies": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getMaskingPolicies({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_masking_policies(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetMaskingPolicies.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetMaskingPolicies(ctx, \u0026snowflake.GetMaskingPoliciesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetMaskingPoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getMaskingPolicies(GetMaskingPoliciesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getMaskingPolicies\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getMaskingPolicies.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getMaskingPolicies.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "maskingPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getMaskingPoliciesMaskingPolicy:getMaskingPoliciesMaskingPolicy"
                        },
                        "description": "The maskingPolicies in the schema\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the maskingPolicies from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "maskingPolicies",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getMaterializedViews:getMaterializedViews": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getMaterializedViews({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_materialized_views(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetMaterializedViews.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetMaterializedViews(ctx, \u0026snowflake.GetMaterializedViewsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetMaterializedViewsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getMaterializedViews(GetMaterializedViewsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getMaterializedViews\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getMaterializedViews.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getMaterializedViews.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "materializedViews": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getMaterializedViewsMaterializedView:getMaterializedViewsMaterializedView"
                        },
                        "description": "The views in the schema\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the views from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "materializedViews",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getParameters:getParameters": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst database = new snowflake.Database(\"database\", {});\nconst parameters = snowflake.getParametersOutput({\n    parameterType: \"OBJECT\",\n    objectType: \"DATABASE\",\n    objectName: database.name,\n});\nconst p2 = snowflake.getParameters({\n    parameterType: \"ACCOUNT\",\n    pattern: \"%TIMESTAMP%\",\n});\nconst p3 = snowflake.getParameters({\n    parameterType: \"SESSION\",\n    pattern: \"ROWS_PER_RESULTSET\",\n    user: \"TEST_USER\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ndatabase = snowflake.Database(\"database\")\nparameters = snowflake.get_parameters_output(parameter_type=\"OBJECT\",\n    object_type=\"DATABASE\",\n    object_name=database.name)\np2 = snowflake.get_parameters(parameter_type=\"ACCOUNT\",\n    pattern=\"%TIMESTAMP%\")\np3 = snowflake.get_parameters(parameter_type=\"SESSION\",\n    pattern=\"ROWS_PER_RESULTSET\",\n    user=\"TEST_USER\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var database = new Snowflake.Database(\"database\");\n\n    var parameters = Snowflake.GetParameters.Invoke(new()\n    {\n        ParameterType = \"OBJECT\",\n        ObjectType = \"DATABASE\",\n        ObjectName = database.Name,\n    });\n\n    var p2 = Snowflake.GetParameters.Invoke(new()\n    {\n        ParameterType = \"ACCOUNT\",\n        Pattern = \"%TIMESTAMP%\",\n    });\n\n    var p3 = Snowflake.GetParameters.Invoke(new()\n    {\n        ParameterType = \"SESSION\",\n        Pattern = \"ROWS_PER_RESULTSET\",\n        User = \"TEST_USER\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatabase, err := snowflake.NewDatabase(ctx, \"database\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = snowflake.GetParametersOutput(ctx, snowflake.GetParametersOutputArgs{\n\t\t\tParameterType: pulumi.String(\"OBJECT\"),\n\t\t\tObjectType:    pulumi.String(\"DATABASE\"),\n\t\t\tObjectName:    database.Name,\n\t\t}, nil)\n\t\t_, err = snowflake.GetParameters(ctx, \u0026snowflake.GetParametersArgs{\n\t\t\tParameterType: pulumi.StringRef(\"ACCOUNT\"),\n\t\t\tPattern:       pulumi.StringRef(\"%TIMESTAMP%\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.GetParameters(ctx, \u0026snowflake.GetParametersArgs{\n\t\t\tParameterType: pulumi.StringRef(\"SESSION\"),\n\t\t\tPattern:       pulumi.StringRef(\"ROWS_PER_RESULTSET\"),\n\t\t\tUser:          pulumi.StringRef(\"TEST_USER\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.Database;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetParametersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var database = new Database(\"database\");\n\n        final var parameters = SnowflakeFunctions.getParameters(GetParametersArgs.builder()\n            .parameterType(\"OBJECT\")\n            .objectType(\"DATABASE\")\n            .objectName(database.name())\n            .build());\n\n        final var p2 = SnowflakeFunctions.getParameters(GetParametersArgs.builder()\n            .parameterType(\"ACCOUNT\")\n            .pattern(\"%TIMESTAMP%\")\n            .build());\n\n        final var p3 = SnowflakeFunctions.getParameters(GetParametersArgs.builder()\n            .parameterType(\"SESSION\")\n            .pattern(\"ROWS_PER_RESULTSET\")\n            .user(\"TEST_USER\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  database:\n    type: snowflake:Database\nvariables:\n  parameters:\n    fn::invoke:\n      Function: snowflake:getParameters\n      Arguments:\n        parameterType: OBJECT\n        objectType: DATABASE\n        objectName: ${database.name}\n  p2:\n    fn::invoke:\n      Function: snowflake:getParameters\n      Arguments:\n        parameterType: ACCOUNT\n        pattern: '%TIMESTAMP%'\n  p3:\n    fn::invoke:\n      Function: snowflake:getParameters\n      Arguments:\n        parameterType: SESSION\n        pattern: ROWS_PER_RESULTSET\n        user: TEST_USER\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getParameters.\n",
                "properties": {
                    "objectName": {
                        "type": "string",
                        "description": "If parameter*type is set to \"OBJECT\" then object*name is the name of the object to display object parameters for.\n"
                    },
                    "objectType": {
                        "type": "string",
                        "description": "If parameter*type is set to \"OBJECT\" then object*type is the type of object to display object parameters for. Valid values are any object supported by the IN clause of the [SHOW PARAMETERS](https://docs.snowflake.com/en/sql-reference/sql/show-parameters.html#parameters) statement, including: WAREHOUSE | DATABASE | SCHEMA | TASK | TABLE\n"
                    },
                    "parameterType": {
                        "type": "string",
                        "description": "The type of parameter to filter by. Valid values are: \"ACCOUNT\", \"SESSION\", \"OBJECT\".\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Allows limiting the list of parameters by name using LIKE clause. Refer to [Limiting the List of Parameters by Name](https://docs.snowflake.com/en/sql-reference/parameters.html#limiting-the-list-of-parameters-by-name)\n"
                    },
                    "user": {
                        "type": "string",
                        "description": "If parameter_type is set to \"SESSION\" then user is the name of the user to display session parameters for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getParameters.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "objectName": {
                        "type": "string",
                        "description": "If parameter*type is set to \"OBJECT\" then object*name is the name of the object to display object parameters for.\n"
                    },
                    "objectType": {
                        "type": "string",
                        "description": "If parameter*type is set to \"OBJECT\" then object*type is the type of object to display object parameters for. Valid values are any object supported by the IN clause of the [SHOW PARAMETERS](https://docs.snowflake.com/en/sql-reference/sql/show-parameters.html#parameters) statement, including: WAREHOUSE | DATABASE | SCHEMA | TASK | TABLE\n"
                    },
                    "parameterType": {
                        "type": "string",
                        "description": "The type of parameter to filter by. Valid values are: \"ACCOUNT\", \"SESSION\", \"OBJECT\".\n"
                    },
                    "parameters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getParametersParameter:getParametersParameter"
                        },
                        "description": "The pipes in the schema\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Allows limiting the list of parameters by name using LIKE clause. Refer to [Limiting the List of Parameters by Name](https://docs.snowflake.com/en/sql-reference/parameters.html#limiting-the-list-of-parameters-by-name)\n"
                    },
                    "user": {
                        "type": "string",
                        "description": "If parameter_type is set to \"SESSION\" then user is the name of the user to display session parameters for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "parameters",
                    "id"
                ]
            }
        },
        "snowflake:index/getPipes:getPipes": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getPipes({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_pipes(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetPipes.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetPipes(ctx, \u0026snowflake.GetPipesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetPipesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getPipes(GetPipesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getPipes\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPipes.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPipes.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pipes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getPipesPipe:getPipesPipe"
                        },
                        "description": "The pipes in the schema\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the pipes from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "pipes",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getProcedures:getProcedures": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getProcedures({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_procedures(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetProcedures.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetProcedures(ctx, \u0026snowflake.GetProceduresArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetProceduresArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getProcedures(GetProceduresArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getProcedures\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProcedures.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProcedures.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "procedures": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getProceduresProcedure:getProceduresProcedure"
                        },
                        "description": "The procedures in the schema\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the procedures from.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "procedures",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getResourceMonitors:getResourceMonitors": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getResourceMonitors({});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_resource_monitors()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetResourceMonitors.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetResourceMonitors(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getResourceMonitors();\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getResourceMonitors\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getResourceMonitors.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "resourceMonitors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getResourceMonitorsResourceMonitor:getResourceMonitorsResourceMonitor"
                        },
                        "description": "The resource monitors in the database\n"
                    }
                },
                "type": "object",
                "required": [
                    "resourceMonitors",
                    "id"
                ]
            }
        },
        "snowflake:index/getRole:getRole": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst this = snowflake.getRole({\n    name: \"role1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_role(name=\"role1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = Snowflake.GetRole.Invoke(new()\n    {\n        Name = \"role1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.LookupRole(ctx, \u0026snowflake.LookupRoleArgs{\n\t\t\tName: \"role1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = SnowflakeFunctions.getRole(GetRoleArgs.builder()\n            .name(\"role1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      Function: snowflake:getRole\n      Arguments:\n        name: role1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The role for which to return metadata.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "The comment on the role\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The role for which to return metadata.\n"
                    }
                },
                "type": "object",
                "required": [
                    "comment",
                    "name",
                    "id"
                ]
            }
        },
        "snowflake:index/getRoles:getRoles": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst this = snowflake.getRoles({});\nconst ad = snowflake.getRoles({\n    pattern: \"SYSADMIN\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_roles()\nad = snowflake.get_roles(pattern=\"SYSADMIN\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = Snowflake.GetRoles.Invoke();\n\n    var ad = Snowflake.GetRoles.Invoke(new()\n    {\n        Pattern = \"SYSADMIN\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetRoles(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.GetRoles(ctx, \u0026snowflake.GetRolesArgs{\n\t\t\tPattern: pulumi.StringRef(\"SYSADMIN\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetRolesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = SnowflakeFunctions.getRoles();\n\n        final var ad = SnowflakeFunctions.getRoles(GetRolesArgs.builder()\n            .pattern(\"SYSADMIN\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      Function: snowflake:getRoles\n      Arguments: {}\n  ad:\n    fn::invoke:\n      Function: snowflake:getRoles\n      Arguments:\n        pattern: SYSADMIN\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRoles.\n",
                "properties": {
                    "pattern": {
                        "type": "string",
                        "description": "Filters the command output by object name.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getRoles.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Filters the command output by object name.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getRolesRole:getRolesRole"
                        },
                        "description": "List of all the roles which you can view across your entire account, including the system-defined roles and any custom roles that exist.\n"
                    }
                },
                "type": "object",
                "required": [
                    "roles",
                    "id"
                ]
            }
        },
        "snowflake:index/getRowAccessPolicies:getRowAccessPolicies": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getRowAccessPolicies({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_row_access_policies(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetRowAccessPolicies.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetRowAccessPolicies(ctx, \u0026snowflake.GetRowAccessPoliciesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetRowAccessPoliciesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getRowAccessPolicies(GetRowAccessPoliciesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getRowAccessPolicies\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRowAccessPolicies.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRowAccessPolicies.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rowAccessPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getRowAccessPoliciesRowAccessPolicy:getRowAccessPoliciesRowAccessPolicy"
                        },
                        "description": "The row access policy in the schema\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the row access policyfrom.\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "rowAccessPolicies",
                    "schema",
                    "id"
                ]
            }
        },
        "snowflake:index/getSchemas:getSchemas": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getSchemas({\n    database: \"MYDB\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_schemas(database=\"MYDB\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetSchemas.Invoke(new()\n    {\n        Database = \"MYDB\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetSchemas(ctx, \u0026snowflake.GetSchemasArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetSchemasArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getSchemas(GetSchemasArgs.builder()\n            .database(\"MYDB\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getSchemas\n      Arguments:\n        database: MYDB\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSchemas.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSchemas.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schemas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getSchemasSchema:getSchemasSchema"
                        },
                        "description": "The schemas in the database\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schemas",
                    "id"
                ]
            }
        },
        "snowflake:index/getSequences:getSequences": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getSequences({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_sequences(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetSequences.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetSequences(ctx, \u0026snowflake.GetSequencesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetSequencesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getSequences(GetSequencesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getSequences\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSequences.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSequences.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the sequences from.\n"
                    },
                    "sequences": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getSequencesSequence:getSequencesSequence"
                        },
                        "description": "The sequences in the schema\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "sequences",
                    "id"
                ]
            }
        },
        "snowflake:index/getShares:getShares": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst this = snowflake.getShares({});\nconst ad = snowflake.getShares({\n    pattern: \"usage\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nthis = snowflake.get_shares()\nad = snowflake.get_shares(pattern=\"usage\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = Snowflake.GetShares.Invoke();\n\n    var ad = Snowflake.GetShares.Invoke(new()\n    {\n        Pattern = \"usage\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetShares(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = snowflake.GetShares(ctx, \u0026snowflake.GetSharesArgs{\n\t\t\tPattern: pulumi.StringRef(\"usage\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetSharesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = SnowflakeFunctions.getShares();\n\n        final var ad = SnowflakeFunctions.getShares(GetSharesArgs.builder()\n            .pattern(\"usage\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      Function: snowflake:getShares\n      Arguments: {}\n  ad:\n    fn::invoke:\n      Function: snowflake:getShares\n      Arguments:\n        pattern: usage\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getShares.\n",
                "properties": {
                    "pattern": {
                        "type": "string",
                        "description": "Filters the command output by object name.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getShares.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Filters the command output by object name.\n"
                    },
                    "shares": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getSharesShare:getSharesShare"
                        },
                        "description": "List of all the shares available in the system.\n"
                    }
                },
                "type": "object",
                "required": [
                    "shares",
                    "id"
                ]
            }
        },
        "snowflake:index/getStages:getStages": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getStages({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_stages(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetStages.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetStages(ctx, \u0026snowflake.GetStagesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetStagesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getStages(GetStagesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getStages\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getStages.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getStages.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the stages from.\n"
                    },
                    "stages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getStagesStage:getStagesStage"
                        },
                        "description": "The stages in the schema\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "stages",
                    "id"
                ]
            }
        },
        "snowflake:index/getStorageIntegrations:getStorageIntegrations": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getStorageIntegrations({});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_storage_integrations()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetStorageIntegrations.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetStorageIntegrations(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getStorageIntegrations();\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getStorageIntegrations\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getStorageIntegrations.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "storageIntegrations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getStorageIntegrationsStorageIntegration:getStorageIntegrationsStorageIntegration"
                        },
                        "description": "The storage integrations in the database\n"
                    }
                },
                "type": "object",
                "required": [
                    "storageIntegrations",
                    "id"
                ]
            }
        },
        "snowflake:index/getStreams:getStreams": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getStreams({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_streams(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetStreams.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetStreams(ctx, \u0026snowflake.GetStreamsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetStreamsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getStreams(GetStreamsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getStreams\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getStreams.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getStreams.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the streams from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the streams from.\n"
                    },
                    "streams": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getStreamsStream:getStreamsStream"
                        },
                        "description": "The streams in the schema\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "streams",
                    "id"
                ]
            }
        },
        "snowflake:index/getSystemGenerateScimAccessToken:getSystemGenerateScimAccessToken": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst scim = snowflake.getSystemGenerateScimAccessToken({\n    integrationName: \"AAD_PROVISIONING\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\nscim = snowflake.get_system_generate_scim_access_token(integration_name=\"AAD_PROVISIONING\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var scim = Snowflake.GetSystemGenerateScimAccessToken.Invoke(new()\n    {\n        IntegrationName = \"AAD_PROVISIONING\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetSystemGenerateScimAccessToken(ctx, \u0026snowflake.GetSystemGenerateScimAccessTokenArgs{\n\t\t\tIntegrationName: \"AAD_PROVISIONING\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetSystemGenerateScimAccessTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var scim = SnowflakeFunctions.getSystemGenerateScimAccessToken(GetSystemGenerateScimAccessTokenArgs.builder()\n            .integrationName(\"AAD_PROVISIONING\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  scim:\n    fn::invoke:\n      Function: snowflake:getSystemGenerateScimAccessToken\n      Arguments:\n        integrationName: AAD_PROVISIONING\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSystemGenerateScimAccessToken.\n",
                "properties": {
                    "integrationName": {
                        "type": "string",
                        "description": "SCIM Integration Name\n"
                    }
                },
                "type": "object",
                "required": [
                    "integrationName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSystemGenerateScimAccessToken.\n",
                "properties": {
                    "accessToken": {
                        "type": "string",
                        "description": "SCIM Access Token\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "integrationName": {
                        "type": "string",
                        "description": "SCIM Integration Name\n"
                    }
                },
                "type": "object",
                "required": [
                    "accessToken",
                    "integrationName",
                    "id"
                ]
            }
        },
        "snowflake:index/getSystemGetAwsSnsIamPolicy:getSystemGetAwsSnsIamPolicy": {
            "inputs": {
                "description": "A collection of arguments for invoking getSystemGetAwsSnsIamPolicy.\n",
                "properties": {
                    "awsSnsTopicArn": {
                        "type": "string",
                        "description": "Amazon Resource Name (ARN) of the SNS topic for your S3 bucket\n"
                    }
                },
                "type": "object",
                "required": [
                    "awsSnsTopicArn"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSystemGetAwsSnsIamPolicy.\n",
                "properties": {
                    "awsSnsTopicArn": {
                        "type": "string",
                        "description": "Amazon Resource Name (ARN) of the SNS topic for your S3 bucket\n"
                    },
                    "awsSnsTopicPolicyJson": {
                        "type": "string",
                        "description": "IAM policy for Snowflake’s SQS queue to subscribe to this topic\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "awsSnsTopicArn",
                    "awsSnsTopicPolicyJson",
                    "id"
                ]
            }
        },
        "snowflake:index/getSystemGetPrivateLinkConfig:getSystemGetPrivateLinkConfig": {
            "outputs": {
                "description": "A collection of values returned by getSystemGetPrivateLinkConfig.\n",
                "properties": {
                    "accountName": {
                        "type": "string",
                        "description": "The name of your Snowflake account.\n"
                    },
                    "accountUrl": {
                        "type": "string",
                        "description": "The URL used to connect to Snowflake through AWS PrivateLink or Azure Private Link.\n"
                    },
                    "awsVpceId": {
                        "type": "string",
                        "description": "The AWS VPCE ID for your account.\n"
                    },
                    "azurePlsId": {
                        "type": "string",
                        "description": "The Azure Private Link Service ID for your account.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "internalStage": {
                        "type": "string",
                        "description": "The endpoint to connect to your Snowflake internal stage using AWS PrivateLink or Azure Private Link.\n"
                    },
                    "ocspUrl": {
                        "type": "string",
                        "description": "The OCSP URL corresponding to your Snowflake account that uses AWS PrivateLink or Azure Private Link.\n"
                    },
                    "regionlessAccountUrl": {
                        "type": "string",
                        "description": "The regionless URL to connect to your Snowflake account using AWS PrivateLink, Azure Private Link, or Google Cloud Private Service Connect.\n"
                    },
                    "regionlessSnowsightUrl": {
                        "type": "string",
                        "description": "The URL for your organization to access Snowsight using Private Connectivity to the Snowflake Service.\n"
                    },
                    "snowsightUrl": {
                        "type": "string",
                        "description": "The URL containing the cloud region to access Snowsight and the Snowflake Marketplace using Private Connectivity to the Snowflake Service.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accountName",
                    "accountUrl",
                    "awsVpceId",
                    "azurePlsId",
                    "internalStage",
                    "ocspUrl",
                    "regionlessAccountUrl",
                    "regionlessSnowsightUrl",
                    "snowsightUrl",
                    "id"
                ]
            }
        },
        "snowflake:index/getSystemGetSnowflakePlatformInfo:getSystemGetSnowflakePlatformInfo": {
            "outputs": {
                "description": "A collection of values returned by getSystemGetSnowflakePlatformInfo.\n",
                "properties": {
                    "awsVpcIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Snowflake AWS Virtual Private Cloud IDs\n"
                    },
                    "azureVnetSubnetIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Snowflake Azure Virtual Network Subnet IDs\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "awsVpcIds",
                    "azureVnetSubnetIds",
                    "id"
                ]
            }
        },
        "snowflake:index/getTables:getTables": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getTables({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_tables(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetTables.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetTables(ctx, \u0026snowflake.GetTablesArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetTablesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getTables(GetTablesArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getTables\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getTables.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTables.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the tables from.\n"
                    },
                    "tables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getTablesTable:getTablesTable"
                        },
                        "description": "The tables in the schema\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "tables",
                    "id"
                ]
            }
        },
        "snowflake:index/getTasks:getTasks": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getTasks({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_tasks(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetTasks.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetTasks(ctx, \u0026snowflake.GetTasksArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetTasksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getTasks(GetTasksArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getTasks\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getTasks.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTasks.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the tasks from.\n"
                    },
                    "tasks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getTasksTask:getTasksTask"
                        },
                        "description": "The tasks in the schema\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "tasks",
                    "id"
                ]
            }
        },
        "snowflake:index/getUsers:getUsers": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getUsers({\n    pattern: \"user1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_users(pattern=\"user1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetUsers.Invoke(new()\n    {\n        Pattern = \"user1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetUsers(ctx, \u0026snowflake.GetUsersArgs{\n\t\t\tPattern: \"user1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getUsers(GetUsersArgs.builder()\n            .pattern(\"user1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getUsers\n      Arguments:\n        pattern: user1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getUsers.\n",
                "properties": {
                    "pattern": {
                        "type": "string",
                        "description": "Users pattern for which to return metadata. Please refer to LIKE keyword from snowflake documentation : https://docs.snowflake.com/en/sql-reference/sql/show-users.html#parameters\n"
                    }
                },
                "type": "object",
                "required": [
                    "pattern"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getUsers.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "pattern": {
                        "type": "string",
                        "description": "Users pattern for which to return metadata. Please refer to LIKE keyword from snowflake documentation : https://docs.snowflake.com/en/sql-reference/sql/show-users.html#parameters\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getUsersUser:getUsersUser"
                        },
                        "description": "The users in the database\n"
                    }
                },
                "type": "object",
                "required": [
                    "pattern",
                    "users",
                    "id"
                ]
            }
        },
        "snowflake:index/getViews:getViews": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getViews({\n    database: \"MYDB\",\n    schema: \"MYSCHEMA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_views(database=\"MYDB\",\n    schema=\"MYSCHEMA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetViews.Invoke(new()\n    {\n        Database = \"MYDB\",\n        Schema = \"MYSCHEMA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetViews(ctx, \u0026snowflake.GetViewsArgs{\n\t\t\tDatabase: \"MYDB\",\n\t\t\tSchema:   \"MYSCHEMA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport com.pulumi.snowflake.inputs.GetViewsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getViews(GetViewsArgs.builder()\n            .database(\"MYDB\")\n            .schema(\"MYSCHEMA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getViews\n      Arguments:\n        database: MYDB\n        schema: MYSCHEMA\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getViews.\n",
                "properties": {
                    "database": {
                        "type": "string"
                    },
                    "schema": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getViews.\n",
                "properties": {
                    "database": {
                        "type": "string",
                        "description": "The database from which to return the schemas from.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema from which to return the views from.\n"
                    },
                    "views": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getViewsView:getViewsView"
                        },
                        "description": "The views in the schema\n"
                    }
                },
                "type": "object",
                "required": [
                    "database",
                    "schema",
                    "views",
                    "id"
                ]
            }
        },
        "snowflake:index/getWarehouses:getWarehouses": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as snowflake from \"@pulumi/snowflake\";\n\nconst current = snowflake.getWarehouses({});\n```\n```python\nimport pulumi\nimport pulumi_snowflake as snowflake\n\ncurrent = snowflake.get_warehouses()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Snowflake = Pulumi.Snowflake;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Snowflake.GetWarehouses.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-snowflake/sdk/go/snowflake\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := snowflake.GetWarehouses(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.snowflake.SnowflakeFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = SnowflakeFunctions.getWarehouses();\n\n    }\n}\n```\n```yaml\nvariables:\n  current:\n    fn::invoke:\n      Function: snowflake:getWarehouses\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getWarehouses.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "warehouses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/snowflake:index/getWarehousesWarehouse:getWarehousesWarehouse"
                        },
                        "description": "The warehouses in the database\n"
                    }
                },
                "type": "object",
                "required": [
                    "warehouses",
                    "id"
                ]
            }
        }
    }
}